diff --git a/src/Algorithm/IpBacktrackingLineSearch.cpp b/src/Algorithm/IpBacktrackingLineSearch.cpp
index 6782ac59..e7c1addb 100644
--- a/src/Algorithm/IpBacktrackingLineSearch.cpp
+++ b/src/Algorithm/IpBacktrackingLineSearch.cpp
@@ -14,6 +14,7 @@
 
 #include <cmath>
 #include <limits>
+#include <iostream>
 
 namespace Ipopt
 {
@@ -257,6 +258,8 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
                   "--> Starting line search in iteration %" IPOPT_INDEX_FORMAT " <--\n", IpData().iter_count());
 
    Number curr_mu = IpData().curr_mu();
+       std::cout << "IpoptAlgorithm::FindAcceptableTrialPoint0 curr_mu="<<curr_mu<< std::endl << std::flush;
+
    if( last_mu_ != curr_mu )
    {
       Jnlst().Printf(J_DETAILED, J_LINE_SEARCH,
@@ -275,6 +278,7 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
    // by the Acceptor.
    if( !acceptor_->NeverRestorationPhase() && IpCq().IsSquareProblem() )
    {
+       std::cout << "IpoptAlgorithm::FindAcceptableTrialPoint NeverRestorationPhase"<< std::endl << std::flush;
       //expect_infeasible_problem_ = true;
       expect_infeasible_problem_ctol_ = 0.;
    }
@@ -283,6 +287,7 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
    // level to be restored if things fail later
    if( CurrentIsAcceptable() )
    {
+       std::cout << "IpoptAlgorithm::FindAcceptableTrialPoint CurrentIsAcceptable"<< std::endl << std::flush;
       Jnlst().Printf(J_DETAILED, J_LINE_SEARCH,
                      "Storing current iterate as backup acceptable point.\n");
       StoreAcceptablePoint();
@@ -296,6 +301,7 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
    SmartPtr<IteratesVector> actual_delta;
 
    bool goto_resto = false;
+   std::cout << "IpoptAlgorithm::FindAcceptableTrialPoint fallback_activated_="<<fallback_activated_<< std::endl << std::flush;
    if( fallback_activated_ )
    {
       // In this case, the algorithm had trouble to continue and wants
@@ -317,6 +323,7 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
       }
       else
       {
+          std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint throw STEP_COMPUTATION_FAILED1"<< std::endl << std::flush;
          THROW_EXCEPTION(STEP_COMPUTATION_FAILED,
                          "We are in an emergency mode, but no restoration phase or other fall back is available.");
       }
@@ -328,7 +335,10 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
       acceptor_->InitThisLineSearch(in_watchdog_);
       actual_delta = IpData().delta()->MakeNewContainer();
    }
+   
+   std::cout << "IpoptAlgorithm::FindAcceptableTrialPoint in_watchdog_="<<in_watchdog_<< std::endl << std::flush;
 
+      std::cout << "IpoptAlgorithm::FindAcceptableTrialPoint start_with_resto_="<<start_with_resto_<< std::endl << std::flush;
    if( start_with_resto_ )
    {
       // If the user requested to start with the restoration phase,
@@ -345,12 +355,15 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
       goto_resto = true;
    }
 
+   std::cout << "IpoptAlgorithm::FindAcceptableTrialPoint goto_resto="<<goto_resto<< std::endl << std::flush;
+   
    bool accept = false;
    Index n_steps = 0;
    Number alpha_primal = 0.;
 
    // Check if search direction becomes too small
    bool tiny_step = (!goto_resto && DetectTinyStep());
+std::cout << "IpoptAlgorithm::FindAcceptableTrialPoint tiny_step="<<tiny_step<< std::endl << std::flush;
 
    if( in_watchdog_ && (goto_resto || tiny_step) )
    {
@@ -366,8 +379,10 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
    if( watchdog_shortened_iter_trigger_ > 0 && !in_watchdog_ && !goto_resto && !tiny_step && !in_soft_resto_phase_
        && !expect_infeasible_problem_ && watchdog_shortened_iter_ >= watchdog_shortened_iter_trigger_ )
    {
+       std::cout << "IpoptAlgorithm::FindAcceptableTrialPoint StartWatchDog"<< std::endl << std::flush;
       StartWatchDog();
    }
+std::cout << "IpoptAlgorithm::FindAcceptableTrialPoint tiny_step="<<tiny_step<< std::endl << std::flush;
 
    // Handle the situation of a tiny step
    if( tiny_step )
@@ -503,6 +518,7 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
    // If line search has been aborted because the step size becomes
    // too small, go to the restoration phase or continue with soft
    // restoration phase
+   std::cout << "IpoptAlgorithm::FindAcceptableTrialPoint accept="<<accept<< std::endl << std::flush;
    if( !accept )
    {
       // If we are not asked to do a rigorous line search, do no call
@@ -566,11 +582,16 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
             }
 
             // ToDo make the 1e-2 below a parameter?
+            
+            std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint curr_constraint_violation="<<IpCq().curr_constraint_violation()<< std::endl << std::flush;
+            std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint unscaled_curr_nlp_constraint_violation="<<IpCq().unscaled_curr_nlp_constraint_violation(NORM_MAX)<< std::endl << std::flush;
+
             // added second criteria to cover cases where tol has been set to a large value
             if( IpCq().curr_constraint_violation() <= 1e-2 * IpData().tol() &&
                 IpCq().unscaled_curr_nlp_constraint_violation(NORM_MAX) <= 1e-1 * constr_viol_tol_ )
             {
                bool found_acceptable = RestoreAcceptablePoint();
+               std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint found_acceptable="<<found_acceptable<< std::endl << std::flush;
                if( found_acceptable )
                {
                   Jnlst().Printf(J_WARNING, J_LINE_SEARCH,
@@ -581,6 +602,7 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
                }
                else
                {
+                    std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint throw STEP_COMPUTATION_FAILED2"<< std::endl << std::flush;
                   Jnlst().Printf(J_STRONGWARNING, J_LINE_SEARCH,
                                  "Cannot call restoration phase at point that is almost feasible %s(violation %e).\nAbort in line search due to no other fall back.\n",
                                  dynamic_cast<OrigIpoptNLP*>(GetRawPtr(IpCq().GetIpoptNLP())) == NULL ? "for the restoration NLP " : "",
@@ -722,6 +744,7 @@ bool BacktrackingLineSearch::DoBacktrackingLineSearch(
       corr_taken = true;
    }
 
+   std::cout << "IpoptAlgorithm::DoBacktrackingLineSearch accept="<<accept<< std::endl << std::flush;
    if( !accept )
    {
       // Loop over decreasing step sizes until acceptable point is
@@ -839,6 +862,7 @@ bool BacktrackingLineSearch::DoBacktrackingLineSearch(
       IpData().Append_info_string("C");
    }
 
+   std::cout << "IpoptAlgorithm::DoBacktrackingLineSearch result accept="<<accept<< std::endl << std::flush;
    return accept;
 }
 
@@ -918,6 +942,7 @@ void BacktrackingLineSearch::PerformDualStep(
    IpData().SetTrialBoundMultipliersFromStep(alpha_dual, *delta->z_L(), *delta->z_U(), *delta->v_L(), *delta->v_U());
 
    Number alpha_y = -1.;
+   std::cout << "IpoptAlgorithm::PerformDualStep alpha_for_y_="<<alpha_for_y_<< std::endl << std::flush;
    switch( alpha_for_y_ )
    {
       case LSACCEPTOR_ALPHA_FOR_Y:
@@ -1163,6 +1188,7 @@ bool BacktrackingLineSearch::TrySoftRestoStep(
    {
       Jnlst().Printf(J_DETAILED, J_LINE_SEARCH,
                      "  Trial step acceptable with respect to original backtracking globalization.\n");
+      std::cout << "IpoptAlgorithm::PerformDualStep TrySoftRestoStep"<< std::endl << std::flush;
       satisfies_original_criterion = true;
       return true;
    }
@@ -1213,7 +1239,7 @@ bool BacktrackingLineSearch::DetectTinyStep()
 
    Number max_step_x;
    Number max_step_s;
-
+std::cout << "IpoptAlgorithm::DetectTinyStep tiny_step_tol_="<<tiny_step_tol_<< std::endl << std::flush;
    if( tiny_step_tol_ == 0. )
    {
       return false;
@@ -1230,6 +1256,7 @@ bool BacktrackingLineSearch::DetectTinyStep()
    SmartPtr<Vector> tmp2 = IpData().delta()->x()->MakeNewCopy();
    tmp2->ElementWiseDivide(*tmp);
    max_step_x = tmp2->Amax();
+   std::cout << "IpoptAlgorithm::DetectTinyStep max_step_x="<<max_step_x<< std::endl << std::flush;
    Jnlst().Printf(J_MOREDETAILED, J_LINE_SEARCH,
                   "Relative step size for delta_x = %e\n", max_step_x);
    if( max_step_x > tiny_step_tol_ )
@@ -1248,6 +1275,7 @@ bool BacktrackingLineSearch::DetectTinyStep()
    max_step_s = tmp2->Amax();
    Jnlst().Printf(J_MOREDETAILED, J_LINE_SEARCH,
                   "Relative step size for delta_s = %e\n", max_step_s);
+   std::cout << "IpoptAlgorithm::DetectTinyStep max_step_x="<<max_step_x<< std::endl << std::flush;
    if( max_step_s > tiny_step_tol_ )
    {
       return false;
@@ -1257,6 +1285,7 @@ bool BacktrackingLineSearch::DetectTinyStep()
    // might be at a starting point that is already a local minimizer
    // of the constraint violation
    const Number cviol = IpCq().curr_constraint_violation();
+   std::cout << "IpoptAlgorithm::DetectTinyStep cviol="<<cviol<< std::endl << std::flush;
    if( cviol > 1e-4 ) // ToDo: adapt parameter?
    {
       return false;
@@ -1270,6 +1299,7 @@ bool BacktrackingLineSearch::DetectTinyStep()
 
 bool BacktrackingLineSearch::CurrentIsAcceptable()
 {
+    std::cout << "BacktrackingLineSearch::CurrentIsAcceptable"<< std::endl << std::flush;
    return (IsValid(conv_check_) && conv_check_->CurrentIsAcceptable());
 }
 
@@ -1289,13 +1319,15 @@ bool BacktrackingLineSearch::RestoreAcceptablePoint()
 
    if( !IsValid(acceptable_iterate_) )
    {
+          std::cout << "BacktrackingLineSearch::RestoreAcceptablePoint false="<< std::endl << std::flush;
+
       return false;
    }
 
    SmartPtr<IteratesVector> prev_iterate = acceptable_iterate_->MakeNewContainer();
    IpData().set_trial(prev_iterate);
    IpData().AcceptTrialPoint();
-
+std::cout << "BacktrackingLineSearch::RestoreAcceptablePoint true="<< std::endl << std::flush;
    return true;
 }
 
diff --git a/src/Algorithm/IpIpoptAlg.cpp b/src/Algorithm/IpIpoptAlg.cpp
index d9092e5c..6db205d0 100644
--- a/src/Algorithm/IpIpoptAlg.cpp
+++ b/src/Algorithm/IpIpoptAlg.cpp
@@ -18,6 +18,7 @@
 #if IPOPT_CHECKLEVEL > 1 && defined(IPOPT_HAS_FEENABLEEXCEPT)
 #include <cfenv>
 #endif
+#include <iostream>
 
 namespace Ipopt
 {
@@ -293,6 +294,7 @@ SolverReturn IpoptAlgorithm::Optimize(
    bool isResto /*= false */
 )
 {
+      std::cout << "IpoptAlgorithm::Optimize0"<< std::endl << std::flush;
    DBG_START_METH("IpoptAlgorithm::Optimize", dbg_verbosity);
 
    // Start measuring CPU time
@@ -341,6 +343,7 @@ SolverReturn IpoptAlgorithm::Optimize(
 
       IpData().TimingStats().CheckConvergence().Start();
       ConvergenceCheck::ConvergenceStatus conv_status = conv_check_->CheckConvergence();
+      std::cout << "IpoptAlgorithm::Optimize1 conv_status"<<conv_status<< std::endl << std::flush;
       IpData().TimingStats().CheckConvergence().End();
 
       // main loop
@@ -379,6 +382,7 @@ SolverReturn IpoptAlgorithm::Optimize(
          // If we are in the emergency mode, ask the line search object
          // to go to the fallback options.  If that isn't possible,
          // issue error message
+         std::cout << "IpoptAlgorithm::Optimize2 emergency_mode"<<emergency_mode<< std::endl << std::flush;
          if( emergency_mode )
          {
             if( line_search_->ActivateFallbackMechanism() )
@@ -388,6 +392,9 @@ SolverReturn IpoptAlgorithm::Optimize(
             }
             else
             {
+                  
+                  std::cout << "IpoptAlgorithm::Optimize1 throw STEP_COMPUTATION_FAILED"<< std::endl << std::flush;
+                  
                Jnlst().Printf(J_ERROR, J_MAIN,
                               "ERROR: Problem in step computation, but emergency mode cannot be activated.\n");
                THROW_EXCEPTION(STEP_COMPUTATION_FAILED, "Step computation failed.");
@@ -413,6 +420,7 @@ SolverReturn IpoptAlgorithm::Optimize(
 
          IpData().TimingStats().CheckConvergence().Start();
          conv_status = conv_check_->CheckConvergence();
+         std::cout << "IpoptAlgorithm::Optimize2 conv_status"<<conv_status<< std::endl << std::flush;
          IpData().TimingStats().CheckConvergence().End();
       }
 
@@ -524,6 +532,7 @@ SolverReturn IpoptAlgorithm::Optimize(
    }
    catch( STEP_COMPUTATION_FAILED& exc )
    {
+         std::cout << "IpoptAlgorithm::Optimize STEP_COMPUTATION_FAILED"<< std::endl << std::flush;
       exc.ReportException(Jnlst(), J_MOREDETAILED);
       IpData().TimingStats().ComputeAcceptableTrialPoint().EndIfStarted();
       retval = ERROR_IN_STEP_COMPUTATION;
@@ -559,6 +568,7 @@ SolverReturn IpoptAlgorithm::Optimize(
    }
 
    DBG_ASSERT(retval != UNASSIGNED && "Unknown return code in the algorithm");
+   std::cout << "IpoptAlgorithm::Optimize retval="<<retval<< std::endl << std::flush;
    return retval;
 }
 
@@ -582,7 +592,7 @@ bool IpoptAlgorithm::UpdateBarrierParameter()
    Jnlst().Printf(J_DETAILED, J_MAIN,
                   "\n**************************************************\n\n");
    bool retval = mu_update_->UpdateBarrierParameter();
-
+std::cout << "IpoptAlgorithm::UpdateBarrierParameter retval="<<retval<< std::endl << std::flush;
    if( retval )
    {
       Jnlst().Printf(J_DETAILED, J_MAIN,
@@ -609,7 +619,7 @@ bool IpoptAlgorithm::ComputeSearchDirection()
                   "\n**************************************************\n\n");
 
    bool retval = search_dir_calculator_->ComputeSearchDirection();
-
+std::cout << "IpoptAlgorithm::ComputeSearchDirection0 retval="<<retval<< std::endl << std::flush;
    if( retval )
    {
       Jnlst().Printf(J_MOREVECTOR, J_MAIN,
@@ -633,6 +643,7 @@ void IpoptAlgorithm::ComputeAcceptableTrialPoint()
                   "*** Finding Acceptable Trial Point for Iteration %" IPOPT_INDEX_FORMAT ":", IpData().iter_count());
    Jnlst().Printf(J_DETAILED, J_MAIN,
                   "\n**************************************************\n\n");
+   std::cout << "IpoptAlgorithm::ComputeAcceptableTrialPoint"<< std::endl << std::flush;
    line_search_->FindAcceptableTrialPoint();
 }
 
@@ -652,17 +663,21 @@ void IpoptAlgorithm::InitializeIterates()
 void IpoptAlgorithm::AcceptTrialPoint()
 {
    DBG_START_METH("IpoptAlgorithm::AcceptTrialPoint", dbg_verbosity);
+   std::cout << "IpoptAlgorithm::AcceptTrialPoint0"<< std::endl << std::flush;
    // If the line search didn't determine a new acceptable trial
    // point, do not accept a new iterate
    if( line_search_->CheckSkippedLineSearch() )
    {
       Jnlst().Printf(J_SUMMARY, J_MAIN,
                      "Line search didn't find acceptable trial point.\n");
+std::cout << "IpoptAlgorithm::AcceptTrialPoint0 CheckSkippedLineSearch"<< std::endl << std::flush;
       return;
    }
+   
 
    // Adjust the bounds if necessary
    Index adjusted_slacks = IpCq().AdjustedTrialSlacks();
+   std::cout << "IpoptAlgorithm::AcceptTrialPoint0.1 adjusted_slacks="<<adjusted_slacks<< std::endl << std::flush;
    DBG_PRINT((1, "adjusted_slacks = %" IPOPT_INDEX_FORMAT "\n", adjusted_slacks));
    if( adjusted_slacks > 0 )
    {
@@ -684,23 +699,38 @@ void IpoptAlgorithm::AcceptTrialPoint()
          IpNLP().d_L()->Print(Jnlst(), J_VECTOR, J_MAIN, "old_d_L");
          IpNLP().d_U()->Print(Jnlst(), J_VECTOR, J_MAIN, "old_d_U");
       }
+      
+      std::cout << "IpoptAlgorithm::AcceptTrialPoint x.sum="<< IpData().trial()->x()->Sum()<<" min="<< IpData().trial()->x()->Min()<<" max="<< IpData().trial()->x()->Max()<<std::endl << std::flush;
+
 
       SmartPtr<Vector> new_x_l = IpNLP().x_L()->MakeNew();
       IpNLP().Px_L()->TransMultVector(1.0, *IpData().trial()->x(), 0.0, *new_x_l);
       new_x_l->Axpy(-1.0, *IpCq().trial_slack_x_L());
 
+      
+      std::cout << "IpoptAlgorithm::AcceptTrialPoint new_x_l.sum="<<new_x_l->Sum()<<" min="<<new_x_l->Min()<<" max="<<new_x_l->Max()<<std::endl << std::flush;
+
+      
+      
       SmartPtr<Vector> new_x_u = IpNLP().x_U()->MakeNew();
       IpNLP().Px_U()->TransMultVector(1.0, *IpData().trial()->x(), 0.0, *new_x_u);
       new_x_u->Axpy(1.0, *IpCq().trial_slack_x_U());
+      
+      std::cout << "IpoptAlgorithm::AcceptTrialPoint new_x_u.sum="<<new_x_u->Sum()<<" min="<<new_x_u->Min()<<" max="<<new_x_u->Max()<<std::endl << std::flush;
+      
 
       SmartPtr<Vector> new_d_l = IpNLP().d_L()->MakeNew();
       IpNLP().Pd_L()->TransMultVector(1.0, *IpData().trial()->s(), 0.0, *new_d_l);
       new_d_l->Axpy(-1.0, *IpCq().trial_slack_s_L());
 
+      std::cout << "IpoptAlgorithm::AcceptTrialPoint new_d_l.sum="<<new_d_l->Sum()<<" min="<<new_d_l->Min()<<" max="<<new_d_l->Max()<<std::endl << std::flush;
+      
       SmartPtr<Vector> new_d_u = IpNLP().d_U()->MakeNew();
       IpNLP().Pd_U()->TransMultVector(1.0, *IpData().trial()->s(), 0.0, *new_d_u);
       new_d_u->Axpy(1.0, *IpCq().trial_slack_s_U());
 
+      std::cout << "IpoptAlgorithm::AcceptTrialPoint new_d_u.sum="<<new_d_u->Sum()<<" min="<<new_d_u->Min()<<" max="<<new_d_u->Max()<<std::endl << std::flush;
+      
       IpNLP().AdjustVariableBounds(*new_x_l, *new_x_u, *new_d_l, *new_d_u);
 
       if( Jnlst().ProduceOutput(J_VECTOR, J_MAIN) )
@@ -720,6 +750,7 @@ void IpoptAlgorithm::AcceptTrialPoint()
    SmartPtr<const Vector> new_z_L;
    max_correction = correct_bound_multiplier(*IpData().trial()->z_L(), *IpCq().trial_slack_x_L(),
                     *IpCq().trial_compl_x_L(), new_z_L);
+   std::cout << "IpoptAlgorithm::AcceptTrialPoint3.1 max_correction="<<max_correction<< std::endl << std::flush;
    if( max_correction > 0. )
    {
       Jnlst().Printf(J_DETAILED, J_MAIN,
@@ -730,6 +761,7 @@ void IpoptAlgorithm::AcceptTrialPoint()
    SmartPtr<const Vector> new_z_U;
    max_correction = correct_bound_multiplier(*IpData().trial()->z_U(), *IpCq().trial_slack_x_U(),
                     *IpCq().trial_compl_x_U(), new_z_U);
+   std::cout << "IpoptAlgorithm::AcceptTrialPoint3.2 max_correction="<<max_correction<< std::endl << std::flush;
    if( max_correction > 0. )
    {
       Jnlst().Printf(J_DETAILED, J_MAIN,
@@ -740,6 +772,7 @@ void IpoptAlgorithm::AcceptTrialPoint()
    SmartPtr<const Vector> new_v_L;
    max_correction = correct_bound_multiplier(*IpData().trial()->v_L(), *IpCq().trial_slack_s_L(),
                     *IpCq().trial_compl_s_L(), new_v_L);
+std::cout << "IpoptAlgorithm::AcceptTrialPoint3.3 max_correction="<<max_correction<< std::endl << std::flush;
    if( max_correction > 0. )
    {
       Jnlst().Printf(J_DETAILED, J_MAIN,
@@ -750,6 +783,7 @@ void IpoptAlgorithm::AcceptTrialPoint()
    SmartPtr<const Vector> new_v_U;
    max_correction = correct_bound_multiplier(*IpData().trial()->v_U(), *IpCq().trial_slack_s_U(),
                     *IpCq().trial_compl_s_U(), new_v_U);
+   std::cout << "IpoptAlgorithm::AcceptTrialPoint3.4 max_correction="<<max_correction<< std::endl << std::flush;
    if( max_correction > 0. )
    {
       Jnlst().Printf(J_DETAILED, J_MAIN,
@@ -760,7 +794,7 @@ void IpoptAlgorithm::AcceptTrialPoint()
    SmartPtr<IteratesVector> trial = IpData().trial()->MakeNewContainer();
    trial->Set_bound_mult(*new_z_L, *new_z_U, *new_v_L, *new_v_U);
    IpData().set_trial(trial);
-
+std::cout << "IpoptAlgorithm::AcceptTrialPoint3.5 corrected="<<corrected<< std::endl << std::flush;
    if( corrected )
    {
       IpData().Append_info_string("z");
@@ -794,6 +828,7 @@ void IpoptAlgorithm::AcceptTrialPoint()
          SmartPtr<Vector> y_c = IpData().curr()->y_c()->MakeNew();
          SmartPtr<Vector> y_d = IpData().curr()->y_d()->MakeNew();
          bool retval = eq_multiplier_calculator_->CalculateMultipliers(*y_c, *y_d);
+         std::cout << "IpoptAlgorithm::AcceptTrialPoint5 CalculateMultipliers="<<retval<< std::endl << std::flush;
          if( retval )
          {
             SmartPtr<const IteratesVector> curr = IpData().curr();
@@ -862,6 +897,8 @@ void IpoptAlgorithm::ComputeFeasibilityMultipliers()
 
    // if not primal feasible yet, then do not compute multipliers yet
    Number constr_viol = IpCq().unscaled_curr_nlp_constraint_violation(NORM_MAX);
+   std::cout << "IpoptAlgorithm::ComputeFeasibilityMultipliers0 constr_viol="<<constr_viol<< " tol="<<constr_viol_tol_<< std::endl << std::flush;
+   
    if( constr_viol > constr_viol_tol_ )
    {
       return;
@@ -878,6 +915,8 @@ void IpoptAlgorithm::ComputeFeasibilityMultipliers()
 
    IpData().TimingStats().CheckConvergence().Start();
    ConvergenceCheck::ConvergenceStatus conv_status = conv_check_->CheckConvergence(false);
+   
+   std::cout << "IpoptAlgorithm::ComputeFeasibilityMultipliers1 conv_status="<<conv_status<< std::endl << std::flush;
    IpData().TimingStats().CheckConvergence().End();
 
    // if converged or reached some limit, then do not update multipliers
@@ -909,6 +948,7 @@ void IpoptAlgorithm::ComputeFeasibilityMultipliers()
    IpData().set_trial(iterates);
    IpData().AcceptTrialPoint();
    bool retval = eq_multiplier_calculator_->CalculateMultipliers(*y_c, *y_d);
+   std::cout << "IpoptAlgorithm::ComputeFeasibilityMultipliers2 retval="<<retval<< std::endl << std::flush;
    if( retval )
    {
       //TODO Check if following line is really necessary
@@ -951,7 +991,7 @@ void IpoptAlgorithm::ComputeFeasibilityMultipliersPostprocess()
    DBG_START_METH("IpoptAlgorithm::ComputeFeasibilityMultipliersPostprocess",
                   dbg_verbosity);
    DBG_ASSERT(IpCq().IsSquareProblem());
-
+std::cout << "IpoptAlgorithm::ComputeFeasibilityMultipliersPostprocess0"<< std::endl << std::flush;
    // if we don't have an object for computing least square
    // multipliers we don't compute them
    if( IsNull(eq_multiplier_calculator_) )
@@ -979,6 +1019,7 @@ void IpoptAlgorithm::ComputeFeasibilityMultipliersPostprocess()
    IpData().set_trial(iterates);
    IpData().AcceptTrialPoint();
    bool retval = eq_multiplier_calculator_->CalculateMultipliers(*y_c, *y_d);
+   std::cout << "IpoptAlgorithm::ComputeFeasibilityMultipliersPostprocess1 retval="<<retval<< std::endl << std::flush;
    if( retval )
    {
       //TODO Check if following line is really necessary
@@ -1061,6 +1102,8 @@ Number IpoptAlgorithm::correct_bound_multiplier(
 {
    DBG_START_METH("IpoptAlgorithm::CorrectBoundMultiplier",
                   dbg_verbosity);
+   
+      std::cout << "IpoptAlgorithm::correct_bound_multiplier zdim="<<trial_z.Dim()<<" kappa_sigma_="<<kappa_sigma_<<std::endl << std::flush;
 
    if( kappa_sigma_ < 1. || trial_z.Dim() == 0 )
    {
@@ -1081,28 +1124,38 @@ Number IpoptAlgorithm::correct_bound_multiplier(
    {
       mu = IpData().curr_mu();
    }
+   std::cout << "IpoptAlgorithm::correct_bound_multiplier mu="<<mu<<std::endl << std::flush;
+   
    DBG_PRINT((1, "mu = %8.2e\n", mu));
    DBG_PRINT_VECTOR(2, "trial_z", trial_z);
+std::cout << "IpoptAlgorithm::correct_bound_multiplier trial_z.sum="<<trial_z.Sum()<<" min="<<trial_z.Min()<<" max="<<trial_z.Max()<<std::endl << std::flush;
+std::cout << "IpoptAlgorithm::correct_bound_multiplier trial_slack.sum="<<trial_slack.Sum()<<" min="<<trial_slack.Min()<<" max="<<trial_slack.Max()<<std::endl << std::flush;
+std::cout << "IpoptAlgorithm::correct_bound_multiplier trial_compl.sum="<<trial_compl.Sum()<<" min="<<trial_compl.Min()<<" max="<<trial_compl.Max()<<std::endl << std::flush;
 
    // First check quickly if anything need to be corrected, using the
    // trial complementarity directly.  Here, Amax is the same as Max
    // (and we use Amax because that can be used later)
    if( trial_compl.Amax() <= kappa_sigma_ * mu && trial_compl.Min() >= 1. / kappa_sigma_ * mu )
    {
+         std::cout << "IpoptAlgorithm::correct_bound_multiplier Amax return"<<std::endl << std::flush;
       new_trial_z = &trial_z;
       return 0.;
    }
 
+   
+   
    SmartPtr<Vector> one_over_s = trial_z.MakeNew();
    one_over_s->Copy(trial_slack);
    one_over_s->ElementWiseReciprocal();
-
+   
    SmartPtr<Vector> step_z = trial_z.MakeNew();
+std::cout << "IpoptAlgorithm::correct_bound_multiplier one_over_s.sum="<<one_over_s->Sum()<<" min="<<one_over_s->Min()<<" max="<<one_over_s->Max()<<std::endl << std::flush;
    step_z->AddTwoVectors(kappa_sigma_ * mu, *one_over_s, -1., trial_z, 0.);
-
+std::cout << "IpoptAlgorithm::correct_bound_multiplier step_z.sum="<<step_z->Sum()<<" min="<<step_z->Min()<<" max="<<step_z->Max()<<std::endl << std::flush;
    DBG_PRINT_VECTOR(2, "step_z", *step_z);
 
    Number max_correction_up = Max(Number(0.), -step_z->Min());
+   std::cout << "IpoptAlgorithm::correct_bound_multiplier max_correction_up="<<max_correction_up<<std::endl << std::flush;
    if( max_correction_up > 0. )
    {
       SmartPtr<Vector> tmp = trial_z.MakeNew();
@@ -1117,8 +1170,16 @@ Number IpoptAlgorithm::correct_bound_multiplier(
    }
 
    step_z->AddTwoVectors(1. / kappa_sigma_ * mu, *one_over_s, -1., *new_trial_z, 0.);
-
+   std::cout << "IpoptAlgorithm::correct_bound_multiplier step_z.sum="<<step_z->Sum()<<" min="<<step_z->Min()<<" max="<<step_z->Max()<<std::endl << std::flush;
+   
    Number max_correction_low = Max(Number(0.), step_z->Max());
+   
+   std::cout << "IpoptAlgorithm::correct_bound_multiplier zmax="<<step_z->Max()<<std::endl << std::flush;
+   
+   
+      std::cout << "IpoptAlgorithm::correct_bound_multiplier max_correction_low="<<max_correction_low<<std::endl << std::flush;
+
+   
    if( max_correction_low > 0. )
    {
       SmartPtr<Vector> tmp = trial_z.MakeNew();
@@ -1130,6 +1191,7 @@ Number IpoptAlgorithm::correct_bound_multiplier(
 
    DBG_PRINT_VECTOR(2, "new_trial_z", *new_trial_z);
 
+   
    return Max(max_correction_up, max_correction_low);
 }
 
diff --git a/src/Algorithm/IpIpoptData.cpp b/src/Algorithm/IpIpoptData.cpp
index 68596e89..d6960e2d 100644
--- a/src/Algorithm/IpIpoptData.cpp
+++ b/src/Algorithm/IpIpoptData.cpp
@@ -189,6 +189,13 @@ void IpoptData::SetTrialPrimalVariablesFromStep(
       trial_ = iterates_space_->MakeNewIteratesVector(false);
    }
 
+   
+      std::cout << "IpoptData::SetTrialPrimalVariablesFromStep alpha=" <<alpha<<std::endl;
+      std::cout << "IpoptData::SetTrialPrimalVariablesFromStep delta_x.min=" << delta_x.Min() << " max="<<delta_x.Max()<<std::endl;
+      std::cout << "IpoptData::SetTrialPrimalVariablesFromStep delta_s.min=" << delta_s.Min() << " max="<<delta_s.Max()<<std::endl;
+   
+   
+   
    SmartPtr<IteratesVector> newvec = trial_->MakeNewContainer();
    newvec->create_new_x();
    newvec->x_NonConst()->AddTwoVectors(1., *curr_->x(), alpha, delta_x, 0.);
@@ -207,6 +214,10 @@ void IpoptData::SetTrialEqMultipliersFromStep(
 {
    DBG_ASSERT(have_prototypes_);
 
+         std::cout << "IpoptData::SetTrialEqMultipliersFromStep alpha=" <<alpha<<std::endl;
+      std::cout << "IpoptData::SetTrialEqMultipliersFromStep delta_y_c.min=" << delta_y_c.Min() << " max="<<delta_y_c.Max()<<std::endl;
+      std::cout << "IpoptData::SetTrialEqMultipliersFromStep delta_y_d.min=" << delta_y_d.Min() << " max="<<delta_y_d.Max()<<std::endl;
+   
    SmartPtr<IteratesVector> newvec = trial()->MakeNewContainer();
    newvec->create_new_y_c();
    newvec->y_c_NonConst()->AddTwoVectors(1., *curr()->y_c(), alpha, delta_y_c, 0.);
@@ -227,6 +238,12 @@ void IpoptData::SetTrialBoundMultipliersFromStep(
 {
    DBG_ASSERT(have_prototypes_);
 
+      std::cout << "IpoptData::SetTrialBoundMultipliersFromStep alpha=" <<alpha<<std::endl;
+      std::cout << "IpoptData::SetTrialBoundMultipliersFromStep delta_z_L.min=" << delta_z_L.Min() << " max="<<delta_z_L.Max()<<std::endl;
+      std::cout << "IpoptData::SetTrialBoundMultipliersFromStep delta_z_U.min=" << delta_z_U.Min() << " max="<<delta_z_U.Max()<<std::endl;
+      std::cout << "IpoptData::SetTrialBoundMultipliersFromStep delta_v_L.min=" << delta_v_L.Min() << " max="<<delta_v_L.Max()<<std::endl;
+      std::cout << "IpoptData::SetTrialBoundMultipliersFromStep delta_v_U.min=" << delta_v_U.Min() << " max="<<delta_v_U.Max()<<std::endl;
+      
    SmartPtr<IteratesVector> newvec = trial()->MakeNewContainer();
    newvec->create_new_z_L();
    newvec->z_L_NonConst()->AddTwoVectors(1., *curr()->z_L(), alpha, delta_z_L, 0.);
@@ -255,6 +272,8 @@ void IpoptData::AcceptTrialPoint()
    DBG_ASSERT(IsValid(trial_->v_L()));
    DBG_ASSERT(IsValid(trial_->v_U()));
 
+
+   
    CopyTrialToCurrent();
 
    // Set trial pointers to Null (frees memory unless someone else is
diff --git a/src/Algorithm/IpIpoptData.hpp b/src/Algorithm/IpIpoptData.hpp
index 067ef8fd..b241bbc8 100644
--- a/src/Algorithm/IpIpoptData.hpp
+++ b/src/Algorithm/IpIpoptData.hpp
@@ -850,6 +850,7 @@ inline SmartPtr<const IteratesVector> IpoptData::delta_aff() const
 inline
 void IpoptData::CopyTrialToCurrent()
 {
+
    curr_ = trial_;
 #if IPOPT_CHECKLEVEL > 0
 
@@ -872,6 +873,12 @@ void IpoptData::set_trial(
    SmartPtr<IteratesVector>& trial
 )
 {
+   
+   for(Index i=0; i < 1; ++ i)
+   {
+      std::cout << "IpoptData::set_trial n=" << trial->NComps()<<" i="<<i << " trial min="<<trial->GetComp(i)->Min() << " max="<<trial->GetComp(i)->Max()<<std::endl;
+   }
+   
    trial_ = ConstPtr(trial);
 
 #if IPOPT_CHECKLEVEL > 0
diff --git a/src/Algorithm/IpOptErrorConvCheck.cpp b/src/Algorithm/IpOptErrorConvCheck.cpp
index 352757a1..b617df9d 100644
--- a/src/Algorithm/IpOptErrorConvCheck.cpp
+++ b/src/Algorithm/IpOptErrorConvCheck.cpp
@@ -277,6 +277,7 @@ ConvergenceCheck::ConvergenceStatus OptimalityErrorConvergenceCheck::CheckConver
 
 bool OptimalityErrorConvergenceCheck::CurrentIsAcceptable()
 {
+    
    DBG_START_METH("OptimalityErrorConvergenceCheck::CurrentIsAcceptable",
                   dbg_verbosity);
 
@@ -285,6 +286,18 @@ bool OptimalityErrorConvergenceCheck::CurrentIsAcceptable()
    Number constr_viol = IpCq().unscaled_curr_nlp_constraint_violation(NORM_MAX);
    Number compl_inf = IpCq().unscaled_curr_complementarity(mu_target_, NORM_MAX);
 
+       std::cout << "OptimalityErrorConvergenceCheck::CurrentIsAcceptable overall_error="<<overall_error<< std::endl << std::flush;
+       std::cout << "OptimalityErrorConvergenceCheck::CurrentIsAcceptable dual_inf="<<dual_inf<< std::endl << std::flush;
+       std::cout << "OptimalityErrorConvergenceCheck::CurrentIsAcceptable constr_viol="<<constr_viol<< std::endl << std::flush;
+       std::cout << "OptimalityErrorConvergenceCheck::CurrentIsAcceptable compl_inf="<<compl_inf<< std::endl << std::flush;
+
+   
+              std::cout << "OptimalityErrorConvergenceCheck::CurrentIsAcceptable acceptable_tol_="<<acceptable_tol_<< std::endl << std::flush;
+       std::cout << "OptimalityErrorConvergenceCheck::CurrentIsAcceptable acceptable_dual_inf_tol_="<<acceptable_dual_inf_tol_<< std::endl << std::flush;
+       std::cout << "OptimalityErrorConvergenceCheck::CurrentIsAcceptable acceptable_constr_viol_tol_="<<acceptable_constr_viol_tol_<< std::endl << std::flush;
+       std::cout << "OptimalityErrorConvergenceCheck::CurrentIsAcceptable acceptable_compl_inf_tol_="<<acceptable_compl_inf_tol_<< std::endl << std::flush;
+              std::cout << "OptimalityErrorConvergenceCheck::CurrentIsAcceptable acceptable_obj_change_tol_="<<acceptable_obj_change_tol_<< std::endl << std::flush;
+
    if( IpData().iter_count() != last_obj_val_iter_ )
    {
       //Jnlst().Printf(J_MOREDETAILED, J_MAIN,
@@ -293,6 +306,9 @@ bool OptimalityErrorConvergenceCheck::CurrentIsAcceptable()
       curr_obj_val_ = IpCq().curr_f();
       last_obj_val_iter_ = IpData().iter_count();
    }
+   
+          std::cout << "OptimalityErrorConvergenceCheck::CurrentIsAcceptable last_obj_val_="<<last_obj_val_<< std::endl << std::flush;
+          std::cout << "OptimalityErrorConvergenceCheck::CurrentIsAcceptable curr_obj_val_="<<curr_obj_val_<< std::endl << std::flush;
 
    DBG_PRINT((1, "overall_error = %e\n", overall_error));
    DBG_PRINT((1, "dual_inf = %e\n", dual_inf));
diff --git a/src/Interfaces/IpIpoptApplication.cpp b/src/Interfaces/IpIpoptApplication.cpp
index 44525aea..422add7e 100644
--- a/src/Interfaces/IpIpoptApplication.cpp
+++ b/src/Interfaces/IpIpoptApplication.cpp
@@ -29,6 +29,7 @@
 #include <cassert>
 #include <cmath>
 #include <fstream>
+#include <iostream>
 
 // Factory to facilitate creating IpoptApplication objects from within a DLL
 
@@ -105,6 +106,7 @@ IpoptApplication::IpoptApplication(
    catch( std::overflow_error& )
    {
       jnlst_->Printf(J_ERROR, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
+      
       THROW_EXCEPTION(IPOPT_APPLICATION_ERROR, "Not enough memory");
    }
    catch( ... )
@@ -270,11 +272,13 @@ ApplicationReturnStatus IpoptApplication::Initialize(
    }
    catch( std::bad_alloc& )
    {
+      std::cout << "IpoptApplication::Initialize1 Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
       return Insufficient_Memory;
    }
    catch( std::overflow_error& )
    {
+         std::cout << "IpoptApplication::Initialize1 Integer type too small for required memory std::overflow_error" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
       return Insufficient_Memory;
    }
@@ -309,10 +313,12 @@ ApplicationReturnStatus IpoptApplication::Initialize(
       catch( std::bad_alloc& )
       {
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
+         std::cout << "IpoptApplication::Initialize2 Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
          return Insufficient_Memory;
       }
       catch( std::overflow_error& )
       {
+            std::cout << "IpoptApplication::Initialize2 Insufficient_Memory std::overflow_error" << std::endl << std::flush;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
          return Insufficient_Memory;
       }
@@ -469,6 +475,7 @@ ApplicationReturnStatus IpoptApplication::OptimizeTNLP(
    const SmartPtr<TNLP>& tnlp
 )
 {
+      std::cout << "IpoptApplication::OptimizeTNLP" << std::endl << std::flush;
    nlp_adapter_ = new TNLPAdapter(GetRawPtr(tnlp), ConstPtr(jnlst_));
    return OptimizeNLP(nlp_adapter_);
 }
@@ -489,6 +496,7 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    const SmartPtr<NLP>& nlp
 )
 {
+      std::cout << "IpoptApplication::OptimizeNLP" << std::endl << std::flush;
    SmartPtr<AlgorithmBuilder> alg_builder = NULL;
    return OptimizeNLP(nlp, alg_builder);
 }
@@ -498,6 +506,7 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    SmartPtr<AlgorithmBuilder>& alg_builder
 )
 {
+      std::cout << "IpoptApplication::OptimizeNLP alg_builder" << std::endl << std::flush;
    ApplicationReturnStatus retValue = Internal_Error;
 
    // Prepare internal data structures of the algorithm
@@ -538,12 +547,14 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    }
    catch( OPTION_INVALID& exc )
    {
+         std::cout << "IpoptApplication::OptimizeNLP OPTION_INVALID" << std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Invalid option encountered.\n");
       retValue = Invalid_Option;
    }
    catch( IpoptException& exc )
    {
+         std::cout << "IpoptApplication::OptimizeNLP IpoptException" << std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Some uncaught Ipopt exception encountered.\n");
       retValue = Unrecoverable_Exception;
@@ -551,23 +562,28 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    catch( std::bad_alloc& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::Initialize3 Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
    }
    catch( std::overflow_error& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::Initialize3 Insufficient_Memory std::overflow_error" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
    }
    catch( ... )
    {
+         std::cout << "IpoptApplication::OptimizeNLP ..." << std::endl << std::flush;
       if( !rethrow_nonipoptexception_ )
       {
          IpoptException exc("Unknown Exception caught in Ipopt", "Unknown File", -1);
          exc.ReportException(*jnlst_, J_ERROR);
+         std::cout << "IpoptApplication::OptimizeNLP NonIpopt_Exception_Thrown" << std::endl << std::flush;
          retValue = NonIpopt_Exception_Thrown;
       }
       else
       {
+            std::cout << "IpoptApplication::OptimizeNLP throw" << std::endl << std::flush;
          throw;
       }
    }
@@ -581,6 +597,7 @@ ApplicationReturnStatus IpoptApplication::ReOptimizeNLP(
    const SmartPtr<NLP>& nlp
 )
 {
+      std::cout << "IpoptApplication::ReOptimizeNLP0" << std::endl << std::flush;
    ASSERT_EXCEPTION(IsValid(alg_), INVALID_WARMSTART, "ReOptimizeNLP called before OptimizeNLP.");
    OrigIpoptNLP* orig_nlp = static_cast<OrigIpoptNLP*>(GetRawPtr(ip_nlp_));
    DBG_ASSERT(dynamic_cast<OrigIpoptNLP*> (GetRawPtr(ip_nlp_)));
@@ -591,6 +608,7 @@ ApplicationReturnStatus IpoptApplication::ReOptimizeNLP(
 
 ApplicationReturnStatus IpoptApplication::call_optimize()
 {
+      std::cout << "IpoptApplication::call_optimize0" << std::endl << std::flush;
    // Reset the print-level for the screen output
    Index ivalue;
    options_->GetIntegerValue("print_level", ivalue, "");
@@ -622,6 +640,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
 
    ApplicationReturnStatus retValue = Internal_Error;
    SolverReturn status = INTERNAL_ERROR;
+   std::cout << "IpoptApplication::call_optimize0.1" << std::endl << std::flush;
    try
    {
       // check whether timing statistics need to be printed
@@ -656,7 +675,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
 
       // Run the algorithm
       status = p2alg->Optimize();
-
+std::cout << "IpoptApplication::call_optimize1 status=" <<status<< std::endl << std::flush;
       // Since all the output below doesn't make any sense in this
       // case, we rethrow the TOO_FEW_DOF exception here
       ASSERT_EXCEPTION(status != TOO_FEW_DEGREES_OF_FREEDOM, TOO_FEW_DOF, "Too few degrees of freedom (rethrown)!");
@@ -686,6 +705,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
          }
          catch( IpoptNLP::Eval_Error& exc )
          {
+               std::cout << "IpoptApplication::call_optimize Eval_Error"<< std::endl << std::flush;
             // this can happen if the final point was accepted because functions can be evaluated,
             // but functions are not differentiable, so dual infeasibility cannot be computed
             status = INVALID_NUMBER_DETECTED;
@@ -751,67 +771,80 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
       }
       else if( status == MAXITER_EXCEEDED )
       {
+            std::cout << "IpoptApplication::call_optimize MAXITER_EXCEEDED"<< std::endl << std::flush;
          retValue = Maximum_Iterations_Exceeded;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Maximum Number of Iterations Exceeded.\n");
       }
       else if( status == CPUTIME_EXCEEDED )
       {
+            std::cout << "IpoptApplication::call_optimize CPUTIME_EXCEEDED"<< std::endl << std::flush;
          retValue = Maximum_CpuTime_Exceeded;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Maximum CPU time exceeded.\n");
       }
       else if( status == WALLTIME_EXCEEDED )
       {
+            std::cout << "IpoptApplication::call_optimize WALLTIME_EXCEEDED"<< std::endl << std::flush;
          retValue = Maximum_WallTime_Exceeded;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Maximum wallclock time exceeded.\n");
       }
       else if( status == STOP_AT_TINY_STEP )
       {
+            std::cout << "IpoptApplication::call_optimize STOP_AT_TINY_STEP"<< std::endl << std::flush;
          retValue = Search_Direction_Becomes_Too_Small;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Search Direction is becoming Too Small.\n");
       }
       else if( status == STOP_AT_ACCEPTABLE_POINT )
       {
+            std::cout << "IpoptApplication::call_optimize STOP_AT_ACCEPTABLE_POINT"<< std::endl << std::flush;
          retValue = Solved_To_Acceptable_Level;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Solved To Acceptable Level.\n");
       }
       else if( status == FEASIBLE_POINT_FOUND )
       {
+            std::cout << "IpoptApplication::call_optimize FEASIBLE_POINT_FOUND"<< std::endl << std::flush;
          retValue = Feasible_Point_Found;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Feasible point for square problem found.\n");
       }
       else if( status == DIVERGING_ITERATES )
       {
+            std::cout << "IpoptApplication::call_optimize DIVERGING_ITERATES"<< std::endl << std::flush;
          retValue = Diverging_Iterates;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Iterates diverging; problem might be unbounded.\n");
       }
       else if( status == RESTORATION_FAILURE )
       {
+            std::cout << "IpoptApplication::call_optimize RESTORATION_FAILURE"<< std::endl << std::flush;
          retValue = Restoration_Failed;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Restoration Failed!\n");
       }
       else if( status == ERROR_IN_STEP_COMPUTATION )
       {
+            std::cout << "IpoptApplication::call_optimize ERROR_IN_STEP_COMPUTATION"<< std::endl << std::flush;
          retValue = Error_In_Step_Computation;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Error in step computation!\n");
       }
       else if( status == LOCAL_INFEASIBILITY )
       {
+            std::cout << "IpoptApplication::call_optimize LOCAL_INFEASIBILITY"<< std::endl << std::flush;
          retValue = Infeasible_Problem_Detected;
          jnlst_->Printf(J_SUMMARY, J_MAIN,
                         "\nEXIT: Converged to a point of local infeasibility. Problem may be infeasible.\n");
       }
       else if( status == USER_REQUESTED_STOP )
       {
+            std::cout << "IpoptApplication::call_optimize USER_REQUESTED_STOP"<< std::endl << std::flush;
          retValue = User_Requested_Stop;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Stopping optimization at current point as requested by user.\n");
       }
       else if( status == INVALID_NUMBER_DETECTED )
       {
+            std::cout << "IpoptApplication::call_optimize INVALID_NUMBER_DETECTED"<< std::endl << std::flush;
          retValue = Invalid_Number_Detected;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Invalid number in NLP function or derivative detected.\n");
       }
       else
       {
+            std::cout << "IpoptApplication::call_optimize Internal_Error"<< std::endl << std::flush;
          retValue = Internal_Error;
          jnlst_->Printf(J_SUMMARY, J_MAIN,
                         "\nEXIT: INTERNAL ERROR: Unknown SolverReturn value - Notify IPOPT Authors.\n");
@@ -826,6 +859,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( TOO_FEW_DOF& exc )
    {
+         std::cout << "IpoptApplication::call_optimize TOO_FEW_DOF"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_STRONGWARNING);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Problem has too few degrees of freedom.\n");
       retValue = Not_Enough_Degrees_Of_Freedom;
@@ -833,6 +867,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( OPTION_INVALID& exc )
    {
+         std::cout << "IpoptApplication::call_optimize OPTION_INVALID"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Invalid option encountered.\n");
       retValue = Invalid_Option;
@@ -840,12 +875,14 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( DYNAMIC_LIBRARY_FAILURE& exc )
    {
+         std::cout << "IpoptApplication::call_optimize DYNAMIC_LIBRARY_FAILURE"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Library loading failure.\n");
       retValue = Invalid_Option;
    }
    catch( INCONSISTENT_BOUNDS& exc )
    {
+         std::cout << "IpoptApplication::call_optimize INCONSISTENT_BOUNDS"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_MOREDETAILED);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Problem has inconsistent variable bounds or constraint sides.\n");
       retValue = Invalid_Problem_Definition;
@@ -853,6 +890,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( IpoptException& exc )
    {
+         std::cout << "IpoptApplication::call_optimize IpoptException"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Some uncaught Ipopt exception encountered.\n");
       retValue = Unrecoverable_Exception;
@@ -860,25 +898,30 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    catch( std::bad_alloc& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::call_optimize Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
       status = OUT_OF_MEMORY;
    }
    catch( std::overflow_error& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::call_optimize Insufficient_Memory std::overflow_error" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
       status = OUT_OF_MEMORY;
    }
    catch( ... )
    {
+         std::cout << "IpoptApplication::call_optimize ..." << std::endl << std::flush;
       if( !rethrow_nonipoptexception_ )
       {
          IpoptException exc("Unknown Exception caught in Ipopt", "Unknown File", -1);
          exc.ReportException(*jnlst_, J_ERROR);
          retValue = NonIpopt_Exception_Thrown;
+         std::cout << "IpoptApplication::call_optimize NonIpopt_Exception_Thrown" << std::endl << std::flush;
       }
       else
       {
+            std::cout << "IpoptApplication::call_optimize throw" << std::endl << std::flush;
          jnlst_->FlushBuffer();
          throw;
       }
@@ -923,6 +966,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
             break;
          default:
          {
+               std::cout << "IpoptApplication::call_optimize status.default" << std::endl << std::flush;
             SmartPtr<Vector> tmp = p2ip_data->curr()->y_c()->MakeNew();
             tmp->Set(0.);
             c = ConstPtr(tmp);
@@ -944,7 +988,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
 
    jnlst_->FlushBuffer();
-
+std::cout << "IpoptApplication::call_optimize final retValue="<< retValue<< std::endl << std::flush;
    return retValue;
 }
 
