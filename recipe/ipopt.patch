diff --git a/src/Algorithm/IpIpoptAlg.cpp b/src/Algorithm/IpIpoptAlg.cpp
index d9092e5c..e7516672 100644
--- a/src/Algorithm/IpIpoptAlg.cpp
+++ b/src/Algorithm/IpIpoptAlg.cpp
@@ -18,6 +18,7 @@
 #if IPOPT_CHECKLEVEL > 1 && defined(IPOPT_HAS_FEENABLEEXCEPT)
 #include <cfenv>
 #endif
+#include <iostream>
 
 namespace Ipopt
 {
@@ -293,6 +294,7 @@ SolverReturn IpoptAlgorithm::Optimize(
    bool isResto /*= false */
 )
 {
+      std::cout << "IpoptAlgorithm::Optimize0"<< std::endl << std::flush;
    DBG_START_METH("IpoptAlgorithm::Optimize", dbg_verbosity);
 
    // Start measuring CPU time
@@ -524,6 +526,7 @@ SolverReturn IpoptAlgorithm::Optimize(
    }
    catch( STEP_COMPUTATION_FAILED& exc )
    {
+         std::cout << "IpoptAlgorithm::Optimize STEP_COMPUTATION_FAILED"<< std::endl << std::flush;
       exc.ReportException(Jnlst(), J_MOREDETAILED);
       IpData().TimingStats().ComputeAcceptableTrialPoint().EndIfStarted();
       retval = ERROR_IN_STEP_COMPUTATION;
@@ -559,6 +562,7 @@ SolverReturn IpoptAlgorithm::Optimize(
    }
 
    DBG_ASSERT(retval != UNASSIGNED && "Unknown return code in the algorithm");
+   std::cout << "IpoptAlgorithm::Optimize retval="<<retval<< std::endl << std::flush;
    return retval;
 }
 
diff --git a/src/Interfaces/IpIpoptApplication.cpp b/src/Interfaces/IpIpoptApplication.cpp
index 44525aea..422add7e 100644
--- a/src/Interfaces/IpIpoptApplication.cpp
+++ b/src/Interfaces/IpIpoptApplication.cpp
@@ -29,6 +29,7 @@
 #include <cassert>
 #include <cmath>
 #include <fstream>
+#include <iostream>
 
 // Factory to facilitate creating IpoptApplication objects from within a DLL
 
@@ -105,6 +106,7 @@ IpoptApplication::IpoptApplication(
    catch( std::overflow_error& )
    {
       jnlst_->Printf(J_ERROR, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
+      
       THROW_EXCEPTION(IPOPT_APPLICATION_ERROR, "Not enough memory");
    }
    catch( ... )
@@ -270,11 +272,13 @@ ApplicationReturnStatus IpoptApplication::Initialize(
    }
    catch( std::bad_alloc& )
    {
+      std::cout << "IpoptApplication::Initialize1 Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
       return Insufficient_Memory;
    }
    catch( std::overflow_error& )
    {
+         std::cout << "IpoptApplication::Initialize1 Integer type too small for required memory std::overflow_error" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
       return Insufficient_Memory;
    }
@@ -309,10 +313,12 @@ ApplicationReturnStatus IpoptApplication::Initialize(
       catch( std::bad_alloc& )
       {
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
+         std::cout << "IpoptApplication::Initialize2 Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
          return Insufficient_Memory;
       }
       catch( std::overflow_error& )
       {
+            std::cout << "IpoptApplication::Initialize2 Insufficient_Memory std::overflow_error" << std::endl << std::flush;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
          return Insufficient_Memory;
       }
@@ -469,6 +475,7 @@ ApplicationReturnStatus IpoptApplication::OptimizeTNLP(
    const SmartPtr<TNLP>& tnlp
 )
 {
+      std::cout << "IpoptApplication::OptimizeTNLP" << std::endl << std::flush;
    nlp_adapter_ = new TNLPAdapter(GetRawPtr(tnlp), ConstPtr(jnlst_));
    return OptimizeNLP(nlp_adapter_);
 }
@@ -489,6 +496,7 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    const SmartPtr<NLP>& nlp
 )
 {
+      std::cout << "IpoptApplication::OptimizeNLP" << std::endl << std::flush;
    SmartPtr<AlgorithmBuilder> alg_builder = NULL;
    return OptimizeNLP(nlp, alg_builder);
 }
@@ -498,6 +506,7 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    SmartPtr<AlgorithmBuilder>& alg_builder
 )
 {
+      std::cout << "IpoptApplication::OptimizeNLP alg_builder" << std::endl << std::flush;
    ApplicationReturnStatus retValue = Internal_Error;
 
    // Prepare internal data structures of the algorithm
@@ -538,12 +547,14 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    }
    catch( OPTION_INVALID& exc )
    {
+         std::cout << "IpoptApplication::OptimizeNLP OPTION_INVALID" << std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Invalid option encountered.\n");
       retValue = Invalid_Option;
    }
    catch( IpoptException& exc )
    {
+         std::cout << "IpoptApplication::OptimizeNLP IpoptException" << std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Some uncaught Ipopt exception encountered.\n");
       retValue = Unrecoverable_Exception;
@@ -551,23 +562,28 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    catch( std::bad_alloc& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::Initialize3 Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
    }
    catch( std::overflow_error& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::Initialize3 Insufficient_Memory std::overflow_error" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
    }
    catch( ... )
    {
+         std::cout << "IpoptApplication::OptimizeNLP ..." << std::endl << std::flush;
       if( !rethrow_nonipoptexception_ )
       {
          IpoptException exc("Unknown Exception caught in Ipopt", "Unknown File", -1);
          exc.ReportException(*jnlst_, J_ERROR);
+         std::cout << "IpoptApplication::OptimizeNLP NonIpopt_Exception_Thrown" << std::endl << std::flush;
          retValue = NonIpopt_Exception_Thrown;
       }
       else
       {
+            std::cout << "IpoptApplication::OptimizeNLP throw" << std::endl << std::flush;
          throw;
       }
    }
@@ -581,6 +597,7 @@ ApplicationReturnStatus IpoptApplication::ReOptimizeNLP(
    const SmartPtr<NLP>& nlp
 )
 {
+      std::cout << "IpoptApplication::ReOptimizeNLP0" << std::endl << std::flush;
    ASSERT_EXCEPTION(IsValid(alg_), INVALID_WARMSTART, "ReOptimizeNLP called before OptimizeNLP.");
    OrigIpoptNLP* orig_nlp = static_cast<OrigIpoptNLP*>(GetRawPtr(ip_nlp_));
    DBG_ASSERT(dynamic_cast<OrigIpoptNLP*> (GetRawPtr(ip_nlp_)));
@@ -591,6 +608,7 @@ ApplicationReturnStatus IpoptApplication::ReOptimizeNLP(
 
 ApplicationReturnStatus IpoptApplication::call_optimize()
 {
+      std::cout << "IpoptApplication::call_optimize0" << std::endl << std::flush;
    // Reset the print-level for the screen output
    Index ivalue;
    options_->GetIntegerValue("print_level", ivalue, "");
@@ -622,6 +640,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
 
    ApplicationReturnStatus retValue = Internal_Error;
    SolverReturn status = INTERNAL_ERROR;
+   std::cout << "IpoptApplication::call_optimize0.1" << std::endl << std::flush;
    try
    {
       // check whether timing statistics need to be printed
@@ -656,7 +675,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
 
       // Run the algorithm
       status = p2alg->Optimize();
-
+std::cout << "IpoptApplication::call_optimize1 status=" <<status<< std::endl << std::flush;
       // Since all the output below doesn't make any sense in this
       // case, we rethrow the TOO_FEW_DOF exception here
       ASSERT_EXCEPTION(status != TOO_FEW_DEGREES_OF_FREEDOM, TOO_FEW_DOF, "Too few degrees of freedom (rethrown)!");
@@ -686,6 +705,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
          }
          catch( IpoptNLP::Eval_Error& exc )
          {
+               std::cout << "IpoptApplication::call_optimize Eval_Error"<< std::endl << std::flush;
             // this can happen if the final point was accepted because functions can be evaluated,
             // but functions are not differentiable, so dual infeasibility cannot be computed
             status = INVALID_NUMBER_DETECTED;
@@ -751,67 +771,80 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
       }
       else if( status == MAXITER_EXCEEDED )
       {
+            std::cout << "IpoptApplication::call_optimize MAXITER_EXCEEDED"<< std::endl << std::flush;
          retValue = Maximum_Iterations_Exceeded;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Maximum Number of Iterations Exceeded.\n");
       }
       else if( status == CPUTIME_EXCEEDED )
       {
+            std::cout << "IpoptApplication::call_optimize CPUTIME_EXCEEDED"<< std::endl << std::flush;
          retValue = Maximum_CpuTime_Exceeded;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Maximum CPU time exceeded.\n");
       }
       else if( status == WALLTIME_EXCEEDED )
       {
+            std::cout << "IpoptApplication::call_optimize WALLTIME_EXCEEDED"<< std::endl << std::flush;
          retValue = Maximum_WallTime_Exceeded;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Maximum wallclock time exceeded.\n");
       }
       else if( status == STOP_AT_TINY_STEP )
       {
+            std::cout << "IpoptApplication::call_optimize STOP_AT_TINY_STEP"<< std::endl << std::flush;
          retValue = Search_Direction_Becomes_Too_Small;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Search Direction is becoming Too Small.\n");
       }
       else if( status == STOP_AT_ACCEPTABLE_POINT )
       {
+            std::cout << "IpoptApplication::call_optimize STOP_AT_ACCEPTABLE_POINT"<< std::endl << std::flush;
          retValue = Solved_To_Acceptable_Level;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Solved To Acceptable Level.\n");
       }
       else if( status == FEASIBLE_POINT_FOUND )
       {
+            std::cout << "IpoptApplication::call_optimize FEASIBLE_POINT_FOUND"<< std::endl << std::flush;
          retValue = Feasible_Point_Found;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Feasible point for square problem found.\n");
       }
       else if( status == DIVERGING_ITERATES )
       {
+            std::cout << "IpoptApplication::call_optimize DIVERGING_ITERATES"<< std::endl << std::flush;
          retValue = Diverging_Iterates;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Iterates diverging; problem might be unbounded.\n");
       }
       else if( status == RESTORATION_FAILURE )
       {
+            std::cout << "IpoptApplication::call_optimize RESTORATION_FAILURE"<< std::endl << std::flush;
          retValue = Restoration_Failed;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Restoration Failed!\n");
       }
       else if( status == ERROR_IN_STEP_COMPUTATION )
       {
+            std::cout << "IpoptApplication::call_optimize ERROR_IN_STEP_COMPUTATION"<< std::endl << std::flush;
          retValue = Error_In_Step_Computation;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Error in step computation!\n");
       }
       else if( status == LOCAL_INFEASIBILITY )
       {
+            std::cout << "IpoptApplication::call_optimize LOCAL_INFEASIBILITY"<< std::endl << std::flush;
          retValue = Infeasible_Problem_Detected;
          jnlst_->Printf(J_SUMMARY, J_MAIN,
                         "\nEXIT: Converged to a point of local infeasibility. Problem may be infeasible.\n");
       }
       else if( status == USER_REQUESTED_STOP )
       {
+            std::cout << "IpoptApplication::call_optimize USER_REQUESTED_STOP"<< std::endl << std::flush;
          retValue = User_Requested_Stop;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Stopping optimization at current point as requested by user.\n");
       }
       else if( status == INVALID_NUMBER_DETECTED )
       {
+            std::cout << "IpoptApplication::call_optimize INVALID_NUMBER_DETECTED"<< std::endl << std::flush;
          retValue = Invalid_Number_Detected;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Invalid number in NLP function or derivative detected.\n");
       }
       else
       {
+            std::cout << "IpoptApplication::call_optimize Internal_Error"<< std::endl << std::flush;
          retValue = Internal_Error;
          jnlst_->Printf(J_SUMMARY, J_MAIN,
                         "\nEXIT: INTERNAL ERROR: Unknown SolverReturn value - Notify IPOPT Authors.\n");
@@ -826,6 +859,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( TOO_FEW_DOF& exc )
    {
+         std::cout << "IpoptApplication::call_optimize TOO_FEW_DOF"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_STRONGWARNING);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Problem has too few degrees of freedom.\n");
       retValue = Not_Enough_Degrees_Of_Freedom;
@@ -833,6 +867,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( OPTION_INVALID& exc )
    {
+         std::cout << "IpoptApplication::call_optimize OPTION_INVALID"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Invalid option encountered.\n");
       retValue = Invalid_Option;
@@ -840,12 +875,14 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( DYNAMIC_LIBRARY_FAILURE& exc )
    {
+         std::cout << "IpoptApplication::call_optimize DYNAMIC_LIBRARY_FAILURE"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Library loading failure.\n");
       retValue = Invalid_Option;
    }
    catch( INCONSISTENT_BOUNDS& exc )
    {
+         std::cout << "IpoptApplication::call_optimize INCONSISTENT_BOUNDS"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_MOREDETAILED);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Problem has inconsistent variable bounds or constraint sides.\n");
       retValue = Invalid_Problem_Definition;
@@ -853,6 +890,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( IpoptException& exc )
    {
+         std::cout << "IpoptApplication::call_optimize IpoptException"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Some uncaught Ipopt exception encountered.\n");
       retValue = Unrecoverable_Exception;
@@ -860,25 +898,30 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    catch( std::bad_alloc& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::call_optimize Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
       status = OUT_OF_MEMORY;
    }
    catch( std::overflow_error& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::call_optimize Insufficient_Memory std::overflow_error" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
       status = OUT_OF_MEMORY;
    }
    catch( ... )
    {
+         std::cout << "IpoptApplication::call_optimize ..." << std::endl << std::flush;
       if( !rethrow_nonipoptexception_ )
       {
          IpoptException exc("Unknown Exception caught in Ipopt", "Unknown File", -1);
          exc.ReportException(*jnlst_, J_ERROR);
          retValue = NonIpopt_Exception_Thrown;
+         std::cout << "IpoptApplication::call_optimize NonIpopt_Exception_Thrown" << std::endl << std::flush;
       }
       else
       {
+            std::cout << "IpoptApplication::call_optimize throw" << std::endl << std::flush;
          jnlst_->FlushBuffer();
          throw;
       }
@@ -923,6 +966,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
             break;
          default:
          {
+               std::cout << "IpoptApplication::call_optimize status.default" << std::endl << std::flush;
             SmartPtr<Vector> tmp = p2ip_data->curr()->y_c()->MakeNew();
             tmp->Set(0.);
             c = ConstPtr(tmp);
@@ -944,7 +988,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
 
    jnlst_->FlushBuffer();
-
+std::cout << "IpoptApplication::call_optimize final retValue="<< retValue<< std::endl << std::flush;
    return retValue;
 }
 
