diff --git a/src/Algorithm/IpBacktrackingLineSearch.cpp b/src/Algorithm/IpBacktrackingLineSearch.cpp
index 6782ac59..29edce5b 100644
--- a/src/Algorithm/IpBacktrackingLineSearch.cpp
+++ b/src/Algorithm/IpBacktrackingLineSearch.cpp
@@ -14,6 +14,7 @@
 
 #include <cmath>
 #include <limits>
+#include <iostream>
 
 namespace Ipopt
 {
@@ -317,6 +318,7 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
       }
       else
       {
+          std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint throw STEP_COMPUTATION_FAILED1"<< std::endl << std::flush;
          THROW_EXCEPTION(STEP_COMPUTATION_FAILED,
                          "We are in an emergency mode, but no restoration phase or other fall back is available.");
       }
@@ -566,11 +568,16 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
             }
 
             // ToDo make the 1e-2 below a parameter?
+            
+            std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint curr_constraint_violation="<<IpCq().curr_constraint_violation()<< std::endl << std::flush;
+            std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint unscaled_curr_nlp_constraint_violation="<<IpCq().unscaled_curr_nlp_constraint_violation(NORM_MAX)<< std::endl << std::flush;
+
             // added second criteria to cover cases where tol has been set to a large value
             if( IpCq().curr_constraint_violation() <= 1e-2 * IpData().tol() &&
                 IpCq().unscaled_curr_nlp_constraint_violation(NORM_MAX) <= 1e-1 * constr_viol_tol_ )
             {
                bool found_acceptable = RestoreAcceptablePoint();
+               std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint found_acceptable="<<found_acceptable<< std::endl << std::flush;
                if( found_acceptable )
                {
                   Jnlst().Printf(J_WARNING, J_LINE_SEARCH,
@@ -581,6 +588,7 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
                }
                else
                {
+                    std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint throw STEP_COMPUTATION_FAILED2"<< std::endl << std::flush;
                   Jnlst().Printf(J_STRONGWARNING, J_LINE_SEARCH,
                                  "Cannot call restoration phase at point that is almost feasible %s(violation %e).\nAbort in line search due to no other fall back.\n",
                                  dynamic_cast<OrigIpoptNLP*>(GetRawPtr(IpCq().GetIpoptNLP())) == NULL ? "for the restoration NLP " : "",
@@ -1289,13 +1297,15 @@ bool BacktrackingLineSearch::RestoreAcceptablePoint()
 
    if( !IsValid(acceptable_iterate_) )
    {
+          std::cout << "BacktrackingLineSearch::RestoreAcceptablePoint false="<< std::endl << std::flush;
+
       return false;
    }
 
    SmartPtr<IteratesVector> prev_iterate = acceptable_iterate_->MakeNewContainer();
    IpData().set_trial(prev_iterate);
    IpData().AcceptTrialPoint();
-
+std::cout << "BacktrackingLineSearch::RestoreAcceptablePoint true="<< std::endl << std::flush;
    return true;
 }
 
diff --git a/src/Algorithm/IpIpoptAlg.cpp b/src/Algorithm/IpIpoptAlg.cpp
index d9092e5c..8ee0c029 100644
--- a/src/Algorithm/IpIpoptAlg.cpp
+++ b/src/Algorithm/IpIpoptAlg.cpp
@@ -18,6 +18,7 @@
 #if IPOPT_CHECKLEVEL > 1 && defined(IPOPT_HAS_FEENABLEEXCEPT)
 #include <cfenv>
 #endif
+#include <iostream>
 
 namespace Ipopt
 {
@@ -293,6 +294,7 @@ SolverReturn IpoptAlgorithm::Optimize(
    bool isResto /*= false */
 )
 {
+      std::cout << "IpoptAlgorithm::Optimize0"<< std::endl << std::flush;
    DBG_START_METH("IpoptAlgorithm::Optimize", dbg_verbosity);
 
    // Start measuring CPU time
@@ -379,6 +381,7 @@ SolverReturn IpoptAlgorithm::Optimize(
          // If we are in the emergency mode, ask the line search object
          // to go to the fallback options.  If that isn't possible,
          // issue error message
+         
          if( emergency_mode )
          {
             if( line_search_->ActivateFallbackMechanism() )
@@ -388,6 +391,9 @@ SolverReturn IpoptAlgorithm::Optimize(
             }
             else
             {
+                  
+                  std::cout << "IpoptAlgorithm::Optimize1 throw STEP_COMPUTATION_FAILED"<< std::endl << std::flush;
+                  
                Jnlst().Printf(J_ERROR, J_MAIN,
                               "ERROR: Problem in step computation, but emergency mode cannot be activated.\n");
                THROW_EXCEPTION(STEP_COMPUTATION_FAILED, "Step computation failed.");
@@ -524,6 +530,7 @@ SolverReturn IpoptAlgorithm::Optimize(
    }
    catch( STEP_COMPUTATION_FAILED& exc )
    {
+         std::cout << "IpoptAlgorithm::Optimize STEP_COMPUTATION_FAILED"<< std::endl << std::flush;
       exc.ReportException(Jnlst(), J_MOREDETAILED);
       IpData().TimingStats().ComputeAcceptableTrialPoint().EndIfStarted();
       retval = ERROR_IN_STEP_COMPUTATION;
@@ -559,6 +566,7 @@ SolverReturn IpoptAlgorithm::Optimize(
    }
 
    DBG_ASSERT(retval != UNASSIGNED && "Unknown return code in the algorithm");
+   std::cout << "IpoptAlgorithm::Optimize retval="<<retval<< std::endl << std::flush;
    return retval;
 }
 
diff --git a/src/Interfaces/IpIpoptApplication.cpp b/src/Interfaces/IpIpoptApplication.cpp
index 44525aea..422add7e 100644
--- a/src/Interfaces/IpIpoptApplication.cpp
+++ b/src/Interfaces/IpIpoptApplication.cpp
@@ -29,6 +29,7 @@
 #include <cassert>
 #include <cmath>
 #include <fstream>
+#include <iostream>
 
 // Factory to facilitate creating IpoptApplication objects from within a DLL
 
@@ -105,6 +106,7 @@ IpoptApplication::IpoptApplication(
    catch( std::overflow_error& )
    {
       jnlst_->Printf(J_ERROR, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
+      
       THROW_EXCEPTION(IPOPT_APPLICATION_ERROR, "Not enough memory");
    }
    catch( ... )
@@ -270,11 +272,13 @@ ApplicationReturnStatus IpoptApplication::Initialize(
    }
    catch( std::bad_alloc& )
    {
+      std::cout << "IpoptApplication::Initialize1 Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
       return Insufficient_Memory;
    }
    catch( std::overflow_error& )
    {
+         std::cout << "IpoptApplication::Initialize1 Integer type too small for required memory std::overflow_error" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
       return Insufficient_Memory;
    }
@@ -309,10 +313,12 @@ ApplicationReturnStatus IpoptApplication::Initialize(
       catch( std::bad_alloc& )
       {
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
+         std::cout << "IpoptApplication::Initialize2 Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
          return Insufficient_Memory;
       }
       catch( std::overflow_error& )
       {
+            std::cout << "IpoptApplication::Initialize2 Insufficient_Memory std::overflow_error" << std::endl << std::flush;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
          return Insufficient_Memory;
       }
@@ -469,6 +475,7 @@ ApplicationReturnStatus IpoptApplication::OptimizeTNLP(
    const SmartPtr<TNLP>& tnlp
 )
 {
+      std::cout << "IpoptApplication::OptimizeTNLP" << std::endl << std::flush;
    nlp_adapter_ = new TNLPAdapter(GetRawPtr(tnlp), ConstPtr(jnlst_));
    return OptimizeNLP(nlp_adapter_);
 }
@@ -489,6 +496,7 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    const SmartPtr<NLP>& nlp
 )
 {
+      std::cout << "IpoptApplication::OptimizeNLP" << std::endl << std::flush;
    SmartPtr<AlgorithmBuilder> alg_builder = NULL;
    return OptimizeNLP(nlp, alg_builder);
 }
@@ -498,6 +506,7 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    SmartPtr<AlgorithmBuilder>& alg_builder
 )
 {
+      std::cout << "IpoptApplication::OptimizeNLP alg_builder" << std::endl << std::flush;
    ApplicationReturnStatus retValue = Internal_Error;
 
    // Prepare internal data structures of the algorithm
@@ -538,12 +547,14 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    }
    catch( OPTION_INVALID& exc )
    {
+         std::cout << "IpoptApplication::OptimizeNLP OPTION_INVALID" << std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Invalid option encountered.\n");
       retValue = Invalid_Option;
    }
    catch( IpoptException& exc )
    {
+         std::cout << "IpoptApplication::OptimizeNLP IpoptException" << std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Some uncaught Ipopt exception encountered.\n");
       retValue = Unrecoverable_Exception;
@@ -551,23 +562,28 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    catch( std::bad_alloc& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::Initialize3 Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
    }
    catch( std::overflow_error& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::Initialize3 Insufficient_Memory std::overflow_error" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
    }
    catch( ... )
    {
+         std::cout << "IpoptApplication::OptimizeNLP ..." << std::endl << std::flush;
       if( !rethrow_nonipoptexception_ )
       {
          IpoptException exc("Unknown Exception caught in Ipopt", "Unknown File", -1);
          exc.ReportException(*jnlst_, J_ERROR);
+         std::cout << "IpoptApplication::OptimizeNLP NonIpopt_Exception_Thrown" << std::endl << std::flush;
          retValue = NonIpopt_Exception_Thrown;
       }
       else
       {
+            std::cout << "IpoptApplication::OptimizeNLP throw" << std::endl << std::flush;
          throw;
       }
    }
@@ -581,6 +597,7 @@ ApplicationReturnStatus IpoptApplication::ReOptimizeNLP(
    const SmartPtr<NLP>& nlp
 )
 {
+      std::cout << "IpoptApplication::ReOptimizeNLP0" << std::endl << std::flush;
    ASSERT_EXCEPTION(IsValid(alg_), INVALID_WARMSTART, "ReOptimizeNLP called before OptimizeNLP.");
    OrigIpoptNLP* orig_nlp = static_cast<OrigIpoptNLP*>(GetRawPtr(ip_nlp_));
    DBG_ASSERT(dynamic_cast<OrigIpoptNLP*> (GetRawPtr(ip_nlp_)));
@@ -591,6 +608,7 @@ ApplicationReturnStatus IpoptApplication::ReOptimizeNLP(
 
 ApplicationReturnStatus IpoptApplication::call_optimize()
 {
+      std::cout << "IpoptApplication::call_optimize0" << std::endl << std::flush;
    // Reset the print-level for the screen output
    Index ivalue;
    options_->GetIntegerValue("print_level", ivalue, "");
@@ -622,6 +640,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
 
    ApplicationReturnStatus retValue = Internal_Error;
    SolverReturn status = INTERNAL_ERROR;
+   std::cout << "IpoptApplication::call_optimize0.1" << std::endl << std::flush;
    try
    {
       // check whether timing statistics need to be printed
@@ -656,7 +675,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
 
       // Run the algorithm
       status = p2alg->Optimize();
-
+std::cout << "IpoptApplication::call_optimize1 status=" <<status<< std::endl << std::flush;
       // Since all the output below doesn't make any sense in this
       // case, we rethrow the TOO_FEW_DOF exception here
       ASSERT_EXCEPTION(status != TOO_FEW_DEGREES_OF_FREEDOM, TOO_FEW_DOF, "Too few degrees of freedom (rethrown)!");
@@ -686,6 +705,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
          }
          catch( IpoptNLP::Eval_Error& exc )
          {
+               std::cout << "IpoptApplication::call_optimize Eval_Error"<< std::endl << std::flush;
             // this can happen if the final point was accepted because functions can be evaluated,
             // but functions are not differentiable, so dual infeasibility cannot be computed
             status = INVALID_NUMBER_DETECTED;
@@ -751,67 +771,80 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
       }
       else if( status == MAXITER_EXCEEDED )
       {
+            std::cout << "IpoptApplication::call_optimize MAXITER_EXCEEDED"<< std::endl << std::flush;
          retValue = Maximum_Iterations_Exceeded;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Maximum Number of Iterations Exceeded.\n");
       }
       else if( status == CPUTIME_EXCEEDED )
       {
+            std::cout << "IpoptApplication::call_optimize CPUTIME_EXCEEDED"<< std::endl << std::flush;
          retValue = Maximum_CpuTime_Exceeded;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Maximum CPU time exceeded.\n");
       }
       else if( status == WALLTIME_EXCEEDED )
       {
+            std::cout << "IpoptApplication::call_optimize WALLTIME_EXCEEDED"<< std::endl << std::flush;
          retValue = Maximum_WallTime_Exceeded;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Maximum wallclock time exceeded.\n");
       }
       else if( status == STOP_AT_TINY_STEP )
       {
+            std::cout << "IpoptApplication::call_optimize STOP_AT_TINY_STEP"<< std::endl << std::flush;
          retValue = Search_Direction_Becomes_Too_Small;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Search Direction is becoming Too Small.\n");
       }
       else if( status == STOP_AT_ACCEPTABLE_POINT )
       {
+            std::cout << "IpoptApplication::call_optimize STOP_AT_ACCEPTABLE_POINT"<< std::endl << std::flush;
          retValue = Solved_To_Acceptable_Level;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Solved To Acceptable Level.\n");
       }
       else if( status == FEASIBLE_POINT_FOUND )
       {
+            std::cout << "IpoptApplication::call_optimize FEASIBLE_POINT_FOUND"<< std::endl << std::flush;
          retValue = Feasible_Point_Found;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Feasible point for square problem found.\n");
       }
       else if( status == DIVERGING_ITERATES )
       {
+            std::cout << "IpoptApplication::call_optimize DIVERGING_ITERATES"<< std::endl << std::flush;
          retValue = Diverging_Iterates;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Iterates diverging; problem might be unbounded.\n");
       }
       else if( status == RESTORATION_FAILURE )
       {
+            std::cout << "IpoptApplication::call_optimize RESTORATION_FAILURE"<< std::endl << std::flush;
          retValue = Restoration_Failed;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Restoration Failed!\n");
       }
       else if( status == ERROR_IN_STEP_COMPUTATION )
       {
+            std::cout << "IpoptApplication::call_optimize ERROR_IN_STEP_COMPUTATION"<< std::endl << std::flush;
          retValue = Error_In_Step_Computation;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Error in step computation!\n");
       }
       else if( status == LOCAL_INFEASIBILITY )
       {
+            std::cout << "IpoptApplication::call_optimize LOCAL_INFEASIBILITY"<< std::endl << std::flush;
          retValue = Infeasible_Problem_Detected;
          jnlst_->Printf(J_SUMMARY, J_MAIN,
                         "\nEXIT: Converged to a point of local infeasibility. Problem may be infeasible.\n");
       }
       else if( status == USER_REQUESTED_STOP )
       {
+            std::cout << "IpoptApplication::call_optimize USER_REQUESTED_STOP"<< std::endl << std::flush;
          retValue = User_Requested_Stop;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Stopping optimization at current point as requested by user.\n");
       }
       else if( status == INVALID_NUMBER_DETECTED )
       {
+            std::cout << "IpoptApplication::call_optimize INVALID_NUMBER_DETECTED"<< std::endl << std::flush;
          retValue = Invalid_Number_Detected;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Invalid number in NLP function or derivative detected.\n");
       }
       else
       {
+            std::cout << "IpoptApplication::call_optimize Internal_Error"<< std::endl << std::flush;
          retValue = Internal_Error;
          jnlst_->Printf(J_SUMMARY, J_MAIN,
                         "\nEXIT: INTERNAL ERROR: Unknown SolverReturn value - Notify IPOPT Authors.\n");
@@ -826,6 +859,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( TOO_FEW_DOF& exc )
    {
+         std::cout << "IpoptApplication::call_optimize TOO_FEW_DOF"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_STRONGWARNING);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Problem has too few degrees of freedom.\n");
       retValue = Not_Enough_Degrees_Of_Freedom;
@@ -833,6 +867,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( OPTION_INVALID& exc )
    {
+         std::cout << "IpoptApplication::call_optimize OPTION_INVALID"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Invalid option encountered.\n");
       retValue = Invalid_Option;
@@ -840,12 +875,14 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( DYNAMIC_LIBRARY_FAILURE& exc )
    {
+         std::cout << "IpoptApplication::call_optimize DYNAMIC_LIBRARY_FAILURE"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Library loading failure.\n");
       retValue = Invalid_Option;
    }
    catch( INCONSISTENT_BOUNDS& exc )
    {
+         std::cout << "IpoptApplication::call_optimize INCONSISTENT_BOUNDS"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_MOREDETAILED);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Problem has inconsistent variable bounds or constraint sides.\n");
       retValue = Invalid_Problem_Definition;
@@ -853,6 +890,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( IpoptException& exc )
    {
+         std::cout << "IpoptApplication::call_optimize IpoptException"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Some uncaught Ipopt exception encountered.\n");
       retValue = Unrecoverable_Exception;
@@ -860,25 +898,30 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    catch( std::bad_alloc& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::call_optimize Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
       status = OUT_OF_MEMORY;
    }
    catch( std::overflow_error& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::call_optimize Insufficient_Memory std::overflow_error" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
       status = OUT_OF_MEMORY;
    }
    catch( ... )
    {
+         std::cout << "IpoptApplication::call_optimize ..." << std::endl << std::flush;
       if( !rethrow_nonipoptexception_ )
       {
          IpoptException exc("Unknown Exception caught in Ipopt", "Unknown File", -1);
          exc.ReportException(*jnlst_, J_ERROR);
          retValue = NonIpopt_Exception_Thrown;
+         std::cout << "IpoptApplication::call_optimize NonIpopt_Exception_Thrown" << std::endl << std::flush;
       }
       else
       {
+            std::cout << "IpoptApplication::call_optimize throw" << std::endl << std::flush;
          jnlst_->FlushBuffer();
          throw;
       }
@@ -923,6 +966,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
             break;
          default:
          {
+               std::cout << "IpoptApplication::call_optimize status.default" << std::endl << std::flush;
             SmartPtr<Vector> tmp = p2ip_data->curr()->y_c()->MakeNew();
             tmp->Set(0.);
             c = ConstPtr(tmp);
@@ -944,7 +988,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
 
    jnlst_->FlushBuffer();
-
+std::cout << "IpoptApplication::call_optimize final retValue="<< retValue<< std::endl << std::flush;
    return retValue;
 }
 
