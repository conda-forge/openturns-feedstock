diff --git a/src/Algorithm/IpBacktrackingLineSearch.cpp b/src/Algorithm/IpBacktrackingLineSearch.cpp
index 6782ac59..29edce5b 100644
--- a/src/Algorithm/IpBacktrackingLineSearch.cpp
+++ b/src/Algorithm/IpBacktrackingLineSearch.cpp
@@ -14,6 +14,7 @@
 
 #include <cmath>
 #include <limits>
+#include <iostream>
 
 namespace Ipopt
 {
@@ -317,6 +318,7 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
       }
       else
       {
+          std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint throw STEP_COMPUTATION_FAILED1"<< std::endl << std::flush;
          THROW_EXCEPTION(STEP_COMPUTATION_FAILED,
                          "We are in an emergency mode, but no restoration phase or other fall back is available.");
       }
@@ -566,11 +568,16 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
             }
 
             // ToDo make the 1e-2 below a parameter?
+            
+            std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint curr_constraint_violation="<<IpCq().curr_constraint_violation()<< std::endl << std::flush;
+            std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint unscaled_curr_nlp_constraint_violation="<<IpCq().unscaled_curr_nlp_constraint_violation(NORM_MAX)<< std::endl << std::flush;
+
             // added second criteria to cover cases where tol has been set to a large value
             if( IpCq().curr_constraint_violation() <= 1e-2 * IpData().tol() &&
                 IpCq().unscaled_curr_nlp_constraint_violation(NORM_MAX) <= 1e-1 * constr_viol_tol_ )
             {
                bool found_acceptable = RestoreAcceptablePoint();
+               std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint found_acceptable="<<found_acceptable<< std::endl << std::flush;
                if( found_acceptable )
                {
                   Jnlst().Printf(J_WARNING, J_LINE_SEARCH,
@@ -581,6 +588,7 @@ void BacktrackingLineSearch::FindAcceptableTrialPoint()
                }
                else
                {
+                    std::cout << "BacktrackingLineSearch::FindAcceptableTrialPoint throw STEP_COMPUTATION_FAILED2"<< std::endl << std::flush;
                   Jnlst().Printf(J_STRONGWARNING, J_LINE_SEARCH,
                                  "Cannot call restoration phase at point that is almost feasible %s(violation %e).\nAbort in line search due to no other fall back.\n",
                                  dynamic_cast<OrigIpoptNLP*>(GetRawPtr(IpCq().GetIpoptNLP())) == NULL ? "for the restoration NLP " : "",
@@ -1289,13 +1297,15 @@ bool BacktrackingLineSearch::RestoreAcceptablePoint()
 
    if( !IsValid(acceptable_iterate_) )
    {
+          std::cout << "BacktrackingLineSearch::RestoreAcceptablePoint false="<< std::endl << std::flush;
+
       return false;
    }
 
    SmartPtr<IteratesVector> prev_iterate = acceptable_iterate_->MakeNewContainer();
    IpData().set_trial(prev_iterate);
    IpData().AcceptTrialPoint();
-
+std::cout << "BacktrackingLineSearch::RestoreAcceptablePoint true="<< std::endl << std::flush;
    return true;
 }
 
diff --git a/src/Algorithm/IpIpoptAlg.cpp b/src/Algorithm/IpIpoptAlg.cpp
index d9092e5c..351b0f96 100644
--- a/src/Algorithm/IpIpoptAlg.cpp
+++ b/src/Algorithm/IpIpoptAlg.cpp
@@ -18,6 +18,7 @@
 #if IPOPT_CHECKLEVEL > 1 && defined(IPOPT_HAS_FEENABLEEXCEPT)
 #include <cfenv>
 #endif
+#include <iostream>
 
 namespace Ipopt
 {
@@ -293,6 +294,7 @@ SolverReturn IpoptAlgorithm::Optimize(
    bool isResto /*= false */
 )
 {
+      std::cout << "IpoptAlgorithm::Optimize0"<< std::endl << std::flush;
    DBG_START_METH("IpoptAlgorithm::Optimize", dbg_verbosity);
 
    // Start measuring CPU time
@@ -341,6 +343,7 @@ SolverReturn IpoptAlgorithm::Optimize(
 
       IpData().TimingStats().CheckConvergence().Start();
       ConvergenceCheck::ConvergenceStatus conv_status = conv_check_->CheckConvergence();
+      std::cout << "IpoptAlgorithm::Optimize1 conv_status"<<conv_status<< std::endl << std::flush;
       IpData().TimingStats().CheckConvergence().End();
 
       // main loop
@@ -379,6 +382,7 @@ SolverReturn IpoptAlgorithm::Optimize(
          // If we are in the emergency mode, ask the line search object
          // to go to the fallback options.  If that isn't possible,
          // issue error message
+         std::cout << "IpoptAlgorithm::Optimize2 emergency_mode"<<emergency_mode<< std::endl << std::flush;
          if( emergency_mode )
          {
             if( line_search_->ActivateFallbackMechanism() )
@@ -388,6 +392,9 @@ SolverReturn IpoptAlgorithm::Optimize(
             }
             else
             {
+                  
+                  std::cout << "IpoptAlgorithm::Optimize1 throw STEP_COMPUTATION_FAILED"<< std::endl << std::flush;
+                  
                Jnlst().Printf(J_ERROR, J_MAIN,
                               "ERROR: Problem in step computation, but emergency mode cannot be activated.\n");
                THROW_EXCEPTION(STEP_COMPUTATION_FAILED, "Step computation failed.");
@@ -413,6 +420,7 @@ SolverReturn IpoptAlgorithm::Optimize(
 
          IpData().TimingStats().CheckConvergence().Start();
          conv_status = conv_check_->CheckConvergence();
+         std::cout << "IpoptAlgorithm::Optimize2 conv_status"<<conv_status<< std::endl << std::flush;
          IpData().TimingStats().CheckConvergence().End();
       }
 
@@ -524,6 +532,7 @@ SolverReturn IpoptAlgorithm::Optimize(
    }
    catch( STEP_COMPUTATION_FAILED& exc )
    {
+         std::cout << "IpoptAlgorithm::Optimize STEP_COMPUTATION_FAILED"<< std::endl << std::flush;
       exc.ReportException(Jnlst(), J_MOREDETAILED);
       IpData().TimingStats().ComputeAcceptableTrialPoint().EndIfStarted();
       retval = ERROR_IN_STEP_COMPUTATION;
@@ -559,6 +568,7 @@ SolverReturn IpoptAlgorithm::Optimize(
    }
 
    DBG_ASSERT(retval != UNASSIGNED && "Unknown return code in the algorithm");
+   std::cout << "IpoptAlgorithm::Optimize retval="<<retval<< std::endl << std::flush;
    return retval;
 }
 
@@ -658,11 +668,14 @@ void IpoptAlgorithm::AcceptTrialPoint()
    {
       Jnlst().Printf(J_SUMMARY, J_MAIN,
                      "Line search didn't find acceptable trial point.\n");
+
       return;
    }
+   
 
    // Adjust the bounds if necessary
    Index adjusted_slacks = IpCq().AdjustedTrialSlacks();
+   std::cout << "IpoptAlgorithm::AcceptTrialPoint0 adjusted_slacks="<<adjusted_slacks<< std::endl << std::flush;
    DBG_PRINT((1, "adjusted_slacks = %" IPOPT_INDEX_FORMAT "\n", adjusted_slacks));
    if( adjusted_slacks > 0 )
    {
@@ -720,6 +733,7 @@ void IpoptAlgorithm::AcceptTrialPoint()
    SmartPtr<const Vector> new_z_L;
    max_correction = correct_bound_multiplier(*IpData().trial()->z_L(), *IpCq().trial_slack_x_L(),
                     *IpCq().trial_compl_x_L(), new_z_L);
+   std::cout << "IpoptAlgorithm::AcceptTrialPoint3.1 max_correction="<<max_correction<< std::endl << std::flush;
    if( max_correction > 0. )
    {
       Jnlst().Printf(J_DETAILED, J_MAIN,
@@ -730,6 +744,7 @@ void IpoptAlgorithm::AcceptTrialPoint()
    SmartPtr<const Vector> new_z_U;
    max_correction = correct_bound_multiplier(*IpData().trial()->z_U(), *IpCq().trial_slack_x_U(),
                     *IpCq().trial_compl_x_U(), new_z_U);
+   std::cout << "IpoptAlgorithm::AcceptTrialPoint3.2 max_correction="<<max_correction<< std::endl << std::flush;
    if( max_correction > 0. )
    {
       Jnlst().Printf(J_DETAILED, J_MAIN,
@@ -740,6 +755,7 @@ void IpoptAlgorithm::AcceptTrialPoint()
    SmartPtr<const Vector> new_v_L;
    max_correction = correct_bound_multiplier(*IpData().trial()->v_L(), *IpCq().trial_slack_s_L(),
                     *IpCq().trial_compl_s_L(), new_v_L);
+std::cout << "IpoptAlgorithm::AcceptTrialPoint3.3 max_correction="<<max_correction<< std::endl << std::flush;
    if( max_correction > 0. )
    {
       Jnlst().Printf(J_DETAILED, J_MAIN,
@@ -750,6 +766,7 @@ void IpoptAlgorithm::AcceptTrialPoint()
    SmartPtr<const Vector> new_v_U;
    max_correction = correct_bound_multiplier(*IpData().trial()->v_U(), *IpCq().trial_slack_s_U(),
                     *IpCq().trial_compl_s_U(), new_v_U);
+   std::cout << "IpoptAlgorithm::AcceptTrialPoint3.4 max_correction="<<max_correction<< std::endl << std::flush;
    if( max_correction > 0. )
    {
       Jnlst().Printf(J_DETAILED, J_MAIN,
@@ -760,7 +777,7 @@ void IpoptAlgorithm::AcceptTrialPoint()
    SmartPtr<IteratesVector> trial = IpData().trial()->MakeNewContainer();
    trial->Set_bound_mult(*new_z_L, *new_z_U, *new_v_L, *new_v_U);
    IpData().set_trial(trial);
-
+std::cout << "IpoptAlgorithm::AcceptTrialPoint3.5 corrected="<<corrected<< std::endl << std::flush;
    if( corrected )
    {
       IpData().Append_info_string("z");
@@ -794,6 +811,7 @@ void IpoptAlgorithm::AcceptTrialPoint()
          SmartPtr<Vector> y_c = IpData().curr()->y_c()->MakeNew();
          SmartPtr<Vector> y_d = IpData().curr()->y_d()->MakeNew();
          bool retval = eq_multiplier_calculator_->CalculateMultipliers(*y_c, *y_d);
+         std::cout << "IpoptAlgorithm::AcceptTrialPoint5 CalculateMultipliers="<<retval<< std::endl << std::flush;
          if( retval )
          {
             SmartPtr<const IteratesVector> curr = IpData().curr();
@@ -862,6 +880,8 @@ void IpoptAlgorithm::ComputeFeasibilityMultipliers()
 
    // if not primal feasible yet, then do not compute multipliers yet
    Number constr_viol = IpCq().unscaled_curr_nlp_constraint_violation(NORM_MAX);
+   std::cout << "IpoptAlgorithm::ComputeFeasibilityMultipliers0 constr_viol="<<constr_viol<< " tol="<<constr_viol_tol_<< std::endl << std::flush;
+   
    if( constr_viol > constr_viol_tol_ )
    {
       return;
@@ -878,6 +898,8 @@ void IpoptAlgorithm::ComputeFeasibilityMultipliers()
 
    IpData().TimingStats().CheckConvergence().Start();
    ConvergenceCheck::ConvergenceStatus conv_status = conv_check_->CheckConvergence(false);
+   
+   std::cout << "IpoptAlgorithm::ComputeFeasibilityMultipliers1 conv_status="<<conv_status<< std::endl << std::flush;
    IpData().TimingStats().CheckConvergence().End();
 
    // if converged or reached some limit, then do not update multipliers
@@ -909,6 +931,7 @@ void IpoptAlgorithm::ComputeFeasibilityMultipliers()
    IpData().set_trial(iterates);
    IpData().AcceptTrialPoint();
    bool retval = eq_multiplier_calculator_->CalculateMultipliers(*y_c, *y_d);
+   std::cout << "IpoptAlgorithm::ComputeFeasibilityMultipliers2 retval="<<retval<< std::endl << std::flush;
    if( retval )
    {
       //TODO Check if following line is really necessary
@@ -951,7 +974,7 @@ void IpoptAlgorithm::ComputeFeasibilityMultipliersPostprocess()
    DBG_START_METH("IpoptAlgorithm::ComputeFeasibilityMultipliersPostprocess",
                   dbg_verbosity);
    DBG_ASSERT(IpCq().IsSquareProblem());
-
+std::cout << "IpoptAlgorithm::ComputeFeasibilityMultipliersPostprocess0"<< std::endl << std::flush;
    // if we don't have an object for computing least square
    // multipliers we don't compute them
    if( IsNull(eq_multiplier_calculator_) )
@@ -979,6 +1002,7 @@ void IpoptAlgorithm::ComputeFeasibilityMultipliersPostprocess()
    IpData().set_trial(iterates);
    IpData().AcceptTrialPoint();
    bool retval = eq_multiplier_calculator_->CalculateMultipliers(*y_c, *y_d);
+   std::cout << "IpoptAlgorithm::ComputeFeasibilityMultipliersPostprocess1 retval="<<retval<< std::endl << std::flush;
    if( retval )
    {
       //TODO Check if following line is really necessary
diff --git a/src/Interfaces/IpIpoptApplication.cpp b/src/Interfaces/IpIpoptApplication.cpp
index 44525aea..422add7e 100644
--- a/src/Interfaces/IpIpoptApplication.cpp
+++ b/src/Interfaces/IpIpoptApplication.cpp
@@ -29,6 +29,7 @@
 #include <cassert>
 #include <cmath>
 #include <fstream>
+#include <iostream>
 
 // Factory to facilitate creating IpoptApplication objects from within a DLL
 
@@ -105,6 +106,7 @@ IpoptApplication::IpoptApplication(
    catch( std::overflow_error& )
    {
       jnlst_->Printf(J_ERROR, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
+      
       THROW_EXCEPTION(IPOPT_APPLICATION_ERROR, "Not enough memory");
    }
    catch( ... )
@@ -270,11 +272,13 @@ ApplicationReturnStatus IpoptApplication::Initialize(
    }
    catch( std::bad_alloc& )
    {
+      std::cout << "IpoptApplication::Initialize1 Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
       return Insufficient_Memory;
    }
    catch( std::overflow_error& )
    {
+         std::cout << "IpoptApplication::Initialize1 Integer type too small for required memory std::overflow_error" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
       return Insufficient_Memory;
    }
@@ -309,10 +313,12 @@ ApplicationReturnStatus IpoptApplication::Initialize(
       catch( std::bad_alloc& )
       {
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
+         std::cout << "IpoptApplication::Initialize2 Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
          return Insufficient_Memory;
       }
       catch( std::overflow_error& )
       {
+            std::cout << "IpoptApplication::Initialize2 Insufficient_Memory std::overflow_error" << std::endl << std::flush;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
          return Insufficient_Memory;
       }
@@ -469,6 +475,7 @@ ApplicationReturnStatus IpoptApplication::OptimizeTNLP(
    const SmartPtr<TNLP>& tnlp
 )
 {
+      std::cout << "IpoptApplication::OptimizeTNLP" << std::endl << std::flush;
    nlp_adapter_ = new TNLPAdapter(GetRawPtr(tnlp), ConstPtr(jnlst_));
    return OptimizeNLP(nlp_adapter_);
 }
@@ -489,6 +496,7 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    const SmartPtr<NLP>& nlp
 )
 {
+      std::cout << "IpoptApplication::OptimizeNLP" << std::endl << std::flush;
    SmartPtr<AlgorithmBuilder> alg_builder = NULL;
    return OptimizeNLP(nlp, alg_builder);
 }
@@ -498,6 +506,7 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    SmartPtr<AlgorithmBuilder>& alg_builder
 )
 {
+      std::cout << "IpoptApplication::OptimizeNLP alg_builder" << std::endl << std::flush;
    ApplicationReturnStatus retValue = Internal_Error;
 
    // Prepare internal data structures of the algorithm
@@ -538,12 +547,14 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    }
    catch( OPTION_INVALID& exc )
    {
+         std::cout << "IpoptApplication::OptimizeNLP OPTION_INVALID" << std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Invalid option encountered.\n");
       retValue = Invalid_Option;
    }
    catch( IpoptException& exc )
    {
+         std::cout << "IpoptApplication::OptimizeNLP IpoptException" << std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Some uncaught Ipopt exception encountered.\n");
       retValue = Unrecoverable_Exception;
@@ -551,23 +562,28 @@ ApplicationReturnStatus IpoptApplication::OptimizeNLP(
    catch( std::bad_alloc& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::Initialize3 Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
    }
    catch( std::overflow_error& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::Initialize3 Insufficient_Memory std::overflow_error" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
    }
    catch( ... )
    {
+         std::cout << "IpoptApplication::OptimizeNLP ..." << std::endl << std::flush;
       if( !rethrow_nonipoptexception_ )
       {
          IpoptException exc("Unknown Exception caught in Ipopt", "Unknown File", -1);
          exc.ReportException(*jnlst_, J_ERROR);
+         std::cout << "IpoptApplication::OptimizeNLP NonIpopt_Exception_Thrown" << std::endl << std::flush;
          retValue = NonIpopt_Exception_Thrown;
       }
       else
       {
+            std::cout << "IpoptApplication::OptimizeNLP throw" << std::endl << std::flush;
          throw;
       }
    }
@@ -581,6 +597,7 @@ ApplicationReturnStatus IpoptApplication::ReOptimizeNLP(
    const SmartPtr<NLP>& nlp
 )
 {
+      std::cout << "IpoptApplication::ReOptimizeNLP0" << std::endl << std::flush;
    ASSERT_EXCEPTION(IsValid(alg_), INVALID_WARMSTART, "ReOptimizeNLP called before OptimizeNLP.");
    OrigIpoptNLP* orig_nlp = static_cast<OrigIpoptNLP*>(GetRawPtr(ip_nlp_));
    DBG_ASSERT(dynamic_cast<OrigIpoptNLP*> (GetRawPtr(ip_nlp_)));
@@ -591,6 +608,7 @@ ApplicationReturnStatus IpoptApplication::ReOptimizeNLP(
 
 ApplicationReturnStatus IpoptApplication::call_optimize()
 {
+      std::cout << "IpoptApplication::call_optimize0" << std::endl << std::flush;
    // Reset the print-level for the screen output
    Index ivalue;
    options_->GetIntegerValue("print_level", ivalue, "");
@@ -622,6 +640,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
 
    ApplicationReturnStatus retValue = Internal_Error;
    SolverReturn status = INTERNAL_ERROR;
+   std::cout << "IpoptApplication::call_optimize0.1" << std::endl << std::flush;
    try
    {
       // check whether timing statistics need to be printed
@@ -656,7 +675,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
 
       // Run the algorithm
       status = p2alg->Optimize();
-
+std::cout << "IpoptApplication::call_optimize1 status=" <<status<< std::endl << std::flush;
       // Since all the output below doesn't make any sense in this
       // case, we rethrow the TOO_FEW_DOF exception here
       ASSERT_EXCEPTION(status != TOO_FEW_DEGREES_OF_FREEDOM, TOO_FEW_DOF, "Too few degrees of freedom (rethrown)!");
@@ -686,6 +705,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
          }
          catch( IpoptNLP::Eval_Error& exc )
          {
+               std::cout << "IpoptApplication::call_optimize Eval_Error"<< std::endl << std::flush;
             // this can happen if the final point was accepted because functions can be evaluated,
             // but functions are not differentiable, so dual infeasibility cannot be computed
             status = INVALID_NUMBER_DETECTED;
@@ -751,67 +771,80 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
       }
       else if( status == MAXITER_EXCEEDED )
       {
+            std::cout << "IpoptApplication::call_optimize MAXITER_EXCEEDED"<< std::endl << std::flush;
          retValue = Maximum_Iterations_Exceeded;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Maximum Number of Iterations Exceeded.\n");
       }
       else if( status == CPUTIME_EXCEEDED )
       {
+            std::cout << "IpoptApplication::call_optimize CPUTIME_EXCEEDED"<< std::endl << std::flush;
          retValue = Maximum_CpuTime_Exceeded;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Maximum CPU time exceeded.\n");
       }
       else if( status == WALLTIME_EXCEEDED )
       {
+            std::cout << "IpoptApplication::call_optimize WALLTIME_EXCEEDED"<< std::endl << std::flush;
          retValue = Maximum_WallTime_Exceeded;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Maximum wallclock time exceeded.\n");
       }
       else if( status == STOP_AT_TINY_STEP )
       {
+            std::cout << "IpoptApplication::call_optimize STOP_AT_TINY_STEP"<< std::endl << std::flush;
          retValue = Search_Direction_Becomes_Too_Small;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Search Direction is becoming Too Small.\n");
       }
       else if( status == STOP_AT_ACCEPTABLE_POINT )
       {
+            std::cout << "IpoptApplication::call_optimize STOP_AT_ACCEPTABLE_POINT"<< std::endl << std::flush;
          retValue = Solved_To_Acceptable_Level;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Solved To Acceptable Level.\n");
       }
       else if( status == FEASIBLE_POINT_FOUND )
       {
+            std::cout << "IpoptApplication::call_optimize FEASIBLE_POINT_FOUND"<< std::endl << std::flush;
          retValue = Feasible_Point_Found;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Feasible point for square problem found.\n");
       }
       else if( status == DIVERGING_ITERATES )
       {
+            std::cout << "IpoptApplication::call_optimize DIVERGING_ITERATES"<< std::endl << std::flush;
          retValue = Diverging_Iterates;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Iterates diverging; problem might be unbounded.\n");
       }
       else if( status == RESTORATION_FAILURE )
       {
+            std::cout << "IpoptApplication::call_optimize RESTORATION_FAILURE"<< std::endl << std::flush;
          retValue = Restoration_Failed;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Restoration Failed!\n");
       }
       else if( status == ERROR_IN_STEP_COMPUTATION )
       {
+            std::cout << "IpoptApplication::call_optimize ERROR_IN_STEP_COMPUTATION"<< std::endl << std::flush;
          retValue = Error_In_Step_Computation;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Error in step computation!\n");
       }
       else if( status == LOCAL_INFEASIBILITY )
       {
+            std::cout << "IpoptApplication::call_optimize LOCAL_INFEASIBILITY"<< std::endl << std::flush;
          retValue = Infeasible_Problem_Detected;
          jnlst_->Printf(J_SUMMARY, J_MAIN,
                         "\nEXIT: Converged to a point of local infeasibility. Problem may be infeasible.\n");
       }
       else if( status == USER_REQUESTED_STOP )
       {
+            std::cout << "IpoptApplication::call_optimize USER_REQUESTED_STOP"<< std::endl << std::flush;
          retValue = User_Requested_Stop;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Stopping optimization at current point as requested by user.\n");
       }
       else if( status == INVALID_NUMBER_DETECTED )
       {
+            std::cout << "IpoptApplication::call_optimize INVALID_NUMBER_DETECTED"<< std::endl << std::flush;
          retValue = Invalid_Number_Detected;
          jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Invalid number in NLP function or derivative detected.\n");
       }
       else
       {
+            std::cout << "IpoptApplication::call_optimize Internal_Error"<< std::endl << std::flush;
          retValue = Internal_Error;
          jnlst_->Printf(J_SUMMARY, J_MAIN,
                         "\nEXIT: INTERNAL ERROR: Unknown SolverReturn value - Notify IPOPT Authors.\n");
@@ -826,6 +859,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( TOO_FEW_DOF& exc )
    {
+         std::cout << "IpoptApplication::call_optimize TOO_FEW_DOF"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_STRONGWARNING);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Problem has too few degrees of freedom.\n");
       retValue = Not_Enough_Degrees_Of_Freedom;
@@ -833,6 +867,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( OPTION_INVALID& exc )
    {
+         std::cout << "IpoptApplication::call_optimize OPTION_INVALID"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Invalid option encountered.\n");
       retValue = Invalid_Option;
@@ -840,12 +875,14 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( DYNAMIC_LIBRARY_FAILURE& exc )
    {
+         std::cout << "IpoptApplication::call_optimize DYNAMIC_LIBRARY_FAILURE"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Library loading failure.\n");
       retValue = Invalid_Option;
    }
    catch( INCONSISTENT_BOUNDS& exc )
    {
+         std::cout << "IpoptApplication::call_optimize INCONSISTENT_BOUNDS"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_MOREDETAILED);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Problem has inconsistent variable bounds or constraint sides.\n");
       retValue = Invalid_Problem_Definition;
@@ -853,6 +890,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
    catch( IpoptException& exc )
    {
+         std::cout << "IpoptApplication::call_optimize IpoptException"<< std::endl << std::flush;
       exc.ReportException(*jnlst_, J_ERROR);
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Some uncaught Ipopt exception encountered.\n");
       retValue = Unrecoverable_Exception;
@@ -860,25 +898,30 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    catch( std::bad_alloc& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::call_optimize Insufficient_Memory std::bad_alloc" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Not enough memory.\n");
       status = OUT_OF_MEMORY;
    }
    catch( std::overflow_error& )
    {
       retValue = Insufficient_Memory;
+      std::cout << "IpoptApplication::call_optimize Insufficient_Memory std::overflow_error" << std::endl << std::flush;
       jnlst_->Printf(J_SUMMARY, J_MAIN, "\nEXIT: Integer type too small for required memory.\n");
       status = OUT_OF_MEMORY;
    }
    catch( ... )
    {
+         std::cout << "IpoptApplication::call_optimize ..." << std::endl << std::flush;
       if( !rethrow_nonipoptexception_ )
       {
          IpoptException exc("Unknown Exception caught in Ipopt", "Unknown File", -1);
          exc.ReportException(*jnlst_, J_ERROR);
          retValue = NonIpopt_Exception_Thrown;
+         std::cout << "IpoptApplication::call_optimize NonIpopt_Exception_Thrown" << std::endl << std::flush;
       }
       else
       {
+            std::cout << "IpoptApplication::call_optimize throw" << std::endl << std::flush;
          jnlst_->FlushBuffer();
          throw;
       }
@@ -923,6 +966,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
             break;
          default:
          {
+               std::cout << "IpoptApplication::call_optimize status.default" << std::endl << std::flush;
             SmartPtr<Vector> tmp = p2ip_data->curr()->y_c()->MakeNew();
             tmp->Set(0.);
             c = ConstPtr(tmp);
@@ -944,7 +988,7 @@ ApplicationReturnStatus IpoptApplication::call_optimize()
    }
 
    jnlst_->FlushBuffer();
-
+std::cout << "IpoptApplication::call_optimize final retValue="<< retValue<< std::endl << std::flush;
    return retValue;
 }
 
