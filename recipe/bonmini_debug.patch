diff --git a/Bonmin/examples/CppExample/MyBonmin.cpp b/Bonmin/examples/CppExample/MyBonmin.cpp
index 558bac5..bfbd1c3 100644
--- a/Bonmin/examples/CppExample/MyBonmin.cpp
+++ b/Bonmin/examples/CppExample/MyBonmin.cpp
@@ -53,21 +53,26 @@ int main (int argc, char *argv[])
   
   // Here we can change the default value of some Bonmin or Ipopt option
   bonmin.options()->SetNumericValue("bonmin.time_limit", 5); //changes bonmin's time limit
-  bonmin.options()->SetStringValue("mu_oracle","loqo");
+  // bonmin.options()->SetStringValue("mu_oracle","loqo");
   
   //Here we read several option files
-  bonmin.readOptionsFile("Mybonmin.opt");
-  bonmin.readOptionsFile();// This reads the default file "bonmin.opt"
+  // bonmin.readOptionsFile("Mybonmin.opt");
+  // bonmin.readOptionsFile();// This reads the default file "bonmin.opt"
   
   // Options can also be set by using a string with a format similar to the bonmin.opt file
   bonmin.readOptionsString("bonmin.algorithm B-BB\n");
   
   // Now we can obtain the value of the new option
-  int printSolution;
-  bonmin.options()->GetEnumValue("print_solution", printSolution,"");
-  if(printSolution == 1){
+  // int printSolution;
+  // bonmin.options()->GetEnumValue("print_solution", printSolution,"");
+  // if(printSolution == 1){
     tminlp->printSolutionAtEndOfAlgorithm();
-  }
+  // }
+
+  // extra options
+  bonmin.options()->SetStringValue("honor_original_bounds", "yes");
+  bonmin.options()->SetNumericValue("constr_viol_tol", 1e-5);
+  bonmin.options()->SetNumericValue("bound_relax_factor", 0.0);
 
   //Now initialize from tminlp
   bonmin.initialize(GetRawPtr(tminlp));
@@ -96,6 +101,9 @@ int main (int argc, char *argv[])
 	     <<E.message()<<std::endl;
   }
 
+  std::string optionsLog;
+  bonmin.options()->PrintList(optionsLog);
+  std::cout << optionsLog << std::endl;
 
   return 0;
 }
diff --git a/Bonmin/examples/CppExample/MyTMINLP.cpp b/Bonmin/examples/CppExample/MyTMINLP.cpp
index cf14b65..42ae795 100644
--- a/Bonmin/examples/CppExample/MyTMINLP.cpp
+++ b/Bonmin/examples/CppExample/MyTMINLP.cpp
@@ -23,10 +23,10 @@ MyTMINLP::get_variables_types(Index n, VariableType* var_types)
 bool 
 MyTMINLP::get_variables_linearity(Index n, Ipopt::TNLP::LinearityType* var_types)
 {
-  var_types[0] = Ipopt::TNLP::LINEAR;
+  var_types[0] = Ipopt::TNLP::NON_LINEAR;
   var_types[1] = Ipopt::TNLP::NON_LINEAR;
   var_types[2] = Ipopt::TNLP::NON_LINEAR;
-  var_types[3] = Ipopt::TNLP::LINEAR;
+  var_types[3] = Ipopt::TNLP::NON_LINEAR;
   return true;
 }
 
@@ -36,8 +36,8 @@ MyTMINLP::get_constraints_linearity(Index m, Ipopt::TNLP::LinearityType* const_t
 {
   assert (m==3);
   const_types[0] = Ipopt::TNLP::NON_LINEAR;
-  const_types[1] = Ipopt::TNLP::LINEAR;
-  const_types[2] = Ipopt::TNLP::LINEAR;
+  const_types[1] = Ipopt::TNLP::NON_LINEAR;
+  const_types[2] = Ipopt::TNLP::NON_LINEAR;
   return true;
 }
 bool 
@@ -104,6 +104,8 @@ MyTMINLP::eval_f(Index n, const Number* x, bool new_x, Number& obj_value)
 {
   assert(n==4);
   obj_value = - x[0] - x[1] - x[2];
+    std::cout <<"MyTMINLP::eval_f x=" <<x[0] <<"; "<< x[1]  <<"; "<< x[2]<<"; "<<x[3]<<" y=" << obj_value<< std::endl<< std::flush;
+
   return true;
 }
 
diff --git a/Bonmin/src/Algorithms/BonSubMipSolver.cpp b/Bonmin/src/Algorithms/BonSubMipSolver.cpp
index 01843e8..a8c55df 100644
--- a/Bonmin/src/Algorithms/BonSubMipSolver.cpp
+++ b/Bonmin/src/Algorithms/BonSubMipSolver.cpp
@@ -208,7 +208,7 @@ namespace Bonmin {
       cbc.setMaximumSolutions(1);
       cbc.setCutoff(cutoff);
 
-      
+      std::cout << "SubMipSolver::find_good_sol cbc.branchAndBound" << std::endl << std::flush;
       cbc.branchAndBound();
       lowBound_ = cbc.getBestPossibleObjValue();
 
@@ -319,6 +319,7 @@ namespace Bonmin {
   void
   SubMipSolver::optimize(double cutoff, int loglevel, double maxTime)
   {
+    std::cout << "SubMipSolver::optimize0" << std::endl << std::flush;
     if (clp_) {
       assert(strategy_);
       CbcStrategyDefault * strat_default = dynamic_cast<CbcStrategyDefault *>(strategy_->clone());
@@ -343,6 +344,7 @@ namespace Bonmin {
       cbc.setDblParam( CbcModel::CbcAllowableFractionGap, gap_tol_);
 
       //cbc.solver()->writeMpsNative("FP.mps", NULL, NULL, 1);
+      std::cout << "SubMipSolver::optimize cbc.branchAndBound cbc=" << (&cbc) << std::endl << std::flush;
       cbc.branchAndBound();
       lowBound_ = cbc.getBestPossibleObjValue();
 
diff --git a/Bonmin/src/CbcBonmin/BonCbc.cpp b/Bonmin/src/CbcBonmin/BonCbc.cpp
index 5c10cbd..71f57ff 100644
--- a/Bonmin/src/CbcBonmin/BonCbc.cpp
+++ b/Bonmin/src/CbcBonmin/BonCbc.cpp
@@ -84,6 +84,7 @@ namespace Bonmin
   /** Destructor.*/
   Bab::~Bab()
   {
+    std::cout << "Bab:::~Bab model_=" << std::endl << std::flush;
     if (bestSolution_) delete [] bestSolution_;
     bestSolution_ = NULL;
     for ( int i = 0 ; i < nObjects_ ; i++) {
@@ -104,7 +105,7 @@ namespace Bonmin
   void
   Bab::branchAndBound(BabSetupBase & s)
   {
-
+    std::cout << "Bab::branchAndBound0 model_=" << std::endl << std::flush;
     double remaining_time = s.getDoubleParameter(BabSetupBase::MaxTime) + CoinCpuTime();
     /* Put a link to this into solver.*/
     OsiBabSolver *  babInfo = dynamic_cast<OsiBabSolver *>(s.continuousSolver()->getAuxiliaryInfo());
@@ -521,6 +522,7 @@ namespace Bonmin
     //model_.branchAndBound(3);
     remaining_time -= CoinCpuTime();
     model_.setDblParam(CbcModel::CbcMaximumSeconds, remaining_time);
+    std::cout << "Bab::branchAndBound model_.branchAndBound remaining_time=" << remaining_time << " model_=" << std::endl << std::flush;
     if(remaining_time > 0.)
       model_.branchAndBound();
     }
diff --git a/Bonmin/src/Interfaces/BonOsiTMINLPInterface.cpp b/Bonmin/src/Interfaces/BonOsiTMINLPInterface.cpp
index ee31245..f454935 100644
--- a/Bonmin/src/Interfaces/BonOsiTMINLPInterface.cpp
+++ b/Bonmin/src/Interfaces/BonOsiTMINLPInterface.cpp
@@ -988,6 +988,7 @@ OsiTMINLPInterface::resolveForCost(int numsolve, bool keepWarmStart)
 void
 OsiTMINLPInterface::resolveForRobustness(int numsolve)
 {
+  std::cout << "OsiTMINLPInterface::resolveForRobustness0" <<std::endl<< std::flush;
   // This method assumes that a problem has just been solved and we try for a
   // different solution. So disregard (in fact, clear out) any warmstart info
   // we might have, and acquire a new one before returning.
@@ -1009,7 +1010,7 @@ OsiTMINLPInterface::resolveForRobustness(int numsolve)
       messages_)
   <<1<< CoinMessageEol ;
   solveAndCheckErrors(0,0,"resolve robustness");
-
+std::cout << "OsiTMINLPInterface::resolveForRobustness1" <<std::endl<< std::flush;
 
   char c='*';
   if(isAbandoned()) {
@@ -1030,6 +1031,7 @@ OsiTMINLPInterface::resolveForRobustness(int numsolve)
     }
     return; //we won go on
   }
+std::cout << "OsiTMINLPInterface::resolveForRobustness2" <<std::endl<< std::flush;
 
   //still unsolved try again with different random starting points
   for(int f = 0; f < numsolve ; f++) {
@@ -1067,6 +1069,7 @@ OsiTMINLPInterface::resolveForRobustness(int numsolve)
       return; //we have found a solution and continue
     }
   }
+std::cout << "OsiTMINLPInterface::resolveForRobustness3" <<std::endl<< std::flush;
 
 
   if(warmStartMode_ < Optimum){
@@ -1084,11 +1087,15 @@ OsiTMINLPInterface::resolveForRobustness(int numsolve)
     return;
   }
   else {
+      std::cout << "OsiTMINLPInterface::resolveForRobustness4" <<std::endl<< std::flush;
+
     std::string probName;
     getStrParam(OsiProbName,probName);
     throw newUnsolvedError(app_->errorCode(), problem_,
                            probName);
   }
+  std::cout << "OsiTMINLPInterface::resolveForRobustness5" <<std::endl<< std::flush;
+
   // Do NOT get warmstart in other cases
 }
 
@@ -2608,12 +2615,14 @@ void
 OsiTMINLPInterface::solveAndCheckErrors(bool warmStarted, bool throwOnFailure,
     const char * whereFrom)
 {
+  std::cout << "OsiTMINLPInterface::solveAndCheckErrors0" <<" warmStarted="<<warmStarted<<std::endl<< std::flush;
   if (BonminAbortAll == true) return;
   totalNlpSolveTime_-=CoinCpuTime();
   if(warmStarted)
     optimizationStatus_ = app_->ReOptimizeTNLP(GetRawPtr(problem_to_optimize_));
   else
     optimizationStatus_ = app_->OptimizeTNLP(GetRawPtr(problem_to_optimize_));
+  std::cout << "OsiTMINLPInterface::solveAndCheckErrors0.1" << " optimizationStatus_="<<optimizationStatus_<<std::endl<< std::flush;
   totalNlpSolveTime_+=CoinCpuTime();
   nCallOptimizeTNLP_++;
   hasBeenOptimized_ = true;
@@ -2624,22 +2633,29 @@ OsiTMINLPInterface::solveAndCheckErrors(bool warmStarted, bool throwOnFailure,
          std::string probName;
          getStrParam(OsiProbName, probName);
          fprintf(stderr, "Problem on optimal path is infeasible!\n");
+           std::cout << "OsiTMINLPInterface::solveAndCheckErrors0.1" <<std::endl<< std::flush;
+
          throw newUnsolvedError(app_->errorCode(), problem_, probName);
       }
    }
-
   //Options should have been printed if not done already turn off Ipopt output
   if(!hasPrintedOptions) {
     hasPrintedOptions = 1;
     //app_->Options()->SetIntegerValue("print_level",0, true, true);
     app_->options()->SetStringValue("print_user_options","no", false, true);
   }
-  
+  std::cout << "OsiTMINLPInterface::solveAndCheckErrors1" <<std::endl<< std::flush;
+
   bool otherDisagree = false ;
+  
+  
+  std::cout << "OsiTMINLPInterface::solveAndCheckErrors1.1" << " isRecoverable="<<app_->isRecoverable(optimizationStatus_)<<std::endl<< std::flush;
     if(!app_->isRecoverable(optimizationStatus_))//Solver failed and the error can not be recovered, throw it
     {
       std::string probName;
       getStrParam(OsiProbName, probName);
+        std::cout << "OsiTMINLPInterface::solveAndCheckErrors1.1" <<std::endl<< std::flush;
+
       throw newUnsolvedError(app_->errorCode(), problem_, probName);
     }
     else if(testOthers_ && !app_->isError(optimizationStatus_)){
@@ -2680,6 +2696,8 @@ OsiTMINLPInterface::solveAndCheckErrors(bool warmStarted, bool throwOnFailure,
           <<(*i)->IterationCount()<<(*i)->CPUTime()<<"retry with "+(*i)->solverName()<<CoinMessageEol;
       }
   }
+  std::cout << "OsiTMINLPInterface::solveAndCheckErrors2" <<std::endl<< std::flush;
+
   try{
     totalIterations_ += app_->IterationCount();
   }
@@ -2687,12 +2705,16 @@ OsiTMINLPInterface::solveAndCheckErrors(bool warmStarted, bool throwOnFailure,
   {
     if (throwOnFailure)//something failed throw
     {
+          std::cout << "OsiTMINLPInterface::solveAndCheckErrors2.1" <<std::endl<< std::flush;
+
       throw SimpleError("No statistics available from Ipopt",whereFrom);
     }
     else {
       return;
     }
   }
+    std::cout << "OsiTMINLPInterface::solveAndCheckErrors3" <<std::endl<< std::flush;
+
   if(problem_->hasUpperBoundingObjective()){//Check if solution is integer and recompute objective value using alternative objective function
     const double * sol = getColSolution();
     bool integerSol = true;
@@ -2743,6 +2765,7 @@ OsiTMINLPInterface::solveAndCheckErrors(bool warmStarted, bool throwOnFailure,
       }
     }
   }
+    std::cout << "OsiTMINLPInterface::solveAndCheckErrors4" <<std::endl<< std::flush;
 
   messageHandler()->message(IPOPT_SUMMARY, messages_)
     <<whereFrom<<optimizationStatus_<<app_->IterationCount()<<app_->CPUTime()<<CoinMessageEol;
@@ -2762,7 +2785,7 @@ OsiTMINLPInterface::solveAndCheckErrors(bool warmStarted, bool throwOnFailure,
     subProbName+=os.str();
     problem_->outputDiffs(subProbName, NULL/*getVarNames()*/);
   }
-  
+  std::cout << "OsiTMINLPInterface::solveAndCheckErrors5" <<std::endl<< std::flush;
 }
 
 ////////////////////////////////////////////////////////////////////
@@ -2778,31 +2801,35 @@ void OsiTMINLPInterface::initialSolve()
 ////////////////////////////////////////////////////////////////////
 void OsiTMINLPInterface::initialSolve(const char * whereFrom)
 {
+  std::cout << "OsiTMINLPInterface::initialSolve0" <<std::endl<< std::flush;
   assert(IsValid(app_));
   assert(IsValid(problem_));
+  std::cout << "OsiTMINLPInterface::initialSolve1" <<std::endl<< std::flush;
 
   if (BonminAbortAll == true) return;
   // Discard warmstart_ if we had one
   delete warmstart_;
   warmstart_ = NULL;
-  
+  std::cout << "OsiTMINLPInterface::initialSolve2" <<std::endl<< std::flush;
   if(!hasPrintedOptions) {
     int printOptions;
     app_->options()->GetEnumValue("print_user_options",printOptions,app_->prefix());
     if(printOptions)
       app_->options()->SetStringValue("print_user_options","yes",true,true);
   }
+  std::cout << "OsiTMINLPInterface::initialSolve3" <<std::endl<< std::flush;
   if(warmStartMode_ >= Optimum)
-    app_->disableWarmStart(); 
+    app_->disableWarmStart();
+  std::cout << "OsiTMINLPInterface::initialSolve4" <<std::endl<< std::flush;
   solveAndCheckErrors(0,1,"initialSolve");
-  
+  std::cout << "OsiTMINLPInterface::initialSolve5" <<std::endl<< std::flush;
   //Options should have been printed if not done already turn off Ipopt output
   if(!hasPrintedOptions) {
     hasPrintedOptions = 1;
     app_->options()->SetStringValue("print_user_options","no");
     app_->options()->SetIntegerValue("print_level",0);
   }
-  
+  std::cout << "OsiTMINLPInterface::initialSolve6" <<std::endl<< std::flush;
   messageHandler()->message(LOG_LINE, messages_)<<' '<<nCallOptimizeTNLP_
 						      <<statusAsString()
                                                       <<getObjValue()
@@ -2813,7 +2840,9 @@ void OsiTMINLPInterface::initialSolve(const char * whereFrom)
   if(BonminAbortAll){
     return;
   }
+  
   int numRetry = firstSolve_ ? numRetryInitial_ : numRetryResolve_;
+  std::cout << "OsiTMINLPInterface::initialSolve7" <<std::endl<< std::flush;
   if(isAbandoned() ||
     ( isProvenPrimalInfeasible() && getObjValue() < infeasibility_epsilon_)) {
     resolveForRobustness(numRetryUnsolved_);
@@ -2825,7 +2854,7 @@ void OsiTMINLPInterface::initialSolve(const char * whereFrom)
       numRetryInitial_ = 0;
     }
   firstSolve_ = false;
-
+std::cout << "OsiTMINLPInterface::initialSolve8" <<std::endl<< std::flush;
   // if warmstart_ is not empty then had to use resolveFor... and that created
   // the warmstart at the end, and we have nothing to do here. Otherwise...
   if (! warmstart_ && ! isAbandoned()) {
@@ -2833,6 +2862,7 @@ void OsiTMINLPInterface::initialSolve(const char * whereFrom)
       warmstart_ = app_->getWarmStart(problem_);
     }
   }
+  std::cout << "OsiTMINLPInterface::initialSolve9" <<std::endl<< std::flush;
 }
 
 /** Resolve the continuous relaxation after problem modification. */
diff --git a/Bonmin/src/Interfaces/BonTNLPSolver.cpp b/Bonmin/src/Interfaces/BonTNLPSolver.cpp
index d070ee5..82a2d8f 100644
--- a/Bonmin/src/Interfaces/BonTNLPSolver.cpp
+++ b/Bonmin/src/Interfaces/BonTNLPSolver.cpp
@@ -251,6 +251,7 @@ TNLPSolver::UnsolvedError::writeDiffFiles(const std::string prefix) const{
       (problem may be solvable).*/
   bool 
   TNLPSolver::isRecoverable(ReturnStatus &r){
+
     return (r >=0 || (r != illDefinedProblem && r != notEnoughFreedom && r != illegalOption && r != computationError && r != timeLimit) );
   }
 
diff --git a/Bonmin/src/Interfaces/Filter/BonBqpdSolver.cpp b/Bonmin/src/Interfaces/Filter/BonBqpdSolver.cpp
index 6969595..bf0eb76 100644
--- a/Bonmin/src/Interfaces/Filter/BonBqpdSolver.cpp
+++ b/Bonmin/src/Interfaces/Filter/BonBqpdSolver.cpp
@@ -208,6 +208,7 @@ namespace Bonmin
   TNLPSolver::ReturnStatus
   BqpdSolver::OptimizeTNLP(const Ipopt::SmartPtr<Ipopt::TNLP>& tnlp)
   {
+    std::cout << "BqpdSolver::OptimizeTNLP0" <<std::endl<< std::flush;
     BranchingTQP* tqp = dynamic_cast<BranchingTQP*>(GetRawPtr(tnlp));
     if (!tqp) {
       Ipopt::IpoptException E("BqpdSolver called with object other than a BranchingTQP",
diff --git a/Bonmin/src/Interfaces/Filter/BonFilterSolver.cpp b/Bonmin/src/Interfaces/Filter/BonFilterSolver.cpp
index 85812e1..7368ec8 100644
--- a/Bonmin/src/Interfaces/Filter/BonFilterSolver.cpp
+++ b/Bonmin/src/Interfaces/Filter/BonFilterSolver.cpp
@@ -363,6 +363,7 @@ namespace Bonmin
   TNLPSolver::ReturnStatus
   FilterSolver::OptimizeTNLP(const Ipopt::SmartPtr<Ipopt::TNLP> & tnlp)
   {
+    std::cout << "FilterSolver::OptimizeTNLP0" <<std::endl<< std::flush;
     if (cached_.IsNull() || !cached_->use_warm_start_in_cache_) {
       cached_ = new cachedInfo(tnlp, options_);
     }
diff --git a/Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.cpp b/Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.cpp
index 22d2d6b..6717be2 100644
--- a/Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.cpp
+++ b/Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.cpp
@@ -8,6 +8,7 @@
 // Date : 26/09/2006
 
 
+#include <iostream>
 #include "BonIpoptSolver.hpp"
 #include "IpSolveStatistics.hpp"
 #include "CoinError.hpp"
@@ -134,6 +135,7 @@ namespace Bonmin
   TNLPSolver::ReturnStatus
   IpoptSolver::OptimizeTNLP(const Ipopt::SmartPtr<Ipopt::TNLP> &tnlp)
   {
+    std::cout << "IpoptSolver::OptimizeTNLP0" <<std::endl<< std::flush;
 #if 0
     printf("Global Time limit set to %g\n", time_limit_);
     double local_time_limit = time_limit_ - 
@@ -146,6 +148,7 @@ namespace Bonmin
 #endif
     TNLPSolver::ReturnStatus ret_status;
     if (!zeroDimension(tnlp, ret_status)) {
+      std::cout << "IpoptSolver::OptimizeTNLP1" <<std::endl<< std::flush;
 #if 0
       if(time_limit_ < DBL_MAX){
            options_->SetNumericValue("max_cpu_time", local_time_limit,
@@ -153,15 +156,18 @@ namespace Bonmin
       }
 #endif
       if (enable_warm_start_ && optimized_before_) {
+        std::cout << "IpoptSolver::OptimizeTNLP2" <<std::endl<< std::flush;
         optimizationStatus_ = app_->ReOptimizeTNLP(tnlp);
       }
       else {
+        std::cout << "IpoptSolver::OptimizeTNLP3" <<std::endl<< std::flush;
         optimizationStatus_ = app_->OptimizeTNLP(tnlp);
       }
       optimized_before_ = true;
       problemHadZeroDimension_ = false;
     }
     else {
+      std::cout << "IpoptSolver::OptimizeTNLP4" <<std::endl<< std::flush;
       problemHadZeroDimension_ = true;
       if (ret_status == solvedOptimal)
         optimizationStatus_ = Ipopt::Solve_Succeeded;
@@ -307,7 +313,10 @@ namespace Bonmin
     case Ipopt::Error_In_Step_Computation:
     case Ipopt::Unrecoverable_Exception:
     case Ipopt::Insufficient_Memory:
+    {
+      std::cout << "IpoptSolver::solverReturnStatus Ipopt::Insufficient_Memory" << std::endl << std::flush;
       return computationError;
+    }
     case Ipopt::Not_Enough_Degrees_Of_Freedom:
       return notEnoughFreedom;
     case Ipopt::Invalid_Problem_Definition:
