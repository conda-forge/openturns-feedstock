diff --git a/Bonmin/examples/CppExample/MyBonmin.cpp b/Bonmin/examples/CppExample/MyBonmin.cpp
index 558bac5..bfbd1c3 100644
--- a/Bonmin/examples/CppExample/MyBonmin.cpp
+++ b/Bonmin/examples/CppExample/MyBonmin.cpp
@@ -53,21 +53,26 @@ int main (int argc, char *argv[])
   
   // Here we can change the default value of some Bonmin or Ipopt option
   bonmin.options()->SetNumericValue("bonmin.time_limit", 5); //changes bonmin's time limit
-  bonmin.options()->SetStringValue("mu_oracle","loqo");
+  // bonmin.options()->SetStringValue("mu_oracle","loqo");
   
   //Here we read several option files
-  bonmin.readOptionsFile("Mybonmin.opt");
-  bonmin.readOptionsFile();// This reads the default file "bonmin.opt"
+  // bonmin.readOptionsFile("Mybonmin.opt");
+  // bonmin.readOptionsFile();// This reads the default file "bonmin.opt"
   
   // Options can also be set by using a string with a format similar to the bonmin.opt file
   bonmin.readOptionsString("bonmin.algorithm B-BB\n");
   
   // Now we can obtain the value of the new option
-  int printSolution;
-  bonmin.options()->GetEnumValue("print_solution", printSolution,"");
-  if(printSolution == 1){
+  // int printSolution;
+  // bonmin.options()->GetEnumValue("print_solution", printSolution,"");
+  // if(printSolution == 1){
     tminlp->printSolutionAtEndOfAlgorithm();
-  }
+  // }
+
+  // extra options
+  bonmin.options()->SetStringValue("honor_original_bounds", "yes");
+  bonmin.options()->SetNumericValue("constr_viol_tol", 1e-5);
+  bonmin.options()->SetNumericValue("bound_relax_factor", 0.0);
 
   //Now initialize from tminlp
   bonmin.initialize(GetRawPtr(tminlp));
@@ -96,6 +101,9 @@ int main (int argc, char *argv[])
 	     <<E.message()<<std::endl;
   }
 
+  std::string optionsLog;
+  bonmin.options()->PrintList(optionsLog);
+  std::cout << optionsLog << std::endl;
 
   return 0;
 }
diff --git a/Bonmin/examples/CppExample/MyTMINLP.cpp b/Bonmin/examples/CppExample/MyTMINLP.cpp
index cf14b65..42ae795 100644
--- a/Bonmin/examples/CppExample/MyTMINLP.cpp
+++ b/Bonmin/examples/CppExample/MyTMINLP.cpp
@@ -23,10 +23,10 @@ MyTMINLP::get_variables_types(Index n, VariableType* var_types)
 bool 
 MyTMINLP::get_variables_linearity(Index n, Ipopt::TNLP::LinearityType* var_types)
 {
-  var_types[0] = Ipopt::TNLP::LINEAR;
+  var_types[0] = Ipopt::TNLP::NON_LINEAR;
   var_types[1] = Ipopt::TNLP::NON_LINEAR;
   var_types[2] = Ipopt::TNLP::NON_LINEAR;
-  var_types[3] = Ipopt::TNLP::LINEAR;
+  var_types[3] = Ipopt::TNLP::NON_LINEAR;
   return true;
 }
 
@@ -36,8 +36,8 @@ MyTMINLP::get_constraints_linearity(Index m, Ipopt::TNLP::LinearityType* const_t
 {
   assert (m==3);
   const_types[0] = Ipopt::TNLP::NON_LINEAR;
-  const_types[1] = Ipopt::TNLP::LINEAR;
-  const_types[2] = Ipopt::TNLP::LINEAR;
+  const_types[1] = Ipopt::TNLP::NON_LINEAR;
+  const_types[2] = Ipopt::TNLP::NON_LINEAR;
   return true;
 }
 bool 
@@ -104,6 +104,8 @@ MyTMINLP::eval_f(Index n, const Number* x, bool new_x, Number& obj_value)
 {
   assert(n==4);
   obj_value = - x[0] - x[1] - x[2];
+    std::cout <<"MyTMINLP::eval_f x=" <<x[0] <<"; "<< x[1]  <<"; "<< x[2]<<"; "<<x[3]<<" y=" << obj_value<< std::endl<< std::flush;
+
   return true;
 }
 
diff --git a/Bonmin/src/Algorithms/BonSubMipSolver.cpp b/Bonmin/src/Algorithms/BonSubMipSolver.cpp
index 01843e8..a8c55df 100644
--- a/Bonmin/src/Algorithms/BonSubMipSolver.cpp
+++ b/Bonmin/src/Algorithms/BonSubMipSolver.cpp
@@ -208,7 +208,7 @@ namespace Bonmin {
       cbc.setMaximumSolutions(1);
       cbc.setCutoff(cutoff);
 
-      
+      std::cout << "SubMipSolver::find_good_sol cbc.branchAndBound" << std::endl << std::flush;
       cbc.branchAndBound();
       lowBound_ = cbc.getBestPossibleObjValue();
 
@@ -319,6 +319,7 @@ namespace Bonmin {
   void
   SubMipSolver::optimize(double cutoff, int loglevel, double maxTime)
   {
+    std::cout << "SubMipSolver::optimize0" << std::endl << std::flush;
     if (clp_) {
       assert(strategy_);
       CbcStrategyDefault * strat_default = dynamic_cast<CbcStrategyDefault *>(strategy_->clone());
@@ -343,6 +344,7 @@ namespace Bonmin {
       cbc.setDblParam( CbcModel::CbcAllowableFractionGap, gap_tol_);
 
       //cbc.solver()->writeMpsNative("FP.mps", NULL, NULL, 1);
+      std::cout << "SubMipSolver::optimize cbc.branchAndBound cbc=" << (&cbc) << std::endl << std::flush;
       cbc.branchAndBound();
       lowBound_ = cbc.getBestPossibleObjValue();
 
diff --git a/Bonmin/src/CbcBonmin/BonCbc.cpp b/Bonmin/src/CbcBonmin/BonCbc.cpp
index 5c10cbd..6cb0b5d 100644
--- a/Bonmin/src/CbcBonmin/BonCbc.cpp
+++ b/Bonmin/src/CbcBonmin/BonCbc.cpp
@@ -84,6 +84,7 @@ namespace Bonmin
   /** Destructor.*/
   Bab::~Bab()
   {
+    std::cout << "Bab:::~Bab model_=" << (&model_) << std::endl << std::flush;
     if (bestSolution_) delete [] bestSolution_;
     bestSolution_ = NULL;
     for ( int i = 0 ; i < nObjects_ ; i++) {
@@ -104,7 +105,7 @@ namespace Bonmin
   void
   Bab::branchAndBound(BabSetupBase & s)
   {
-
+    std::cout << "Bab::branchAndBound0 model_=" << (&model_) << std::endl << std::flush;
     double remaining_time = s.getDoubleParameter(BabSetupBase::MaxTime) + CoinCpuTime();
     /* Put a link to this into solver.*/
     OsiBabSolver *  babInfo = dynamic_cast<OsiBabSolver *>(s.continuousSolver()->getAuxiliaryInfo());
@@ -521,6 +522,7 @@ namespace Bonmin
     //model_.branchAndBound(3);
     remaining_time -= CoinCpuTime();
     model_.setDblParam(CbcModel::CbcMaximumSeconds, remaining_time);
+    std::cout << "Bab::branchAndBound model_.branchAndBound remaining_time=" << remaining_time << " model_=" << (&model_) << std::endl << std::flush;
     if(remaining_time > 0.)
       model_.branchAndBound();
     }
