From 428f47cf40133730a7c583c818bf851ef4992d63 Mon Sep 17 00:00:00 2001
From: Julien Schueller <schueller@phimeca.com>
Date: Tue, 16 Jul 2019 08:52:56 +0200
Subject: [PATCH] Fix ANCOVA for sparse decomposition

---
 .../Algorithm/Sensitivity/ANCOVA.cxx          |  17 +-
 python/test/t_ANCOVA_std.expout               |  12 +-
 python/test/t_ANCOVA_std.py                   | 182 +++++++++++-------
 3 files changed, 124 insertions(+), 87 deletions(-)

diff --git a/lib/src/Uncertainty/Algorithm/Sensitivity/ANCOVA.cxx b/lib/src/Uncertainty/Algorithm/Sensitivity/ANCOVA.cxx
index dc8dc1b5a..da76992b8 100644
--- a/lib/src/Uncertainty/Algorithm/Sensitivity/ANCOVA.cxx
+++ b/lib/src/Uncertainty/Algorithm/Sensitivity/ANCOVA.cxx
@@ -56,20 +56,17 @@ void ANCOVA::run() const
 
   for (UnsignedInteger input_i = 0; input_i < inputDimension; ++input_i)
   {
-    Indices coefList(coefSize);
-    UnsignedInteger counter = 0;
     // Search univariate polynomials
-    for (UnsignedInteger m = 0; m < coefSize - 1; ++m)
+    Indices coefList;
+    for (UnsignedInteger k = 0; k < coefSize; ++ k)
     {
       const Indices nullIndices(inputDimension);
-      Indices multiIndices(enumerateFunction(coefficientIndices[m + 1]));
-
+      Indices multiIndices(enumerateFunction(coefficientIndices[k]));
+      if (!multiIndices[input_i])
+        continue;
       multiIndices[input_i] = 0;
       if (multiIndices == nullIndices)
-      {
-        coefList[counter] = m + 1;
-        ++counter;
-      }
+        coefList.add(k);
     }
     for (UnsignedInteger marginal_k = 0; marginal_k < nbMarginals; ++marginal_k)
     {
@@ -83,7 +80,7 @@ void ANCOVA::run() const
       for (UnsignedInteger j = 0; j < inputSize; ++j)
       {
         Scalar temp = 0.;
-        for (UnsignedInteger k = 0; k < counter + 1; ++k)
+        for (UnsignedInteger k = 0; k < coefList.getSize(); ++k)
           temp += coefficients(coefList[k], 0) * B[coefList[k]](T(correlatedInput_[j]))[0];
 
         inputOutput(j, 0) = temp;
diff --git a/python/test/t_ANCOVA_std.expout b/python/test/t_ANCOVA_std.expout
index 43c1f6677..797371b28 100644
--- a/python/test/t_ANCOVA_std.expout
+++ b/python/test/t_ANCOVA_std.expout
@@ -1,4 +1,8 @@
-ANCOVA index 0 = 0.41107658 absolute error=0.0040177641
-ANCOVA uncorrelated index 0 = 0.29867971 absolute error=0.0032070869
-ANCOVA index 1 = 0.58892342 absolute error=0.0040177641
-ANCOVA uncorrelated index 1 = 0.47652655 absolute error=0.0048284413
+ANCOVA index 0 = 0.411077 absolute error=0.00401776
+ANCOVA uncorrelated index 0 = 0.29867971 absolute error=0.00320709
+ANCOVA index 1 = 0.588923 absolute error=0.00401776
+ANCOVA uncorrelated index 1 = 0.47652655 absolute error=0.00482844
+indices/full= [0,1,2,3]
+indices/sparse= [1,2,3]
+Indice ancova, chaos normal : 0.495 0.105 0.400
+Indice ancova, chaos sparse : 0.495 0.105 0.400
diff --git a/python/test/t_ANCOVA_std.py b/python/test/t_ANCOVA_std.py
index ae291e6b7..8e67ed335 100755
--- a/python/test/t_ANCOVA_std.py
+++ b/python/test/t_ANCOVA_std.py
@@ -1,78 +1,114 @@
 #! /usr/bin/env python
 
 from __future__ import print_function
-from openturns import *
+import openturns as ot
 from math import *
 
-TESTPREAMBLE()
-
-try:
-
-    RandomGenerator.SetSeed(0)
-
-    # Problem parameters
-    inputDimension = 2
-    outputDimension = 1
-    rho = 0.3
-    a = 4.
-    b = 5.
-
-    # Reference analytical values
-    covTh = a * a + b * b + 2 * a * b * rho
-    Si = [[(a * a + a * b * rho) / covTh, a * a / covTh],
-          [(b * b + a * b * rho) / covTh, b * b / covTh]]
-
-    # Model
-    inputName = ["X1", "X2", "a", "b"]
-    formula = ["a * X1 + b * X2"]
-
-    full = SymbolicFunction(inputName, formula)
-    model = ParametricFunction(full, [2, 3], [a, b])
-
-    # Input distribution
-    distribution = ComposedDistribution([Normal()] * inputDimension)
-
-    # Correlated input distribution
-    S = CorrelationMatrix(inputDimension)
-    S[1, 0] = 0.3
-    R = NormalCopula().GetCorrelationFromSpearmanCorrelation(S)
-    myCopula = NormalCopula(R)
-    myCorrelatedInputDistribution = ComposedDistribution(
-        [Normal()] * inputDimension, myCopula)
-
-    sample = myCorrelatedInputDistribution.getSample(2000)
-
-    # Orthogonal basis
-    enumerateFunction = EnumerateFunction(inputDimension)
-    productBasis = OrthogonalProductPolynomialFactory(
-        [HermiteFactory()] * inputDimension, enumerateFunction)
-    # Adaptive strategy
-    adaptiveStrategy = FixedStrategy(
-        productBasis, enumerateFunction.getStrataCumulatedCardinal(4))
-    # Projection strategy
-    samplingSize = 250
-    projectionStrategy = LeastSquaresStrategy(
-        MonteCarloExperiment(samplingSize))
-
-    # Polynomial chaos algorithm
-    algo = FunctionalChaosAlgorithm(
-        model, distribution, adaptiveStrategy, projectionStrategy)
-    algo.run()
-
-    # Post-process the results
-    result = FunctionalChaosResult(algo.getResult())
-    ancova = ANCOVA(result, sample)
-    indices = ancova.getIndices()
-    uncorrelatedIndices = ancova.getUncorrelatedIndices()
-
-    for i in range(inputDimension):
-        value = indices[i]
-        print("ANCOVA index", i, "= %.8f" %
-              value, "absolute error=%.10f" % fabs(value - Si[i][0]))
-        value = uncorrelatedIndices[i]
-        print("ANCOVA uncorrelated index", i, "= %.8f" %
-              value, "absolute error=%.10f" % fabs(value - Si[i][1]))
-
-except:
-    import sys
-    print("t_ANCOVA_std.py", sys.exc_info()[0], sys.exc_info()[1])
+ot.TESTPREAMBLE()
+
+
+# Problem parameters
+inputDimension = 2
+outputDimension = 1
+rho = 0.3
+a = 4.
+b = 5.
+
+# Reference analytical values
+covTh = a * a + b * b + 2 * a * b * rho
+Si = [[(a * a + a * b * rho) / covTh, a * a / covTh],
+      [(b * b + a * b * rho) / covTh, b * b / covTh]]
+
+# Model
+inputName = ["X1", "X2", "a", "b"]
+formula = ["a * X1 + b * X2"]
+
+full = ot.SymbolicFunction(inputName, formula)
+model = ot.ParametricFunction(full, [2, 3], [a, b])
+
+# Input distribution
+distribution = ot.ComposedDistribution([ot.Normal()] * inputDimension)
+
+# Correlated input distribution
+S = ot.CorrelationMatrix(inputDimension)
+S[1, 0] = 0.3
+R = ot.NormalCopula().GetCorrelationFromSpearmanCorrelation(S)
+myCopula = ot.NormalCopula(R)
+myCorrelatedInputDistribution = ot.ComposedDistribution(
+    [ot.Normal()] * inputDimension, myCopula)
+
+sample = myCorrelatedInputDistribution.getSample(2000)
+
+# Orthogonal basis
+enumerateFunction = ot.EnumerateFunction(inputDimension)
+productBasis = ot.OrthogonalProductPolynomialFactory(
+    [ot.HermiteFactory()] * inputDimension, enumerateFunction)
+# Adaptive strategy
+adaptiveStrategy = ot.FixedStrategy(
+    productBasis, enumerateFunction.getStrataCumulatedCardinal(4))
+# Projection strategy
+samplingSize = 250
+projectionStrategy = ot.LeastSquaresStrategy(
+    ot.MonteCarloExperiment(samplingSize))
+
+# Polynomial chaos algorithm
+algo = ot.FunctionalChaosAlgorithm(
+    model, distribution, adaptiveStrategy, projectionStrategy)
+algo.run()
+
+# Post-process the results
+result = ot.FunctionalChaosResult(algo.getResult())
+ancova = ot.ANCOVA(result, sample)
+indices = ancova.getIndices()
+uncorrelatedIndices = ancova.getUncorrelatedIndices()
+
+for i in range(inputDimension):
+    value = indices[i]
+    print("ANCOVA index", i, "= %.6g" %
+          value, "absolute error=%.6g" % fabs(value - Si[i][0]))
+    value = uncorrelatedIndices[i]
+    print("ANCOVA uncorrelated index", i, "= %.8f" %
+          value, "absolute error=%.6g" % fabs(value - Si[i][1]))
+
+# Compare full/sparse
+ot.RandomGenerator.SetSeed(323)
+
+model = ot.SymbolicFunction(['x1', 'x2', 'x3'], ['x1 + 0.56*x2 + 0.9*x3'])
+distribution = ot.Normal(3)
+distribution.setDescription(['x1', 'x2', 'x3'])
+
+n_sample = 10
+input_sample = distribution.getSample(n_sample)
+output_sample = model(input_sample)
+
+dim = 3
+enumerateFunction = ot.EnumerateFunction(dim)
+polyCol = [0.]*dim
+for i in range(dim):
+    polyCol[i] = ot.StandardDistributionPolynomialFactory(distribution.getMarginal(i))
+
+####### Chaos definition ######
+multivariateBasis = ot.OrthogonalProductPolynomialFactory(polyCol, enumerateFunction)
+indexMax = enumerateFunction.getStrataCumulatedCardinal(1)
+strategy = ot.FixedStrategy(multivariateBasis, indexMax)
+
+approximation_algorithm = ot.LeastSquaresMetaModelSelectionFactory(ot.LARS(),
+                                                                  ot.CorrectedLeaveOneOut())
+evaluationStrategy_sparse = ot.LeastSquaresStrategy(approximation_algorithm)
+evaluationStrategy = ot.LeastSquaresStrategy()
+
+# sparse and not sparse
+chaos = ot.FunctionalChaosAlgorithm(input_sample, output_sample, distribution,
+                                          strategy, evaluationStrategy)
+chaos.run()
+chaos_sparse = ot.FunctionalChaosAlgorithm(input_sample, output_sample, distribution,
+                                          strategy, evaluationStrategy_sparse)
+chaos_sparse.run()
+print('indices/full=', chaos.getResult().getIndices())
+print('indices/sparse=', chaos_sparse.getResult().getIndices())
+
+ancova = ot.ANCOVA(chaos.getResult(), input_sample)
+ancova_sparse = ot.ANCOVA(chaos_sparse.getResult(), input_sample)
+print('Indice ancova, chaos normal : {:0.3f} {:0.3f} {:0.3f}'.format(*ancova.getIndices()))
+print('Indice ancova, chaos sparse : {:0.3f} {:0.3f} {:0.3f}'.format(*ancova_sparse.getIndices()))
+
-- 
2.17.1

