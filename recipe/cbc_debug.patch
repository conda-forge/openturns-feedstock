diff --git a/Cbc/src/CbcModel.cpp b/Cbc/src/CbcModel.cpp
index 235d8a72..632a9b5d 100644
--- a/Cbc/src/CbcModel.cpp
+++ b/Cbc/src/CbcModel.cpp
@@ -10,6 +10,7 @@
 
 #include "CbcConfig.h"
 
+#include <iostream>
 #include <string>
 //#define CBC_DEBUG 1
 //#define CHECK_CUT_COUNTS
@@ -1673,6 +1674,7 @@ static double lengthConflictCuts = 0.0;
 void CbcModel::branchAndBound(int doStatistics)
 
 {
+  std::cout << "CbcModel::branchAndBound0 this="<<this << std::endl<< std::flush;
   if (!parentModel_) {
     /*
 	Capture a time stamp before we start (unless set).
@@ -1757,6 +1759,8 @@ void CbcModel::branchAndBound(int doStatistics)
       preprocessed solver to model, but will instruct assignSolver not to trash the
       existing one.
     */
+  
+  std::cout << "CbcModel::branchAndBound1 this="<<this << std::endl<< std::flush;
   if (strategy_) {
     // May do preprocessing
     originalSolver = solver_;
@@ -1778,6 +1782,7 @@ void CbcModel::branchAndBound(int doStatistics)
         originalContinuousObjective_ = COIN_DBL_MAX;
         if (flipObjective)
           flipModel();
+        std::cout << "CbcModel::branchAndBound this=" << this  << " return 5" <<  std::endl<< std::flush;
         return;
       } else if (numberObjects_ && object_) {
         numberOriginalObjects = numberObjects_;
@@ -1932,6 +1937,7 @@ void CbcModel::branchAndBound(int doStatistics)
     // Set strategy print level to models
     strategy_->setupPrinting(*this, handler_->logLevel());
   }
+  std::cout << "CbcModel::branchAndBound2 this="<<this << std::endl<< std::flush;
   eventHappened_ = false;
   CbcEventHandler *eventHandler = getEventHandler();
   if (eventHandler)
@@ -1993,6 +1999,7 @@ void CbcModel::branchAndBound(int doStatistics)
     // depth first
     nodeCompare_ = new CbcCompareDepth();
   }
+  std::cout << "CbcModel::branchAndBound3 this="<<this << std::endl<< std::flush;
   if (!problemFeasibility_)
     problemFeasibility_ = new CbcFeasibilityBase();
 #ifdef CBC_DEBUG
@@ -2041,6 +2048,7 @@ void CbcModel::branchAndBound(int doStatistics)
       Ensure that objects on the lists of OsiObjects, heuristics, and cut
       generators attached to this model all refer to this model.
     */
+  std::cout << "CbcModel::branchAndBound4 this="<<this << std::endl<< std::flush;
   synchronizeModel();
   if (!solverCharacteristics_) {
     OsiBabSolver *solverCharacteristics = dynamic_cast< OsiBabSolver * >(solver_->getAuxiliaryInfo());
@@ -2127,6 +2135,8 @@ void CbcModel::branchAndBound(int doStatistics)
   numberSavedSolutions_ = 0;
   int saveNumberStrong = numberStrong_;
   int saveNumberBeforeTrust = numberBeforeTrust_;
+  
+  std::cout << "CbcModel::branchAndBound5 this="<<this << std::endl<< std::flush;
   /*
       If the linear relaxation of the root is infeasible, bail out now. Otherwise,
       continue with processing the root node.
@@ -2178,10 +2188,12 @@ void CbcModel::branchAndBound(int doStatistics)
       solver_ = continuousSolver_;
       setPointers(solver_);
       continuousSolver_ = NULL;
+      std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 1" <<  std::endl<< std::flush;
     }
     solverCharacteristics_ = NULL;
     if (flipObjective)
       flipModel();
+     std::cout << "CbcModel::branchAndBound this=" << this  << " return 6" <<  std::endl<< std::flush;
     return;
   } else if (!numberObjects_) {
     // nothing to do
@@ -2235,8 +2247,10 @@ void CbcModel::branchAndBound(int doStatistics)
     delete[] bestSolution_;
     bestSolution_ = new double[numberColumns];
     CoinCopyN(solver_->getColSolution(), numberColumns, bestSolution_);
+     std::cout << "CbcModel::branchAndBound this=" << this  << " return 7" <<  std::endl<< std::flush;
     return;
   }
+  std::cout << "CbcModel::branchAndBound6 this="<<this << std::endl<< std::flush;
   /*
       See if we're using the Osi side of the branching hierarchy. If so, either
       convert existing CbcObjects to OsiObjects, or generate them fresh. In the
@@ -2305,6 +2319,7 @@ void CbcModel::branchAndBound(int doStatistics)
     }
     branchingMethod_->chooseMethod()->setSolver(solver_);
   }
+  std::cout << "CbcModel::branchAndBound7 this="<<this << std::endl<< std::flush;
   // take off heuristics if have to (some do not work with SOS, for example)
   // object should know what's safe.
   {
@@ -2373,7 +2388,7 @@ void CbcModel::branchAndBound(int doStatistics)
   if (solver_->getRowCutDebuggerAlways())
     specialOptions_ |= 1;
 #endif
-
+std::cout << "CbcModel::branchAndBound8 this="<<this << std::endl<< std::flush;
   /*
       Begin setup to process a feasible root node.
     */
@@ -2456,7 +2471,7 @@ void CbcModel::branchAndBound(int doStatistics)
     }
   }
 #endif
-
+std::cout << "CbcModel::branchAndBound9 this="<<this << std::endl<< std::flush;
   // add cutoff as constraint if wanted
   if (cutoffRowNumber_ == -2) {
     if (!parentModel_) {
@@ -2491,6 +2506,7 @@ void CbcModel::branchAndBound(int doStatistics)
   }
   numberRowsAtContinuous_ = getNumRows();
   solver_->saveBaseModel();
+  std::cout << "CbcModel::branchAndBound10 this="<<this << std::endl<< std::flush;
   /*
       Check the objective to see if we can deduce a nontrivial increment. If
       it's better than the current value for CbcCutoffIncrement, it'll be
@@ -2560,6 +2576,7 @@ void CbcModel::branchAndBound(int doStatistics)
 #endif
   }
   tree_->setComparison(*nodeCompare_);
+  std::cout << "CbcModel::branchAndBound11 this="<<this << std::endl<< std::flush;
   /*
       Used to record the path from a node to the root of the search tree, so that
       we can then traverse from the root to the node when restoring a subproblem.
@@ -2684,6 +2701,7 @@ void CbcModel::branchAndBound(int doStatistics)
       }
     }
   }
+  std::cout << "CbcModel::branchAndBound12 this="<<this << std::endl<< std::flush;
 #ifdef SWITCH_VARIABLES
   // see if any switching variables
   if (numberIntegers_ < solver_->getNumCols())
@@ -2882,6 +2900,7 @@ void CbcModel::branchAndBound(int doStatistics)
     delete[] which;
     delete[] value;
   }
+  std::cout << "CbcModel::branchAndBound14 this="<<this << std::endl<< std::flush;
   // Do heuristics
   if (numberObjects_ && !rootModels)
     doHeuristicsAtRoot();
@@ -2944,6 +2963,8 @@ void CbcModel::branchAndBound(int doStatistics)
       convertToDynamic();
     }
   }
+  
+  std::cout << "CbcModel::branchAndBound15 this="<<this << std::endl<< std::flush;
 #ifdef COIN_HAS_NTY
 #define MAX_NAUTY_PASS 2000
   int testOptions = moreSpecialOptions2_&1073741824;
@@ -2959,6 +2980,7 @@ void CbcModel::branchAndBound(int doStatistics)
     OsiSolverInterface *solverOriginal = solver_;
     OsiSolverInterface *continuousSolver = continuousSolver_;
     continuousSolver_ = NULL;
+    std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 2" <<  std::endl<< std::flush;
     int numberOriginalRows = solverOriginal->getNumRows();
     OsiSolverInterface *solver = solverOriginal->clone();
     solver_ = solver;
@@ -3098,6 +3120,7 @@ void CbcModel::branchAndBound(int doStatistics)
       // have to switch nauty off totally!
       moreSpecialOptions2_ &= ~(128 | 256);
     }
+    std::cout << "CbcModel::branchAndBound this=" << this << " continuousSolver=" << continuousSolver << std::endl << std::flush;
     continuousSolver_ = continuousSolver;
     int numberRows = solver->getNumRows();
     if (numberRows > numberOriginalRows) {
@@ -3121,6 +3144,7 @@ void CbcModel::branchAndBound(int doStatistics)
   }
 #endif
 
+std::cout << "CbcModel::branchAndBound16 this="<<this << std::endl<< std::flush;
   /*
       Do an initial round of cut generation for the root node. Depending on the
       type of underlying solver, we may want to do this even if the initial query
@@ -3597,6 +3621,7 @@ void CbcModel::branchAndBound(int doStatistics)
         NULL);
     }
   }
+  std::cout << "CbcModel::branchAndBound17 this="<<this << std::endl<< std::flush;
   if (rootModels) {
     int numberModels = multipleRootTries_ % 100;
     for (int i = 0; i < numberModels; i++)
@@ -3765,6 +3790,7 @@ void CbcModel::branchAndBound(int doStatistics)
     feasible = false;
   }
 #endif
+std::cout << "CbcModel::branchAndBound18 this="<<this << std::endl<< std::flush;
   if (!parentModel_ && (moreSpecialOptions_ & 268435456) != 0) {
     // try idiotic idea
     CbcObject *obj = new CbcIdiotBranch(this);
@@ -3836,8 +3862,11 @@ void CbcModel::branchAndBound(int doStatistics)
     delete saveSolver;
     if (flipObjective)
       flipModel();
+     std::cout << "CbcModel::branchAndBound this=" << this  << " return 8" <<  std::endl<< std::flush;
     return;
   }
+  
+  std::cout << "CbcModel::branchAndBound19 this="<<this << std::endl<< std::flush;
   /*
       We've taken the continuous relaxation as far as we can. Time to branch.
       The first order of business is to actually create a node. chooseBranch
@@ -4239,6 +4268,8 @@ void CbcModel::branchAndBound(int doStatistics)
       feasible = false;
     }
   }
+  
+  std::cout << "CbcModel::branchAndBound20 this="<<this << std::endl<< std::flush;
   if (newNode && probingInfo_) {
     int number01 = probingInfo_->numberIntegers();
     //const fixEntry * entry = probingInfo_->fixEntries();
@@ -4345,6 +4376,7 @@ void CbcModel::branchAndBound(int doStatistics)
       probingInfo_ = NULL;
     }
   }
+  std::cout << "CbcModel::branchAndBound21 this="<<this << std::endl<< std::flush;
   /*
       At this point, the root subproblem is infeasible or fathomed by bound
       (newNode == NULL), or we're live with an objective value that satisfies the
@@ -4449,6 +4481,7 @@ void CbcModel::branchAndBound(int doStatistics)
     }
   }
 
+  std::cout << "CbcModel::branchAndBound22 this="<<this << std::endl<< std::flush;
   if (printFrequency_ <= 0) {
     printFrequency_ = 1000;
     if (getNumCols() > 2000)
@@ -4479,6 +4512,7 @@ void CbcModel::branchAndBound(int doStatistics)
     }
   }
 #endif
+std::cout << "CbcModel::branchAndBound23 this="<<this << std::endl<< std::flush;
   /*
       At last, the actual branch-and-cut search loop, which will iterate until
       the live set is empty or we hit some limit (integrality gap, time, node
@@ -4510,6 +4544,7 @@ void CbcModel::branchAndBound(int doStatistics)
       //abort();
     }
   }
+  std::cout << "CbcModel::branchAndBound23.1 this="<<this << std::endl<< std::flush;
   {
     // may be able to change cutoff now
     double cutoff = getCutoff();
@@ -4519,6 +4554,7 @@ void CbcModel::branchAndBound(int doStatistics)
       setCutoff(cutoff);
     }
   }
+  std::cout << "CbcModel::branchAndBound23.2 this="<<this << std::endl<< std::flush;
 #ifdef CBC_THREAD
   bool goneParallel = false;
 #endif
@@ -4535,7 +4571,9 @@ void CbcModel::branchAndBound(int doStatistics)
   if ((moreSpecialOptions_ & 262144) != 0)
     specialOptions_ |= 131072;
 #endif
-  while (true) {
+  while (true)
+  {
+    std::cout << "CbcModel::branchAndBound23.3 this="<<this << std::endl<< std::flush;
     lockThread();
 #ifdef COIN_HAS_CLP
     // See if we want dantzig row choice
@@ -4660,6 +4698,7 @@ void CbcModel::branchAndBound(int doStatistics)
     break;
 #endif
     } else {
+      std::cout << "CbcModel::branchAndBound23.5 this="<<this << std::endl<< std::flush;
       unlockThread();
     }
     // If done 50/100 nodes see if worth trying reduction
@@ -4764,6 +4803,7 @@ void CbcModel::branchAndBound(int doStatistics)
               delete temp;
               saveSolver->writeMps("reduced");
             } else {
+              std::cout << "CbcModel::branchAndBound23.6 abort this="<<this << std::endl<< std::flush;
               abort();
             }
           }
@@ -4830,6 +4870,7 @@ void CbcModel::branchAndBound(int doStatistics)
             delete[] newSolution;
 #ifdef CBC_THREAD
             if (master_) {
+              std::cout << "CbcModel::branchAndBound23.6 lockThread this="<<this << std::endl<< std::flush;
               lockThread();
               if (parallelMode() > 0) {
                 while (master_->waitForThreadsInTree(0)) {
@@ -4842,6 +4883,7 @@ void CbcModel::branchAndBound(int doStatistics)
                 double dummyBest;
                 tree_->cleanTree(this, -COIN_DBL_MAX, dummyBest);
               }
+              std::cout << "CbcModel::branchAndBound23.6 waitForThreadsInTree this="<<this << std::endl<< std::flush;
               master_->waitForThreadsInTree(2);
               delete master_;
               master_ = NULL;
@@ -4859,6 +4901,7 @@ void CbcModel::branchAndBound(int doStatistics)
         saveSolver = NULL;
       }
     }
+    std::cout << "CbcModel::branchAndBound23.7 this="<<this << std::endl<< std::flush;
     /*
           Check for abort on limits: node count, solution count, time, integrality gap.
         */
@@ -4953,6 +4996,7 @@ void CbcModel::branchAndBound(int doStatistics)
       if (tree_->empty()) {
         continue;
       }
+       std::cout << "CbcModel::branchAndBound23.8 unlockThread this="<<this << std::endl<< std::flush;
       unlockThread();
     }
     cutoff = getCutoff();
@@ -4976,6 +5020,7 @@ void CbcModel::branchAndBound(int doStatistics)
       // redo tree if requested
       if (redoTree)
         tree_->setComparison(*nodeCompare_);
+      std::cout << "CbcModel::branchAndBound23.9 unlockThread this="<<this << std::endl<< std::flush;
       unlockThread();
     }
     // Had hotstart before, now switched off
@@ -4989,6 +5034,7 @@ void CbcModel::branchAndBound(int doStatistics)
       tree_->setComparison(*nodeCompare_);
       unlockThread();
     }
+    std::cout << "CbcModel::branchAndBound23.10 this="<<this << std::endl<< std::flush;
     if (numberNodes_ >= lastPrintEvery) {
       lastPrintEvery = numberNodes_ + printFrequency_;
       lockThread();
@@ -5084,10 +5130,12 @@ void CbcModel::branchAndBound(int doStatistics)
           represents, and then execute the current arm of the branch to create the
           active subproblem.
         */
+    std::cout << "CbcModel::branchAndBound23.11 this="<<this << std::endl<< std::flush;
     CbcNode *node = NULL;
 #ifdef CBC_THREAD
     if (!parallelMode() || parallelMode() == -1) {
 #endif
+      std::cout << "CbcModel::branchAndBound23.12 this="<<this << std::endl<< std::flush;
       node = tree_->bestNode(cutoff);
       // Possible one on tree worse than cutoff
       // Weird comparison function can leave ineligible nodes on tree
@@ -5119,6 +5167,7 @@ void CbcModel::branchAndBound(int doStatistics)
       //numberConsecutiveInfeasible++;
 #ifdef CBC_THREAD
     } else if (parallelMode() > 0) {
+      std::cout << "CbcModel::branchAndBound23.13 this="<<this << std::endl<< std::flush;
       //lockThread();
       //node = tree_->bestNode(cutoff) ;
       // Possible one on tree worse than cutoff
@@ -5136,6 +5185,7 @@ void CbcModel::branchAndBound(int doStatistics)
       }
       //unlockThread();
     } else {
+      std::cout << "CbcModel::branchAndBound23.14 this="<<this << std::endl<< std::flush;
       // Deterministic parallel
       if ((tree_->size() < CoinMax(numberThreads_, 8) || hotstartSolution_) && !goneParallel) {
         node = tree_->bestNode(cutoff);
@@ -5186,6 +5236,8 @@ void CbcModel::branchAndBound(int doStatistics)
     }
 #endif
   }
+  std::cout << "CbcModel::branchAndBound24 this="<<this << std::endl<< std::flush;
+  
   if (nDeleteNode) {
     for (int i = 0; i < nDeleteNode; i++) {
       delete delNode[i];
@@ -5261,6 +5313,7 @@ void CbcModel::branchAndBound(int doStatistics)
       status_ = 5;
     }
   }
+  std::cout << "CbcModel::branchAndBound25 this="<<this << std::endl<< std::flush;
 #ifdef CBC_THREAD
   if (master_) {
 #ifdef COIN_HAS_NTY
@@ -5358,6 +5411,7 @@ void CbcModel::branchAndBound(int doStatistics)
         obj->print();
     }
   }
+  std::cout << "CbcModel::branchAndBound26 this="<<this << std::endl<< std::flush;
   if (statistics_) {
     // report in some way
     int *lookup = new int[numberObjects_];
@@ -5521,6 +5575,7 @@ void CbcModel::branchAndBound(int doStatistics)
     maximumStatistics_ = 0;
     delete[] lookup;
   }
+  std::cout << "CbcModel::branchAndBound27 this="<<this << std::endl<< std::flush;
   /*
       If we think we have a solution, restore and confirm it with a call to
       setBestSolution().  We need to reset the cutoff value so as not to fathom
@@ -5571,7 +5626,9 @@ void CbcModel::branchAndBound(int doStatistics)
     solver_ = continuousSolver_;
     setPointers(solver_);
     continuousSolver_ = NULL;
+    std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 2" <<  std::endl<< std::flush;
   }
+  std::cout << "CbcModel::branchAndBound28 this="<<this << std::endl<< std::flush;
   /*
       Clean up dangling objects. continuousSolver_ may already be toast.
     */
@@ -5600,9 +5657,12 @@ void CbcModel::branchAndBound(int doStatistics)
   //delete persistentInfo;
   // Get rid of characteristics
   solverCharacteristics_ = NULL;
+
+  std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 4 ? " << (continuousSolver_ != NULL) << std::endl<< std::flush;
   if (continuousSolver_) {
     delete continuousSolver_;
     continuousSolver_ = NULL;
+    std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 4" <<  std::endl<< std::flush;
   }
   /*
       Destroy global cuts by replacing with an empty OsiCuts object.
@@ -5698,6 +5758,7 @@ void CbcModel::branchAndBound(int doStatistics)
   }
 #endif
   moreSpecialOptions_ = saveMoreSpecialOptions;
+   std::cout << "CbcModel::branchAndBound this=" << this << " return 9" <<  std::endl<< std::flush;
   return;
 }
 
@@ -6456,10 +6517,12 @@ CbcModel::CbcModel(const CbcModel &rhs, bool cloneHandler)
     numberObjects_ = 0;
     object_ = NULL;
   }
+  // std::cout << "CbcModel this=" << this << " rhs.continuousSolver_ ?" << (rhs.continuousSolver_!=NULL) <<  std::endl<< std::flush;
   if (rhs.continuousSolver_) {
     continuousSolver_ = rhs.continuousSolver_->clone();
   } else {
     continuousSolver_ = NULL;
+    std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 5" <<  std::endl<< std::flush;
   }
   if (rhs.referenceSolver_)
     referenceSolver_ = rhs.referenceSolver_->clone();
@@ -6639,6 +6702,7 @@ CbcModel::operator=(const CbcModel &rhs)
     if (rhs.continuousSolver_) {
       continuousSolver_ = rhs.continuousSolver_->clone();
     } else {
+      std::cout << "CbcModel::operator= this=" << this  << " continuousSolver_.NULL x" <<  std::endl<< std::flush;
       continuousSolver_ = 0;
     }
     delete referenceSolver_;
@@ -6969,6 +7033,7 @@ CbcModel::~CbcModel()
   }
   delete tree_;
   tree_ = NULL;
+  std::cout << "CbcModel::~CbcModel.2 this="<<this<<" solver_="<<solver_<<" continuousSolver_=" << continuousSolver_ <<  std::endl<< std::flush;
   if (modelOwnsSolver()) {
     delete solver_;
     solver_ = NULL;
@@ -7049,8 +7114,10 @@ void CbcModel::resetModel()
 {
   delete emptyWarmStart_;
   emptyWarmStart_ = NULL;
+  std::cout << "CbcModel::resetModel this="<<this<<" continuousSolver_=" << continuousSolver_ << std::endl<< std::flush;
   delete continuousSolver_;
   continuousSolver_ = NULL;
+  std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 6" <<  std::endl<< std::flush;
   numberSavedSolutions_ = 0;
   delete[] bestSolution_;
   bestSolution_ = NULL;
@@ -18200,6 +18267,7 @@ bool CbcModel::integerPresolveThisModel(OsiSolverInterface *originalSolver,
   solverCharacteristics_->setSolver(solver_);
   // just point to solver_
   delete continuousSolver_;
+  std::cout << "CbcModel::integerPresolveThisModel this=" << this << " solver_=" << solver_ << std::endl<< std::flush;
   continuousSolver_ = solver_;
   // get a copy of original so we can fix bounds
   OsiSolverInterface *cleanModel = originalSolver->clone();
@@ -18361,6 +18429,7 @@ bool CbcModel::integerPresolveThisModel(OsiSolverInterface *originalSolver,
         }
         synchronizeModel(); // make sure everything that needs solver has it
         // just point to solver_
+        std::cout << "CbcModel::integerPresolveThisModel this=" << this << " solver_=" << solver_ << std::endl << std::flush;
         continuousSolver_ = solver_;
         feasible = (resolve(NULL, 3) != 0);
         if (!feasible || !doIntegerPresolve || weak)
@@ -18484,6 +18553,7 @@ bool CbcModel::integerPresolveThisModel(OsiSolverInterface *originalSolver,
   deleteObjects();
   synchronizeModel(); // make sure everything that needs solver has it
   continuousSolver_ = NULL;
+  std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 7" <<  std::endl<< std::flush;
   currentNumberCuts_ = 0;
   return feasible;
 }
@@ -19045,6 +19115,7 @@ CbcModel::strengthenedModel()
   if (continuousSolver_) {
     delete continuousSolver_;
     continuousSolver_ = NULL;
+    std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 8" <<  std::endl<< std::flush;
   }
   /*
       Destroy global cuts by replacing with an empty OsiCuts object.
