diff --git a/Cbc/src/CbcModel.cpp b/Cbc/src/CbcModel.cpp
index 235d8a72..d176874a 100644
--- a/Cbc/src/CbcModel.cpp
+++ b/Cbc/src/CbcModel.cpp
@@ -10,6 +10,7 @@
 
 #include "CbcConfig.h"
 
+#include <iostream>
 #include <string>
 //#define CBC_DEBUG 1
 //#define CHECK_CUT_COUNTS
@@ -1673,6 +1674,7 @@ static double lengthConflictCuts = 0.0;
 void CbcModel::branchAndBound(int doStatistics)
 
 {
+  std::cout << "CbcModel::branchAndBound0 this="<<this << std::endl<< std::flush;
   if (!parentModel_) {
     /*
 	Capture a time stamp before we start (unless set).
@@ -1757,6 +1759,8 @@ void CbcModel::branchAndBound(int doStatistics)
       preprocessed solver to model, but will instruct assignSolver not to trash the
       existing one.
     */
+  
+  std::cout << "CbcModel::branchAndBound1 this="<<this << std::endl<< std::flush;
   if (strategy_) {
     // May do preprocessing
     originalSolver = solver_;
@@ -1778,6 +1782,7 @@ void CbcModel::branchAndBound(int doStatistics)
         originalContinuousObjective_ = COIN_DBL_MAX;
         if (flipObjective)
           flipModel();
+        std::cout << "CbcModel::branchAndBound this=" << this  << " return 5" <<  std::endl<< std::flush;
         return;
       } else if (numberObjects_ && object_) {
         numberOriginalObjects = numberObjects_;
@@ -1932,6 +1937,7 @@ void CbcModel::branchAndBound(int doStatistics)
     // Set strategy print level to models
     strategy_->setupPrinting(*this, handler_->logLevel());
   }
+  std::cout << "CbcModel::branchAndBound2 this="<<this << std::endl<< std::flush;
   eventHappened_ = false;
   CbcEventHandler *eventHandler = getEventHandler();
   if (eventHandler)
@@ -1993,6 +1999,7 @@ void CbcModel::branchAndBound(int doStatistics)
     // depth first
     nodeCompare_ = new CbcCompareDepth();
   }
+  std::cout << "CbcModel::branchAndBound3 this="<<this << std::endl<< std::flush;
   if (!problemFeasibility_)
     problemFeasibility_ = new CbcFeasibilityBase();
 #ifdef CBC_DEBUG
@@ -2041,6 +2048,7 @@ void CbcModel::branchAndBound(int doStatistics)
       Ensure that objects on the lists of OsiObjects, heuristics, and cut
       generators attached to this model all refer to this model.
     */
+  std::cout << "CbcModel::branchAndBound4 this="<<this << std::endl<< std::flush;
   synchronizeModel();
   if (!solverCharacteristics_) {
     OsiBabSolver *solverCharacteristics = dynamic_cast< OsiBabSolver * >(solver_->getAuxiliaryInfo());
@@ -2127,6 +2135,8 @@ void CbcModel::branchAndBound(int doStatistics)
   numberSavedSolutions_ = 0;
   int saveNumberStrong = numberStrong_;
   int saveNumberBeforeTrust = numberBeforeTrust_;
+  
+  std::cout << "CbcModel::branchAndBound5 this="<<this << std::endl<< std::flush;
   /*
       If the linear relaxation of the root is infeasible, bail out now. Otherwise,
       continue with processing the root node.
@@ -2178,10 +2188,12 @@ void CbcModel::branchAndBound(int doStatistics)
       solver_ = continuousSolver_;
       setPointers(solver_);
       continuousSolver_ = NULL;
+      std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 1" <<  std::endl<< std::flush;
     }
     solverCharacteristics_ = NULL;
     if (flipObjective)
       flipModel();
+     std::cout << "CbcModel::branchAndBound this=" << this  << " return 6" <<  std::endl<< std::flush;
     return;
   } else if (!numberObjects_) {
     // nothing to do
@@ -2235,8 +2247,10 @@ void CbcModel::branchAndBound(int doStatistics)
     delete[] bestSolution_;
     bestSolution_ = new double[numberColumns];
     CoinCopyN(solver_->getColSolution(), numberColumns, bestSolution_);
+     std::cout << "CbcModel::branchAndBound this=" << this  << " return 7" <<  std::endl<< std::flush;
     return;
   }
+  std::cout << "CbcModel::branchAndBound6 this="<<this << std::endl<< std::flush;
   /*
       See if we're using the Osi side of the branching hierarchy. If so, either
       convert existing CbcObjects to OsiObjects, or generate them fresh. In the
@@ -2305,6 +2319,7 @@ void CbcModel::branchAndBound(int doStatistics)
     }
     branchingMethod_->chooseMethod()->setSolver(solver_);
   }
+  std::cout << "CbcModel::branchAndBound7 this="<<this << std::endl<< std::flush;
   // take off heuristics if have to (some do not work with SOS, for example)
   // object should know what's safe.
   {
@@ -2373,7 +2388,7 @@ void CbcModel::branchAndBound(int doStatistics)
   if (solver_->getRowCutDebuggerAlways())
     specialOptions_ |= 1;
 #endif
-
+std::cout << "CbcModel::branchAndBound8 this="<<this << std::endl<< std::flush;
   /*
       Begin setup to process a feasible root node.
     */
@@ -2456,7 +2471,7 @@ void CbcModel::branchAndBound(int doStatistics)
     }
   }
 #endif
-
+std::cout << "CbcModel::branchAndBound9 this="<<this << std::endl<< std::flush;
   // add cutoff as constraint if wanted
   if (cutoffRowNumber_ == -2) {
     if (!parentModel_) {
@@ -2491,6 +2506,7 @@ void CbcModel::branchAndBound(int doStatistics)
   }
   numberRowsAtContinuous_ = getNumRows();
   solver_->saveBaseModel();
+  std::cout << "CbcModel::branchAndBound10 this="<<this << std::endl<< std::flush;
   /*
       Check the objective to see if we can deduce a nontrivial increment. If
       it's better than the current value for CbcCutoffIncrement, it'll be
@@ -2560,6 +2576,7 @@ void CbcModel::branchAndBound(int doStatistics)
 #endif
   }
   tree_->setComparison(*nodeCompare_);
+  std::cout << "CbcModel::branchAndBound11 this="<<this << std::endl<< std::flush;
   /*
       Used to record the path from a node to the root of the search tree, so that
       we can then traverse from the root to the node when restoring a subproblem.
@@ -2684,6 +2701,7 @@ void CbcModel::branchAndBound(int doStatistics)
       }
     }
   }
+  std::cout << "CbcModel::branchAndBound12 this="<<this << std::endl<< std::flush;
 #ifdef SWITCH_VARIABLES
   // see if any switching variables
   if (numberIntegers_ < solver_->getNumCols())
@@ -2882,6 +2900,7 @@ void CbcModel::branchAndBound(int doStatistics)
     delete[] which;
     delete[] value;
   }
+  std::cout << "CbcModel::branchAndBound14 this="<<this << std::endl<< std::flush;
   // Do heuristics
   if (numberObjects_ && !rootModels)
     doHeuristicsAtRoot();
@@ -2944,6 +2963,8 @@ void CbcModel::branchAndBound(int doStatistics)
       convertToDynamic();
     }
   }
+  
+  std::cout << "CbcModel::branchAndBound15 this="<<this << std::endl<< std::flush;
 #ifdef COIN_HAS_NTY
 #define MAX_NAUTY_PASS 2000
   int testOptions = moreSpecialOptions2_&1073741824;
@@ -2959,6 +2980,7 @@ void CbcModel::branchAndBound(int doStatistics)
     OsiSolverInterface *solverOriginal = solver_;
     OsiSolverInterface *continuousSolver = continuousSolver_;
     continuousSolver_ = NULL;
+    std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 2" <<  std::endl<< std::flush;
     int numberOriginalRows = solverOriginal->getNumRows();
     OsiSolverInterface *solver = solverOriginal->clone();
     solver_ = solver;
@@ -3098,6 +3120,7 @@ void CbcModel::branchAndBound(int doStatistics)
       // have to switch nauty off totally!
       moreSpecialOptions2_ &= ~(128 | 256);
     }
+    std::cout << "CbcModel::branchAndBound this=" << this << " continuousSolver=" << continuousSolver << std::endl << std::flush;
     continuousSolver_ = continuousSolver;
     int numberRows = solver->getNumRows();
     if (numberRows > numberOriginalRows) {
@@ -3121,6 +3144,7 @@ void CbcModel::branchAndBound(int doStatistics)
   }
 #endif
 
+std::cout << "CbcModel::branchAndBound16 this="<<this << std::endl<< std::flush;
   /*
       Do an initial round of cut generation for the root node. Depending on the
       type of underlying solver, we may want to do this even if the initial query
@@ -3597,6 +3621,7 @@ void CbcModel::branchAndBound(int doStatistics)
         NULL);
     }
   }
+  std::cout << "CbcModel::branchAndBound17 this="<<this << std::endl<< std::flush;
   if (rootModels) {
     int numberModels = multipleRootTries_ % 100;
     for (int i = 0; i < numberModels; i++)
@@ -3765,6 +3790,7 @@ void CbcModel::branchAndBound(int doStatistics)
     feasible = false;
   }
 #endif
+std::cout << "CbcModel::branchAndBound18 this="<<this << std::endl<< std::flush;
   if (!parentModel_ && (moreSpecialOptions_ & 268435456) != 0) {
     // try idiotic idea
     CbcObject *obj = new CbcIdiotBranch(this);
@@ -3836,8 +3862,11 @@ void CbcModel::branchAndBound(int doStatistics)
     delete saveSolver;
     if (flipObjective)
       flipModel();
+     std::cout << "CbcModel::branchAndBound this=" << this  << " return 8" <<  std::endl<< std::flush;
     return;
   }
+  
+  std::cout << "CbcModel::branchAndBound19 this="<<this << std::endl<< std::flush;
   /*
       We've taken the continuous relaxation as far as we can. Time to branch.
       The first order of business is to actually create a node. chooseBranch
@@ -4239,6 +4268,8 @@ void CbcModel::branchAndBound(int doStatistics)
       feasible = false;
     }
   }
+  
+  std::cout << "CbcModel::branchAndBound20 this="<<this << std::endl<< std::flush;
   if (newNode && probingInfo_) {
     int number01 = probingInfo_->numberIntegers();
     //const fixEntry * entry = probingInfo_->fixEntries();
@@ -4345,6 +4376,7 @@ void CbcModel::branchAndBound(int doStatistics)
       probingInfo_ = NULL;
     }
   }
+  std::cout << "CbcModel::branchAndBound21 this="<<this << std::endl<< std::flush;
   /*
       At this point, the root subproblem is infeasible or fathomed by bound
       (newNode == NULL), or we're live with an objective value that satisfies the
@@ -4449,6 +4481,7 @@ void CbcModel::branchAndBound(int doStatistics)
     }
   }
 
+  std::cout << "CbcModel::branchAndBound22 this="<<this << std::endl<< std::flush;
   if (printFrequency_ <= 0) {
     printFrequency_ = 1000;
     if (getNumCols() > 2000)
@@ -4479,6 +4512,7 @@ void CbcModel::branchAndBound(int doStatistics)
     }
   }
 #endif
+std::cout << "CbcModel::branchAndBound23 this="<<this << std::endl<< std::flush;
   /*
       At last, the actual branch-and-cut search loop, which will iterate until
       the live set is empty or we hit some limit (integrality gap, time, node
@@ -4510,6 +4544,7 @@ void CbcModel::branchAndBound(int doStatistics)
       //abort();
     }
   }
+  std::cout << "CbcModel::branchAndBound23.1 this="<<this << std::endl<< std::flush;
   {
     // may be able to change cutoff now
     double cutoff = getCutoff();
@@ -4519,6 +4554,7 @@ void CbcModel::branchAndBound(int doStatistics)
       setCutoff(cutoff);
     }
   }
+  std::cout << "CbcModel::branchAndBound23.2 this="<<this << std::endl<< std::flush;
 #ifdef CBC_THREAD
   bool goneParallel = false;
 #endif
@@ -4535,7 +4571,9 @@ void CbcModel::branchAndBound(int doStatistics)
   if ((moreSpecialOptions_ & 262144) != 0)
     specialOptions_ |= 131072;
 #endif
-  while (true) {
+  while (true)
+  {
+    std::cout << "CbcModel::branchAndBound23.3 this="<<this << std::endl<< std::flush;
     lockThread();
 #ifdef COIN_HAS_CLP
     // See if we want dantzig row choice
@@ -4660,6 +4698,7 @@ void CbcModel::branchAndBound(int doStatistics)
     break;
 #endif
     } else {
+      std::cout << "CbcModel::branchAndBound23.5 this="<<this << std::endl<< std::flush;
       unlockThread();
     }
     // If done 50/100 nodes see if worth trying reduction
@@ -4764,6 +4803,7 @@ void CbcModel::branchAndBound(int doStatistics)
               delete temp;
               saveSolver->writeMps("reduced");
             } else {
+              std::cout << "CbcModel::branchAndBound23.6 abort this="<<this << std::endl<< std::flush;
               abort();
             }
           }
@@ -4830,6 +4870,7 @@ void CbcModel::branchAndBound(int doStatistics)
             delete[] newSolution;
 #ifdef CBC_THREAD
             if (master_) {
+              std::cout << "CbcModel::branchAndBound23.6 lockThread this="<<this << std::endl<< std::flush;
               lockThread();
               if (parallelMode() > 0) {
                 while (master_->waitForThreadsInTree(0)) {
@@ -4842,6 +4883,7 @@ void CbcModel::branchAndBound(int doStatistics)
                 double dummyBest;
                 tree_->cleanTree(this, -COIN_DBL_MAX, dummyBest);
               }
+              std::cout << "CbcModel::branchAndBound23.6 waitForThreadsInTree this="<<this << std::endl<< std::flush;
               master_->waitForThreadsInTree(2);
               delete master_;
               master_ = NULL;
@@ -4859,6 +4901,7 @@ void CbcModel::branchAndBound(int doStatistics)
         saveSolver = NULL;
       }
     }
+    std::cout << "CbcModel::branchAndBound23.7 this="<<this << std::endl<< std::flush;
     /*
           Check for abort on limits: node count, solution count, time, integrality gap.
         */
@@ -4953,6 +4996,7 @@ void CbcModel::branchAndBound(int doStatistics)
       if (tree_->empty()) {
         continue;
       }
+       std::cout << "CbcModel::branchAndBound23.8 unlockThread this="<<this << std::endl<< std::flush;
       unlockThread();
     }
     cutoff = getCutoff();
@@ -4976,6 +5020,7 @@ void CbcModel::branchAndBound(int doStatistics)
       // redo tree if requested
       if (redoTree)
         tree_->setComparison(*nodeCompare_);
+      std::cout << "CbcModel::branchAndBound23.9 unlockThread this="<<this << std::endl<< std::flush;
       unlockThread();
     }
     // Had hotstart before, now switched off
@@ -4989,6 +5034,7 @@ void CbcModel::branchAndBound(int doStatistics)
       tree_->setComparison(*nodeCompare_);
       unlockThread();
     }
+    std::cout << "CbcModel::branchAndBound23.10 this="<<this << std::endl<< std::flush;
     if (numberNodes_ >= lastPrintEvery) {
       lastPrintEvery = numberNodes_ + printFrequency_;
       lockThread();
@@ -5084,17 +5130,22 @@ void CbcModel::branchAndBound(int doStatistics)
           represents, and then execute the current arm of the branch to create the
           active subproblem.
         */
+    std::cout << "CbcModel::branchAndBound23.11 this="<<this << std::endl<< std::flush;
     CbcNode *node = NULL;
 #ifdef CBC_THREAD
     if (!parallelMode() || parallelMode() == -1) {
 #endif
+      std::cout << "CbcModel::branchAndBound23.12 this="<<this << std::endl<< std::flush;
       node = tree_->bestNode(cutoff);
+      std::cout << "CbcModel::branchAndBound23.121 this="<<this << std::endl<< std::flush;
       // Possible one on tree worse than cutoff
       // Weird comparison function can leave ineligible nodes on tree
       if (!node || node->objectiveValue() > cutoff)
         continue;
+      std::cout << "CbcModel::branchAndBound23.122 this="<<this << std::endl<< std::flush;
       // Do main work of solving node here
       doOneNode(this, node, createdNode);
+      std::cout << "CbcModel::branchAndBound23.123 this="<<this << std::endl<< std::flush;
 #ifdef JJF_ZERO
       if (node) {
         if (createdNode) {
@@ -5113,12 +5164,14 @@ void CbcModel::branchAndBound(int doStatistics)
         numberConsecutiveInfeasible = 2;
       }
 #endif
+      std::cout << "CbcModel::branchAndBound23.124 this="<<this << std::endl<< std::flush;
       //if (createdNode)
       //numberConsecutiveInfeasible=0;
       //else
       //numberConsecutiveInfeasible++;
 #ifdef CBC_THREAD
     } else if (parallelMode() > 0) {
+      std::cout << "CbcModel::branchAndBound23.13 this="<<this << std::endl<< std::flush;
       //lockThread();
       //node = tree_->bestNode(cutoff) ;
       // Possible one on tree worse than cutoff
@@ -5136,6 +5189,7 @@ void CbcModel::branchAndBound(int doStatistics)
       }
       //unlockThread();
     } else {
+      std::cout << "CbcModel::branchAndBound23.14 this="<<this << std::endl<< std::flush;
       // Deterministic parallel
       if ((tree_->size() < CoinMax(numberThreads_, 8) || hotstartSolution_) && !goneParallel) {
         node = tree_->bestNode(cutoff);
@@ -5186,6 +5240,8 @@ void CbcModel::branchAndBound(int doStatistics)
     }
 #endif
   }
+  std::cout << "CbcModel::branchAndBound24 this="<<this << std::endl<< std::flush;
+  
   if (nDeleteNode) {
     for (int i = 0; i < nDeleteNode; i++) {
       delete delNode[i];
@@ -5261,6 +5317,7 @@ void CbcModel::branchAndBound(int doStatistics)
       status_ = 5;
     }
   }
+  std::cout << "CbcModel::branchAndBound25 this="<<this << std::endl<< std::flush;
 #ifdef CBC_THREAD
   if (master_) {
 #ifdef COIN_HAS_NTY
@@ -5358,6 +5415,7 @@ void CbcModel::branchAndBound(int doStatistics)
         obj->print();
     }
   }
+  std::cout << "CbcModel::branchAndBound26 this="<<this << std::endl<< std::flush;
   if (statistics_) {
     // report in some way
     int *lookup = new int[numberObjects_];
@@ -5521,6 +5579,7 @@ void CbcModel::branchAndBound(int doStatistics)
     maximumStatistics_ = 0;
     delete[] lookup;
   }
+  std::cout << "CbcModel::branchAndBound27 this="<<this << std::endl<< std::flush;
   /*
       If we think we have a solution, restore and confirm it with a call to
       setBestSolution().  We need to reset the cutoff value so as not to fathom
@@ -5571,7 +5630,9 @@ void CbcModel::branchAndBound(int doStatistics)
     solver_ = continuousSolver_;
     setPointers(solver_);
     continuousSolver_ = NULL;
+    std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 2" <<  std::endl<< std::flush;
   }
+  std::cout << "CbcModel::branchAndBound28 this="<<this << std::endl<< std::flush;
   /*
       Clean up dangling objects. continuousSolver_ may already be toast.
     */
@@ -5600,9 +5661,12 @@ void CbcModel::branchAndBound(int doStatistics)
   //delete persistentInfo;
   // Get rid of characteristics
   solverCharacteristics_ = NULL;
+
+  std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 4 ? " << (continuousSolver_ != NULL) << std::endl<< std::flush;
   if (continuousSolver_) {
     delete continuousSolver_;
     continuousSolver_ = NULL;
+    std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 4" <<  std::endl<< std::flush;
   }
   /*
       Destroy global cuts by replacing with an empty OsiCuts object.
@@ -5698,6 +5762,7 @@ void CbcModel::branchAndBound(int doStatistics)
   }
 #endif
   moreSpecialOptions_ = saveMoreSpecialOptions;
+   std::cout << "CbcModel::branchAndBound this=" << this << " return 9" <<  std::endl<< std::flush;
   return;
 }
 
@@ -6456,10 +6521,12 @@ CbcModel::CbcModel(const CbcModel &rhs, bool cloneHandler)
     numberObjects_ = 0;
     object_ = NULL;
   }
+  // std::cout << "CbcModel this=" << this << " rhs.continuousSolver_ ?" << (rhs.continuousSolver_!=NULL) <<  std::endl<< std::flush;
   if (rhs.continuousSolver_) {
     continuousSolver_ = rhs.continuousSolver_->clone();
   } else {
     continuousSolver_ = NULL;
+    std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 5" <<  std::endl<< std::flush;
   }
   if (rhs.referenceSolver_)
     referenceSolver_ = rhs.referenceSolver_->clone();
@@ -6639,6 +6706,7 @@ CbcModel::operator=(const CbcModel &rhs)
     if (rhs.continuousSolver_) {
       continuousSolver_ = rhs.continuousSolver_->clone();
     } else {
+      std::cout << "CbcModel::operator= this=" << this  << " continuousSolver_.NULL x" <<  std::endl<< std::flush;
       continuousSolver_ = 0;
     }
     delete referenceSolver_;
@@ -6969,6 +7037,7 @@ CbcModel::~CbcModel()
   }
   delete tree_;
   tree_ = NULL;
+  std::cout << "CbcModel::~CbcModel.2 this="<<this<<" solver_="<<solver_<<" continuousSolver_=" << continuousSolver_ <<  std::endl<< std::flush;
   if (modelOwnsSolver()) {
     delete solver_;
     solver_ = NULL;
@@ -7049,8 +7118,10 @@ void CbcModel::resetModel()
 {
   delete emptyWarmStart_;
   emptyWarmStart_ = NULL;
+  std::cout << "CbcModel::resetModel this="<<this<<" continuousSolver_=" << continuousSolver_ << std::endl<< std::flush;
   delete continuousSolver_;
   continuousSolver_ = NULL;
+  std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 6" <<  std::endl<< std::flush;
   numberSavedSolutions_ = 0;
   delete[] bestSolution_;
   bestSolution_ = NULL;
@@ -14650,9 +14721,11 @@ void CbcModel::setStrategy(CbcStrategy &strategy)
 // Increases usedInSolution for nonzeros
 void CbcModel::incrementUsed(const double *solution)
 {
+  std::cout << "CbcModel::incrementUsed this="<<this <<" solution="<<solution<<" usedInSolution_="<<usedInSolution_<<std::endl<< std::flush;
   if (usedInSolution_) {
     // might as well mark all including continuous
     int numberColumns = solver_->getNumCols();
+    std::cout << "CbcModel::incrementUsed this="<<this <<" numberColumns="<<numberColumns<<std::endl<< std::flush;
     for (int i = 0; i < numberColumns; i++) {
       if (solution[i])
         usedInSolution_[i]++;
@@ -16432,6 +16505,7 @@ void CbcModel::setCutModifier(CbcCutModifier &modifier)
 */
 int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
 {
+  std::cout << "CbcModel::doOneNode0 this="<<this << std::endl<< std::flush;
   int foundSolution = 0;
   int saveNumberCutGenerators = numberCutGenerators_;
   if ((moreSpecialOptions_ & 33554432) != 0 && (specialOptions_ & 2048) == 0) {
@@ -16452,7 +16526,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
     node->numberUnsatisfied());
   //node->columnNumber()) ;
 #endif
-
+std::cout << "CbcModel::doOneNode1 this="<<this << std::endl<< std::flush;
   /*
       Rebuild the subproblem for this node:	 Call addCuts() to adjust the model
       to recreate the subproblem for this node (set proper variable bounds, add
@@ -16476,7 +16550,9 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
     newNode = new CbcNode();
   bool feasible = true;
   CoinWarmStartBasis *lastws = new CoinWarmStartBasis();
+  std::cout << "CbcModel::doOneNode2 this="<<this << std::endl<< std::flush;
   lockThread();
+  std::cout << "CbcModel::doOneNode3 this="<<this << std::endl<< std::flush;
   // point to genuine ones
   //int save1 = maximumNumberCuts_;
   //maximumNumberCuts_ = baseModel->maximumNumberCuts_;
@@ -16494,6 +16570,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
 #ifdef SWITCH_VARIABLES
   fixAssociated(solver_, 0);
 #endif
+  std::cout << "CbcModel::doOneNode4 this="<<this << std::endl<< std::flush;
   //if (save1<maximumNumberCuts_) {
   // increased
   //baseModel->maximumNumberCuts_ = maximumNumberCuts_;
@@ -16509,7 +16586,9 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
     baseModel->lastNumberCuts2_ = lastNumberCuts2_;
   }
   int branchesLeft = 0;
+  std::cout << "CbcModel::doOneNode5 retcode=" << retCode<<" this="<<this <<std::endl<< std::flush;
   if (!retCode) {
+    std::cout << "CbcModel::doOneNode6 this="<<this <<std::endl<< std::flush;
     unlockThread();
     int i;
     const double *lower = getColLower();
@@ -16523,6 +16602,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
       solverCharacteristics_->setBeforeUpper(upperBefore);
     }
     lockThread();
+    std::cout << "CbcModel::doOneNode7 this="<<this <<std::endl<< std::flush;
     assert(node->objectiveValue() < 1.0e200);
     if (messageHandler()->logLevel() > 2)
       node->modifiableBranchingObject()->print();
@@ -16608,6 +16688,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
         }
       }
     } else {
+      std::cout << "CbcModel::doOneNode8 this="<<this <<std::endl<< std::flush;
       // normal
       if (false) {
         const double *lower = solver_->getColLower();
@@ -16658,6 +16739,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
 #ifndef COIN_HAS_CPX
           specialOptions_ &= ~16384;
 #endif
+          std::cout << "CbcModel::doOneNode9 this="<<this <<" specialOptions_="<<specialOptions_ <<std::endl<< std::flush;
           if ((specialOptions_ & 16384) == 0) {
             info->integerTolerance_ = getIntegerTolerance();
             info->integerIncrement_ = getCutoffIncrement();
@@ -16784,6 +16866,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
                 fastNodeDepth_, FATHOM_BIAS - fastNodeDepth_);
 #endif
             }
+            std::cout << "CbcModel::doOneNode10 this="<<this <<" info->nNodes_="<<info->nNodes_ <<std::endl<< std::flush;
             if (info->nNodes_ < 0) {
               // we gave up
               //abort();
@@ -16798,6 +16881,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
               printf("gave up fastNodeDepth now %d - so at depth >= %d\n",
                 fastNodeDepth_, FATHOM_BIAS - fastNodeDepth_);
 #endif
+              std::cout << "CbcModel::doOneNode11 this="<<this <<" feasible="<<feasible <<std::endl<< std::flush;
               if (feasible) {
                 // Save bounds round bestSolution
                 //double * saveLower = CoinCopyOfArray(solver_->getColLower(),
@@ -16824,6 +16908,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
               // say feasible so will redo node
               feasible = true;
             } else {
+              std::cout << "CbcModel::doOneNode12 this="<<this <<std::endl<< std::flush;
               if (feasible) {
                 clpSolver->setWarmStart(NULL);
                 // try and do solution
@@ -16845,6 +16930,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
                   solver_->setColUpper(saveUpper);
                 }
               }
+              
               // update pseudo costs
               double smallest = 1.0e50;
               double largest = -1.0;
@@ -16877,6 +16963,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
             simplex->setLogLevel(saveLevel);
 #ifdef COIN_HAS_CPX
           } else {
+            std::cout << "CbcModel::doOneNode13 this="<<this <<std::endl<< std::flush;
             // try cplex
             OsiCpxSolverInterface cpxSolver;
             double direction = clpSolver->getObjSense();
@@ -16960,6 +17047,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
       feasible = solveWithCuts(cuts, maximumCutPasses_, node);
 #endif
     }
+    std::cout << "CbcModel::doOneNode13.2 this="<<this <<std::endl<< std::flush;
     if ((specialOptions_ & 1) != 0 && onOptimalPath) {
       if (solver_->getRowCutDebuggerAlways()->optimalValue() < getCutoff()) {
         if (!solver_->getRowCutDebugger() || !feasible) {
@@ -17030,6 +17118,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
       }
     }
     bool checkingNode = false;
+    std::cout << "CbcModel::doOneNode14 this="<<this <<" feasible= "<<feasible<<std::endl<< std::flush;
     if (feasible) {
 #ifdef FUNNY_BRANCHING2
       // Far too clever
@@ -17124,6 +17213,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
               dj[iColumn1], nodeInfo->numberBranchesLeft());
 #endif
             while (nodeInfo->parent()) {
+              std::cout << "CbcModel::doOneNode15 this="<<this <<std::endl<< std::flush;
               nodeInfo = nodeInfo->parent();
               CbcNode *nodeLook = nodeInfo->mutableOwner();
               if (!nodeLook || nodeLook->objectiveValue() == 0.5 * COIN_DBL_MAX)
@@ -17353,6 +17443,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
       }
       unlockThread();
     }
+    std::cout << "CbcModel::doOneNode17 this="<<this <<std::endl<< std::flush;
     /*
           At this point, there are three possibilities:
           * newNode is live and will require further branching to resolve
@@ -17407,6 +17498,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
         numberUpdateItems_ = 0;
       }
     }
+    std::cout << "CbcModel::doOneNode18 this="<<this <<std::endl<< std::flush;
     if (newNode)
       if (newNode && newNode->active()) {
         if (newNode->branchingObject() == NULL) {
@@ -17441,6 +17533,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
             }
           }
         }
+        std::cout << "CbcModel::doOneNode18.2 bo=" << newNode->branchingObject()<< " this="<<this <<std::endl<< std::flush;
         if (newNode->branchingObject()) {
           handler_->message(CBC_BRANCH, messages_)
             << numberNodes_ << trueObjValue(newNode->objectiveValue())
@@ -17457,7 +17550,9 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
               addedCuts_[i]->increment(numberLeft - 1);
             }
           }
+          std::cout << "CbcModel::doOneNode18.3 this="<<this <<std::endl<< std::flush;
           unlockThread();
+          std::cout << "CbcModel::doOneNode18.31 this="<<this <<std::endl<< std::flush;
           locked = false;
           double estValue = newNode->guessedObjectiveValue();
           int found = -1;
@@ -17468,6 +17563,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
           // allow more heuristics
           currentPassNumber_ = 0;
           for (iHeur = 0; iHeur < numberHeuristics_; iHeur++) {
+            std::cout << "CbcModel::doOneNode18.4 this="<<this <<std::endl<< std::flush;
             // skip if can't run here
             if (!heuristic_[iHeur]->shouldHeurRun(whereFrom))
               continue;
@@ -17496,6 +17592,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
               heurValue = saveValue;
             }
           }
+          std::cout << "CbcModel::doOneNode18.4 this="<<this <<" found="<<found<<std::endl<< std::flush;
           if (found >= 0 && parallelMode() > 0) {
             lastHeuristic_ = heuristic_[found];
 #if CBC_USEFUL_PRINTING > 1
@@ -17505,12 +17602,14 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
             setBestSolution(CBC_ROUNDING, heurValue, newSolution);
             foundSolution = 1;
           }
+          std::cout << "CbcModel::doOneNode18.5 this="<<this <<std::endl<< std::flush;
           delete[] newSolution;
           newNode->setGuessedObjectiveValue(estValue);
           if (parallelMode() >= 0) {
             if (!masterThread_) // only if serial
               tree_->push(newNode);
           }
+          std::cout << "CbcModel::doOneNode18.6 this="<<this <<std::endl<< std::flush;
           if (statistics_) {
             if (numberNodes2_ == maximumStatistics_) {
               maximumStatistics_ = 2 * maximumStatistics_;
@@ -17523,15 +17622,17 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
             assert(!statistics_[numberNodes2_]);
             statistics_[numberNodes2_] = new CbcStatistics(newNode, this);
           }
+          std::cout << "CbcModel::doOneNode18.7 this="<<this <<std::endl<< std::flush;
           numberNodes2_++;
 #ifdef CHECK_NODE
           printf("Node %x pushed on tree c\n", newNode);
 #endif
         } else {
+          std::cout << "CbcModel::doOneNode18.8 this="<<this <<" solverCharacteristics_="<<solverCharacteristics_<<std::endl<< std::flush;
           if (solverCharacteristics_ && //we may be in a non standard bab
             solverCharacteristics_->solutionAddsCuts() // we are in some kind of OA based bab.
           ) {
-
+            std::cout << "CbcModel::doOneNode18.9 this="<<this <<" CoinError"<<std::endl<< std::flush;
             std::cerr << "You should never get here" << std::endl;
             throw CoinError("Nodes should not be fathomed on integer infeasibility in this setting",
               "branchAndBound", "CbcModel");
@@ -17544,17 +17645,24 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
               }
             }
           }
+          std::cout << "CbcModel::doOneNode18.10 this="<<this <<std::endl<< std::flush;
           double objectiveValue = newNode->objectiveValue();
           lastHeuristic_ = NULL;
+          std::cout << "CbcModel::doOneNode18.101  this="<<this <<" objectiveValue="<<objectiveValue<<" cutoff="<<getCutoff()<<std::endl<< std::flush;
           // Just possible solver did not know about a solution from another thread!
           if (objectiveValue < getCutoff()) {
+            std::cout << "CbcModel::doOneNode18.102 this="<<this <<std::endl<< std::flush;
             incrementUsed(solver_->getColSolution());
+            std::cout << "CbcModel::doOneNode18.103 this="<<this <<std::endl<< std::flush;
             setBestSolution(CBC_SOLUTION, objectiveValue,
               solver_->getColSolution());
+            std::cout << "CbcModel::doOneNode18.104 this="<<this <<std::endl<< std::flush;
             // Check if was found
+            std::cout << "CbcModel::doOneNode18.105 this="<<this <<" bestObjective_="<<bestObjective_<<std::endl<< std::flush;
             if (bestObjective_ < getCutoff())
               foundSolution = 1;
           }
+          std::cout << "CbcModel::doOneNode18.11 this="<<this <<" parallelMode="<<parallelMode()<<std::endl<< std::flush;
           //assert(nodeInfo->numberPointingToThis() <= 2) ;
           if (parallelMode() >= 0) {
             // avoid accidental pruning, if newNode was final branch arm
@@ -17567,6 +17675,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
           }
         }
       }
+      std::cout << "CbcModel::doOneNode19 this="<<this <<std::endl<< std::flush;
     if (branchesLeft) {
       // set nodenumber correctly
       if (node->nodeInfo())
@@ -17639,6 +17748,8 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
       node->setActive(false);
     }
   }
+  
+  std::cout << "CbcModel::doOneNode20 this="<<this <<std::endl<< std::flush;
   /*
       Delete cuts to get back to the original system.
 
@@ -17691,6 +17802,7 @@ int CbcModel::doOneNode(CbcModel *baseModel, CbcNode *&node, CbcNode *&newNode)
     unlockThread();
   }
   numberCutGenerators_ = saveNumberCutGenerators;
+  std::cout << "CbcModel::doOneNode21 this="<<this <<" foundSolution="<<foundSolution <<std::endl<< std::flush;
   return foundSolution;
 }
 // Adds an update information object
@@ -18200,6 +18312,7 @@ bool CbcModel::integerPresolveThisModel(OsiSolverInterface *originalSolver,
   solverCharacteristics_->setSolver(solver_);
   // just point to solver_
   delete continuousSolver_;
+  std::cout << "CbcModel::integerPresolveThisModel this=" << this << " solver_=" << solver_ << std::endl<< std::flush;
   continuousSolver_ = solver_;
   // get a copy of original so we can fix bounds
   OsiSolverInterface *cleanModel = originalSolver->clone();
@@ -18361,6 +18474,7 @@ bool CbcModel::integerPresolveThisModel(OsiSolverInterface *originalSolver,
         }
         synchronizeModel(); // make sure everything that needs solver has it
         // just point to solver_
+        std::cout << "CbcModel::integerPresolveThisModel this=" << this << " solver_=" << solver_ << std::endl << std::flush;
         continuousSolver_ = solver_;
         feasible = (resolve(NULL, 3) != 0);
         if (!feasible || !doIntegerPresolve || weak)
@@ -18484,6 +18598,7 @@ bool CbcModel::integerPresolveThisModel(OsiSolverInterface *originalSolver,
   deleteObjects();
   synchronizeModel(); // make sure everything that needs solver has it
   continuousSolver_ = NULL;
+  std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 7" <<  std::endl<< std::flush;
   currentNumberCuts_ = 0;
   return feasible;
 }
@@ -19045,6 +19160,7 @@ CbcModel::strengthenedModel()
   if (continuousSolver_) {
     delete continuousSolver_;
     continuousSolver_ = NULL;
+    std::cout << "CbcModel this=" << this  << " continuousSolver_.NULL 8" <<  std::endl<< std::flush;
   }
   /*
       Destroy global cuts by replacing with an empty OsiCuts object.
