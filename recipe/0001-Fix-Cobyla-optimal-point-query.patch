From f299c729faeab8dfdf11991c85bdb810806ff10f Mon Sep 17 00:00:00 2001
From: Julien Schueller <schueller@phimeca.com>
Date: Thu, 31 May 2018 18:03:20 +0200
Subject: [PATCH 1/7] Fix Cobyla optimal point query

The point returned by reference by cobyla might not be exactly the one
evaluated, so query the nearest in the history to avoid a crash as find
returns an index out of bounds.
---
 lib/src/Base/Optim/Cobyla.cxx                 | 14 +++++++----
 .../test/t_EfficientGlobalOptimization_std.py | 25 +++++++++++++++++++
 2 files changed, 34 insertions(+), 5 deletions(-)

diff --git a/lib/src/Base/Optim/Cobyla.cxx b/lib/src/Base/Optim/Cobyla.cxx
index da4f2fe0..85d0a460 100644
--- a/lib/src/Base/Optim/Cobyla.cxx
+++ b/lib/src/Base/Optim/Cobyla.cxx
@@ -23,6 +23,7 @@
 #include "openturns/PersistentObjectFactory.hxx"
 #include "openturns/Log.hxx"
 #include "openturns/SpecFunc.hxx"
+#include "openturns/NearestNeighbourAlgorithm.hxx"
 
 BEGIN_NAMESPACE_OPENTURNS
 
@@ -120,7 +121,7 @@ void Cobyla::run()
    * extern int cobyla(int n, int m, double *x, double rhobeg, double rhoend,
    *  int message, int *maxfun, cobyla_function *calcfc, void *state);
    */
-  int returnCode(ot_cobyla(n, m, &x[0], rhoBeg_, rhoEnd, message, &maxFun, Cobyla::ComputeObjectiveAndConstraint, (void*) this));
+  int returnCode = ot_cobyla(n, m, &x[0], rhoBeg_, rhoEnd, message, &maxFun, Cobyla::ComputeObjectiveAndConstraint, (void*) this);
 
   result_ = OptimizationResult(dimension, 2);
   result_.setProblem(getProblem());
@@ -149,10 +150,13 @@ void Cobyla::run()
     result_.store(inP, Point(1, outP[0]), absoluteError, relativeError, residualError, constraintError);
   }
 
-  result_.setOptimalPoint(x);
-  const UnsignedInteger index = evaluationInputHistory_.find(x);
-  Scalar bestValue = evaluationOutputHistory_(index, 0);
-  result_.setOptimalValue(Point(1, bestValue));
+  UnsignedInteger optimalIndex = evaluationInputHistory_.find(x);
+  // x might not be exactly the best point evaluated, so fallback to the nearest
+  if (optimalIndex >= size)
+    optimalIndex = NearestNeighbourAlgorithm(evaluationInputHistory_).query(x);
+  result_.setOptimalPoint(evaluationInputHistory_[optimalIndex]);
+  result_.setOptimalValue(Point(1, evaluationOutputHistory_(optimalIndex, 0)));
+
   result_.setEvaluationNumber(maxFun);
   result_.setLagrangeMultipliers(computeLagrangeMultipliers(x));
 
diff --git a/python/test/t_EfficientGlobalOptimization_std.py b/python/test/t_EfficientGlobalOptimization_std.py
index d8dd2f1c..aa0927a2 100755
--- a/python/test/t_EfficientGlobalOptimization_std.py
+++ b/python/test/t_EfficientGlobalOptimization_std.py
@@ -160,3 +160,28 @@ openturns.testing.assert_almost_equal(
 # ei = algo.getExpectedImprovement()
 # print(ei)
 print('OK')
+
+
+# Cobyla out of bound test
+ot.RandomGenerator.SetSeed(0)
+dim = 4
+model = ot.SymbolicFunction(['x1', 'x2', 'x3', 'x4'], ['x1*x1+x2^3*x1+x3+x4'])
+model = ot.MemoizeFunction(model)
+bounds = ot.Interval([-5.0] * dim, [5.0] * dim)
+problem = ot.OptimizationProblem()
+problem.setObjective(model)
+problem.setBounds(bounds)
+experiment = ot.Composite([0.0] * dim, [1.0, 2.0, 4.0])
+inputSample = experiment.generate()
+outputSample = model(inputSample)
+covarianceModel = ot.SquaredExponential([2.0] * dim, [0.1])
+basis = ot.ConstantBasisFactory(dim).build()
+kriging = ot.KrigingAlgorithm(inputSample, outputSample, covarianceModel, basis)
+kriging.run()
+algo = ot.EfficientGlobalOptimization(problem, kriging.getResult())
+algo.setMaximumEvaluationNumber(2)
+algo.run()
+result = algo.getResult()
+
+
+
-- 
2.17.0

