diff --git a/CMakeLists.txt b/CMakeLists.txt
index 685223460..6c466e41c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -9,35 +9,35 @@ set (CMAKE_TRY_COMPILE_CONFIGURATION ${CMAKE_BUILD_TYPE})
 
 project (openturns)
 
-option (USE_BISON                    "Looks for Bison if true and then build parser"                         ON)
-option (USE_CUBA                     "Use Cuba library"                                                      ON)
-option (USE_FLEX                     "Looks for Flex if true and then build lexer"                           ON)
-option (USE_TBB                      "Use Intel Threading Building Blocks library for multithreading"        ON)
+option (USE_BISON                    "Looks for Bison if true and then build parser"                         OFF)
+option (USE_CUBA                     "Use Cuba library"                                                      OFF)
+option (USE_FLEX                     "Looks for Flex if true and then build lexer"                           OFF)
+option (USE_TBB                      "Use Intel Threading Building Blocks library for multithreading"        OFF)
 option (USE_HMAT                     "Use HMat library (enforces GPL license)"                               OFF)
-option (USE_MUPARSER                 "Use muParser library"                                                  ON)
+option (USE_MUPARSER                 "Use muParser library"                                                  OFF)
 option (USE_EXPRTK                   "Use ExprTK library"                                                    ON)
-option (USE_LIBXML2                  "Use LibXml2 for XML support"                                           ON)
-option (USE_HDF5                     "Use HDF5 for high volume storage"                                      ON)
-option (USE_BOOST                    "Use Boost for distribution computation"                                ON)
-option (USE_MPFR                     "Use MPFR for real valued special functions computation"                ON)
-option (USE_MPC                      "Use MPC for complex valued special functions computation"              ON)
-option (USE_SPHINX                   "Use sphinx for documentation"                                          ON)
-option (USE_DOXYGEN                  "Use Doxygen for API documentation"                                     ON)
-option (USE_NLOPT                    "Use NLopt for additional optimization algorithms"                      ON)
-option (USE_CERES                    "Use Ceres Solver for additional optimization algorithms"               ON)
-option (USE_CMINPACK                 "Use CMinpack for additional optimization algorithms"                   ON)
-option (USE_DLIB                     "Use dlib for additional optimization algorithms"                       ON)
+option (USE_LIBXML2                  "Use LibXml2 for XML support"                                           OFF)
+option (USE_HDF5                     "Use HDF5 for high volume storage"                                      OFF)
+option (USE_BOOST                    "Use Boost for distribution computation"                                OFF)
+option (USE_MPFR                     "Use MPFR for real valued special functions computation"                OFF)
+option (USE_MPC                      "Use MPC for complex valued special functions computation"              OFF)
+option (USE_SPHINX                   "Use sphinx for documentation"                                          OFF)
+option (USE_DOXYGEN                  "Use Doxygen for API documentation"                                     OFF)
+option (USE_NLOPT                    "Use NLopt for additional optimization algorithms"                      OFF)
+option (USE_CERES                    "Use Ceres Solver for additional optimization algorithms"               OFF)
+option (USE_CMINPACK                 "Use CMinpack for additional optimization algorithms"                   OFF)
+option (USE_DLIB                     "Use dlib for additional optimization algorithms"                       OFF)
 option (USE_IPOPT                    "Use Ipopt for nonlinear optimization"                                  ON)
 option (USE_BONMIN                   "Use Bonmin for MINLP problems"                                         ON)
-option (USE_PAGMO                    "Use Pagmo for multi-objective optimization"                            ON)
-option (USE_SPECTRA                  "Use Spectra for eigenvalues computation"                               ON)
-option (USE_PRIMESIEVE               "Use primesieve for prime numbers generation"                           ON)
-option (USE_OPENMP                   "Use OpenMP to disable threading"                                       ON)
-option (USE_OPENBLAS                 "Use OpenBLAS to disable threading"                                     ON)
-option (USE_CXX17                    "Use C++17 standard"                                                    ON)
-option (USE_NANOFLANN                "Use nanoflann for Nearest Neighbor search"                             ON)
-
-option (BUILD_PYTHON                 "Build the python module for the library"                               ON)
+option (USE_PAGMO                    "Use Pagmo for multi-objective optimization"                            OFF)
+option (USE_SPECTRA                  "Use Spectra for eigenvalues computation"                               OFF)
+option (USE_PRIMESIEVE               "Use primesieve for prime numbers generation"                           OFF)
+option (USE_OPENMP                   "Use OpenMP to disable threading"                                       OFF)
+option (USE_OPENBLAS                 "Use OpenBLAS to disable threading"                                     OFF)
+option (USE_CXX17                    "Use C++17 standard"                                                    OFF)
+option (USE_NANOFLANN                "Use nanoflann for Nearest Neighbor search"                             OFF)
+
+option (BUILD_PYTHON                 "Build the python module for the library"                               OFF)
 option (BUILD_SHARED_LIBS            "Build shared libraries"                                                ON)
 
 # Defines our own module path
diff --git a/lib/include/openturns/OTtestcode.hxx b/lib/include/openturns/OTtestcode.hxx
index 680a86e49..ac795e71e 100644
--- a/lib/include/openturns/OTtestcode.hxx
+++ b/lib/include/openturns/OTtestcode.hxx
@@ -36,7 +36,7 @@
 #include "openturns/PlatformInfo.hxx"
 #include "openturns/SpecFunc.hxx"
 #include "openturns/TBB.hxx"
-#include "openturns/Distribution.hxx"
+// #include "openturns/Distribution.hxx"
 #include "openturns/Mesh.hxx"
 #include "openturns/Field.hxx"
 #include "openturns/ProcessSample.hxx"
@@ -412,38 +412,6 @@ inline void assert_almost_equal(const Tensor & a, const Tensor & b, const Scalar
     assert_almost_equal(a.getSheet(k), b.getSheet(k), rtol, atol, errMsg);
 }
 
-inline void assert_almost_equal(const Distribution &a, const Distribution &b, const Scalar rtol = 1.0e-5, const Scalar atol = 1.0e-8, const String errMsg = "")
-{
-  if (a.getImplementation()->getClassName() != b.getImplementation()->getClassName())
-    throw InvalidArgumentException(HERE) << "A and B must be the same distribution. A is a " << a.getImplementation()->getClassName() << " whereas B is a " << b.getImplementation()->getClassName();
-
-  if (a.getParameterDimension() != b.getParameterDimension())
-    throw InvalidArgumentException(HERE) << "A and B must have the same number of parameters. A has " << a.getParameterDimension() << " parameters whereas B has " << b.getParameterDimension() << " parameters.";
-
-  assert_almost_equal(a.getParameter(), b.getParameter(), rtol, atol, errMsg);
-}
-
-inline void assert_almost_equal(const Mesh & a, const Mesh & b, const Scalar rtol = 1.0e-5, const Scalar atol = 1.0e-8, const String errMsg = "")
-{
-  assert_almost_equal(a.getVertices(), b.getVertices(), rtol, atol, errMsg);
-  if (a.getSimplices() != b.getSimplices())
-    throw InvalidArgumentException(HERE) << "A and B must have the same simplices";
-}
-
-inline void assert_almost_equal(const Field & a, const Field & b, const Scalar rtol = 1.0e-5, const Scalar atol = 1.0e-8, const String errMsg = "")
-{
-  assert_almost_equal(a.getMesh(), b.getMesh(), rtol, atol, errMsg);
-  assert_almost_equal(a.getValues(), b.getValues(), rtol, atol, errMsg);
-}
-
-inline void assert_almost_equal(const ProcessSample & a, const ProcessSample & b, const Scalar rtol = 1.0e-5, const Scalar atol = 1.0e-8, const String errMsg = "")
-{
-  assert_almost_equal(a.getMesh(), b.getMesh(), rtol, atol, errMsg);
-  if (a.getSize() != b.getSize())
-    throw InvalidArgumentException(HERE) << "A and B must have the same size";
-  for (UnsignedInteger j = 0; j < a.getSize(); ++j)
-    assert_almost_equal(a.getField(j).getValues(), b.getField(j).getValues(), rtol, atol, errMsg);
-}
 
 template <typename T>
 void assert_equal(const T & a, const T & b, const String errMsg = "")
diff --git a/lib/src/Base/CMakeLists.txt b/lib/src/Base/CMakeLists.txt
index ea936172e..3d963dbd3 100644
--- a/lib/src/Base/CMakeLists.txt
+++ b/lib/src/Base/CMakeLists.txt
@@ -17,4 +17,4 @@ add_subdirectory (Optim)
 add_subdirectory (Solver)
 add_subdirectory (Stat)
 add_subdirectory (Type)
-add_subdirectory (IterativeStat)
+# add_subdirectory (IterativeStat)
diff --git a/lib/src/Base/Optim/Bonmin.cxx b/lib/src/Base/Optim/Bonmin.cxx
index c17385aaf..1ff8bc1e0 100644
--- a/lib/src/Base/Optim/Bonmin.cxx
+++ b/lib/src/Base/Optim/Bonmin.cxx
@@ -97,80 +97,20 @@ void Bonmin::checkProblem(const OptimizationProblem & problem) const
 }
 
 
-#ifdef OPENTURNS_HAVE_BONMIN
-
-/** Accessors to Bonmin options */
-static void GetOptionsFromResourceMap(::Ipopt::SmartPtr<::Ipopt::OptionsList> options)
-{
-//   Get options for Bonmin setup from ResourceMap
-//   See Bonmin/Ipopt user manuals for more details.
-
-  std::vector<String> keys(ResourceMap::GetKeys());
-  const UnsignedInteger nbKeys = keys.size();
-
-  for (UnsignedInteger i = 0; i < nbKeys; ++i)
-    if (keys[i].substr(0, 7) == "Bonmin-")
-    {
-      String optionName(keys[i].substr(7));
-      String type(ResourceMap::GetType(keys[i]));
-      Bool ok = false;
-      if (type == "str")
-        ok = options->SetStringValue(optionName, ResourceMap::GetAsString(keys[i]));
-      else if (type == "float")
-        ok = options->SetNumericValue(optionName, ResourceMap::GetAsScalar(keys[i]));
-      else if (type == "int")
-        ok = options->SetIntegerValue(optionName, ResourceMap::GetAsUnsignedInteger(keys[i]));
-      else if (type == "bool")
-        ok = options->SetStringValue(optionName, ResourceMap::GetAsBool(keys[i]) ? "yes" : "no");
-      if (!ok)
-        throw InvalidArgumentException(HERE) << "Invalid Bonmin option " << optionName;
-    }
-}
-
-#endif
-
 /** Performs the actual computation. */
 void Bonmin::run()
 {
-#ifdef OPENTURNS_HAVE_BONMIN
-  // Check problem
-  checkProblem(getProblem());
-
-  // Check starting point
-  if (getStartingPoint().getDimension() != getProblem().getDimension())
-    throw InvalidArgumentException(HERE) << "Invalid starting point dimension (" << getStartingPoint().getDimension() << "), expected " << getProblem().getDimension();
-
   // Create BonminProblem
-  std::chrono::steady_clock::time_point t0 = std::chrono::steady_clock::now();
-  Ipopt::SmartPtr<BonminProblem> tminlp = new BonminProblem(getProblem(), getStartingPoint(), getMaximumCallsNumber(), getMaximumTimeDuration(), t0);
-  tminlp->setProgressCallback(progressCallback_.first, progressCallback_.second);
-  tminlp->setStopCallback(stopCallback_.first, stopCallback_.second);
+  Ipopt::SmartPtr<BonminProblem> tminlp = new BonminProblem();
 
   // Create setup, initialize options
   ::Bonmin::BonminSetup app;
   app.initializeOptionsAndJournalist();
-  if (!app.options()->SetStringValue("bonmin.algorithm", algoName_))
-    throw InvalidArgumentException(HERE) << "Bonmin: Invalid parameter for bonmin.algorithm";
-  if (!app.options()->SetIntegerValue("bonmin.iteration_limit", getMaximumIterationNumber()))
-    throw InvalidArgumentException(HERE) << "Bonmin: Invalid parameter for bonmin.iteration_limit";
-  if (getMaximumTimeDuration() > 0.0)
-    app.options()->SetNumericValue("bonmin.time_limit", getMaximumTimeDuration());
-  if (!app.options()->SetStringValue("sb", "yes"))
-    throw InvalidArgumentException(HERE) << "Bonmin: Invalid parameter for sb";
-  if (!app.options()->SetIntegerValue("print_level", 0))
-    throw InvalidArgumentException(HERE) << "Bonmin: Invalid parameter for print_level";
-  if (!app.options()->SetStringValue("honor_original_bounds", "yes"))
-    throw InvalidArgumentException(HERE) << "Bonmin: Invalid parameter for honor_original_bounds";
-  const Description algos = {"bb", "nlp", "lp", "oa", "fp", "milp"};
-  for (UnsignedInteger i = 0; i < algos.getSize(); ++ i)
-    if (!app.options()->SetIntegerValue("bonmin." + algos[i] + "_log_level", 0))
-      throw InvalidArgumentException(HERE) << "Bonmin: Invalid parameter for bonmin." << algos[i] << "_log_level";
-  if (getMaximumConstraintError() > 0.0)
-    app.options()->SetNumericValue("constr_viol_tol", getMaximumConstraintError());
-  else
-    app.options()->SetNumericValue("constr_viol_tol", SpecFunc::MinScalar);
+  app.options()->SetStringValue("bonmin.algorithm", "B-BB");
+  app.options()->SetIntegerValue("bonmin.iteration_limit", 1000);
+  app.options()->SetStringValue("honor_original_bounds", "yes"); 
+  app.options()->SetNumericValue("constr_viol_tol", 1e-5);
   app.options()->SetNumericValue("bound_relax_factor", 0.0);
-  GetOptionsFromResourceMap(app.options());
 
   // Update setup with BonminProblem
   try
@@ -183,71 +123,21 @@ void Bonmin::run()
   }
   catch (::Bonmin::TNLPSolver::UnsolvedError *exc)
   {
-    const Sample inputHistory(tminlp->getInputHistory());
-    setResultFromEvaluationHistory(inputHistory, tminlp->getOutputHistory(),
-                                   getProblem().hasInequalityConstraint() ? getProblem().getInequalityConstraint()(inputHistory) : Sample(),
-                                   getProblem().hasEqualityConstraint() ? getProblem().getEqualityConstraint()(inputHistory) : Sample());
-
-    result_.setStatus(OptimizationResult::FAILURE);
-    std::ostringstream oss;
-    exc->printError(oss);
-    result_.setStatusMessage(oss.str());
     return;
   }
   catch(const ::Bonmin::OsiTMINLPInterface::SimpleError & exc)
   {
-    result_.setStatus(OptimizationResult::FAILURE);
-    result_.setStatusMessage(exc.message());
     return;
   }
   catch(const CoinError & exc)
   {
-    result_.setStatus(OptimizationResult::FAILURE);
-    result_.setStatusMessage(exc.message());
     return;
   }
 
   // print used options
   String optionsLog;
   app.options()->PrintList(optionsLog);
-  LOGINFO(optionsLog);
-
-  const Sample inputHistory(tminlp->getInputHistory());
-  setResultFromEvaluationHistory(inputHistory, tminlp->getOutputHistory(),
-                                 getProblem().hasInequalityConstraint() ? getProblem().getInequalityConstraint()(inputHistory) : Sample(),
-                                 getProblem().hasEqualityConstraint() ? getProblem().getEqualityConstraint()(inputHistory) : Sample());
-
-  const ::Bonmin::TMINLP::SolverReturn status = tminlp->getStatus();
-  const Description bonminExitStatus = {"SUCCESS", "INFEASIBLE", "CONTINUOUS_UNBOUNDED",
-                                        "LIMIT_EXCEEDED", "USER_INTERRUPT", "MINLP_ERROR"
-                                       };
-  result_.setStatusMessage(bonminExitStatus[status]);
-  switch (status)
-  {
-    case ::Bonmin::TMINLP::SUCCESS:
-      break;
-    case ::Bonmin::TMINLP::USER_INTERRUPT:
-      result_.setStatus(OptimizationResult::INTERRUPTION);
-      break;
-    default:
-      result_.setStatus(OptimizationResult::FAILURE);
-      break;
-  }
-  if (tminlp->getTimeOut())
-    result_.setStatus(OptimizationResult::TIMEOUT);
-
-  if (result_.getStatus() != OptimizationResult::SUCCESS)
-  {
-    if (getCheckStatus())
-      throw InternalException(HERE) << "Solving problem by Bonmin method failed (" << result_.getStatusMessage() << ")";
-    else
-      LOGWARN(OSS() << "Bonmin algorithm failed. The error message is " << result_.getStatusMessage());
-  }
-#else
-  result_.setStatus(OptimizationResult::FAILURE);
-  throw NotYetImplementedException(HERE) << "No Bonmin support";
-
-#endif
+  std::cout << optionsLog << std::endl;
 }
 
 
diff --git a/lib/src/Base/Optim/CMakeLists.txt b/lib/src/Base/Optim/CMakeLists.txt
index d61e05a7d..d4d9287f6 100644
--- a/lib/src/Base/Optim/CMakeLists.txt
+++ b/lib/src/Base/Optim/CMakeLists.txt
@@ -9,9 +9,7 @@ ot_add_source_file (Bonmin.cxx)
 ot_add_source_file (Ceres.cxx)
 ot_add_source_file (CMinpack.cxx)
 ot_add_source_file (Cobyla.cxx)
-if (OPENTURNS_HAVE_BONMIN)
-  ot_add_source_file (BonminProblem.cxx)
-endif ()
+
 ot_add_source_file (Dlib.cxx)
 if (dlib_FOUND)
   ot_add_source_file (DlibFunctions.cxx)
diff --git a/lib/src/Base/Optim/Pagmo.cxx b/lib/src/Base/Optim/Pagmo.cxx
index 6a9fc2482..8ef033f67 100644
--- a/lib/src/Base/Optim/Pagmo.cxx
+++ b/lib/src/Base/Optim/Pagmo.cxx
@@ -23,7 +23,7 @@
 #include "openturns/SpecFunc.hxx"
 #include "openturns/OTconfig.hxx"
 #include "openturns/DatabaseFunction.hxx"
-#include "openturns/BootstrapExperiment.hxx"
+// #include "openturns/BootstrapExperiment.hxx"
 
 #ifdef OPENTURNS_HAVE_PAGMO
 #include <pagmo/algorithm.hpp>
diff --git a/lib/src/Base/Optim/openturns/BonminProblem.hxx b/lib/src/Base/Optim/openturns/BonminProblem.hxx
index 79af481e0..baf7bac4f 100644
--- a/lib/src/Base/Optim/openturns/BonminProblem.hxx
+++ b/lib/src/Base/Optim/openturns/BonminProblem.hxx
@@ -44,43 +44,78 @@ class BonminProblem
 public:
 
   /** Constructor with parameters */
-  BonminProblem( const OptimizationProblem & optimProblem,
-                 const Point & startingPoint,
-                 const UnsignedInteger maximumCallsNumber,
-                 const Scalar maximumTimeDuration,
-                 const std::chrono::steady_clock::time_point & t0);
-
-  /** Retrieving objective function input.output history */
-  Sample getInputHistory() const;
-  Sample getOutputHistory() const;
-
-  /** Overloading functions from Bonmin::TMINLP
-   See BonTMINLP.hpp for description */
+  BonminProblem()
+  : ::Bonmin::TMINLP()
+{
 
-  // n: number of variables
-  // m: number of constraints
+}
 
   bool get_nlp_info(int & n,
                     int & m,
                     int & nnz_jac_g, // Number of non-zero components in the Jacobian of g
                     int & nnz_h_lag, // Number of non-zero components in Hessian of Lagrangean
-                    ::Ipopt::TNLP::IndexStyleEnum & index_style);
+                    ::Ipopt::TNLP::IndexStyleEnum & index_style)
+  {
+    m = 3;
+    n = 4;
+    
+    // All components of the jacobian and lagrangian's hessian are assumed to be non-zero
+    nnz_jac_g = n * m;
+    nnz_h_lag = n * n;
+
+    // Index style is C-like
+    index_style = ::Ipopt::TNLP::C_STYLE;
+
+    return true;
+  }
 
   bool get_variables_types( int n,
-                            VariableTypeTable var_types);
+                            VariableTypeTable var_types)
+  {
+    var_types[0] = ::Bonmin::TMINLP::BINARY;
+    var_types[1] = ::Bonmin::TMINLP::CONTINUOUS;
+    var_types[2] = ::Bonmin::TMINLP::CONTINUOUS;
+    var_types[3] = ::Bonmin::TMINLP::INTEGER;
+    return true;
+  }
 
   bool get_variables_linearity( int n,
-                                LinearityTypeTable var_types);
-
-  bool get_constraints_linearity( int m,
-                                  LinearityTypeTable const_types);
+                                LinearityTypeTable var_types)
+  {
+    var_types[0] = ::Ipopt::TNLP::LINEAR;
+    var_types[1] = ::Ipopt::TNLP::NON_LINEAR;
+    var_types[2] = ::Ipopt::TNLP::NON_LINEAR;
+    var_types[3] = ::Ipopt::TNLP::LINEAR;
+    return true;
+  }
 
+  bool get_constraints_linearity( int m, LinearityTypeTable const_types)
+  {
+    return true;
+  }
   bool get_bounds_info( int n,
                         double* x_l,  // Lower bounds
                         double* x_u,  // Upper bounds
                         int m,
                         double* g_l,  // Lower bounds
-                        double* g_u); // Upper bounds
+                        double* g_u) // Upper bounds
+  {
+    for (int i = 0; i < n; ++i)
+    {
+      x_l[i] = 0.0;
+      x_u[i] = std::numeric_limits<double>::max();
+    }
+    x_u[0] = 1.0;  
+    x_u[3] = 5.0;
+
+    for (UnsignedInteger i = 0; i < 3; ++i)
+    {
+      g_l[i] = 0.0;   // OT constraints are expressed as g(x) = 0 and h(x) >= 0
+      g_u[i] = std::numeric_limits<double>::max();
+    }
+
+    return true;
+  }
 
   bool get_starting_point(int n,
                           bool init_x,
@@ -90,24 +125,46 @@ public:
                           double* z_U,
                           int m,
                           bool init_lambda,
-                          double* lambda);
-
+                          double* lambda)
+  {
+    for (int i=0;i <4; ++i)
+      x[i] = 0.0;
+    return true;
+  }
   bool eval_f(int n,
               const double* x,
               bool new_x,
-              double& obj_value);
+              double& obj_value)
+  {
+    obj_value = -x[0] -x[1] -x[2];
 
+    static int ncalls = 0;
+    ++ ncalls;
+    return ncalls <= 10000;
+  }
   bool eval_grad_f( int n,
                     const double* x,
                     bool new_x,
-                    double* grad_f);
+                    double* grad_f)
+  {
 
+    grad_f[0] = -1.0;
+  grad_f[1] = -1.0;
+  grad_f[2] = -1.0;
+    return true;
+  }
   bool eval_g(int n,
               const double* x,
               bool new_x,
               int m,
-              double* g);
-
+              double* g)
+  {
+    g[0] = -(x[1] - 0.5)*(x[1] - 0.5) - (x[2] - 0.5)*(x[2] - 0.5) + 0.25;
+      g[1] = -x[0] +x[1];
+      g[2] = -x[0] -x[2]-x[3] + 2.0;
+    
+    return true;
+  }
   bool eval_jac_g(int n,
                   const double* x,
                   bool new_x,
@@ -115,8 +172,36 @@ public:
                   int nele_jac,
                   int* iRow,
                   int *jCol,
-                  double* values);
-
+                  double* values)
+  {
+    /* Switch on first call / later calls */
+    if (values == NULL)
+    {
+      // First call: initialization of iRow/jCol
+      int k = 0;
+      for (int i = 0; i < m; ++i)
+        for (int j = 0; j < n; ++j)
+        {
+          iRow[k] = i;
+          jCol[k] = j;
+          ++k;
+        }
+    }
+    else     // Later calls
+    {
+      for (int i = 0; i < 12; ++i)
+        values[i] = 0.0;
+      values[1] = -2.0*(x[1]-0.5);
+      values[2] = -2.0*(x[2]-0.5);
+      values[4] = -1.0;
+      values[5] = 1.0;
+      values[8] = -1.0;
+      values[10] = -1.0;
+      values[11] = -1.0;
+    }
+
+    return true;
+  }
   bool eval_h(int n,
               const double* x,
               bool new_x,
@@ -127,26 +212,78 @@ public:
               int nele_hess,
               int* iRow,
               int* jCol,
-              double* values);
-
+              double* values)
+  {
+    /* Switch on first call / later calls */
+    if (values == NULL) // First call: initialization of iRow/jCol
+    {
+      int k = 0;
+      for (int i = 0; i < n; ++i)
+        for (int j = 0; j < n; ++j)
+        {
+          iRow[k] = i;
+          jCol[k] = j;
+          ++k;
+        }
+    }
+    else // Later calls
+    {
+      int k = 0;
+      for (int i = 0; i < n; ++i)
+        for (int j = 0; j < n; ++j)
+        {
+          values[k] = 0.0;
+          ++k;
+        }
+      values[5] = -2.0 * lambda[0];
+      values[10] = -2.0 * lambda[0];
+    }
+
+    return true;
+  }
   bool eval_gi(int n,
                const double* x,
                bool new_x,
                int i,
-               double& gi);
-
+               double& gi)
+  {
+    if (i == 0)
+      gi = -(x[1] - 0.5)*(x[1] - 0.5) - (x[2] - 0.5)*(x[2] - 0.5) + 0.25;
+    if (i == 1)
+      gi = -x[0] +x[1];
+    if (i == 2)
+      gi = -x[0] -x[2]-x[3] + 2.0;
+    return true;
+  }
   bool eval_grad_gi(int n,
                     const double* x,
                     bool new_x,
                     int i,
                     int& nele_grad_gi,
                     int* jCol,
-                    double* values);
-
+                    double* values)
+  {
+    // Computing constraint derivative
+    nele_grad_gi = n;
+
+    if (values == NULL) // First call
+      for (int j = 0; j < n; ++j)
+        jCol[j] = j;
+    else
+    {
+      // not implemented
+      for (int j = 0; j < n; ++ j)
+        values[j] = 0.0;
+    }
+    return true;
+  }
   void finalize_solution( ::Bonmin::TMINLP::SolverReturn status,
                           ::Ipopt::Index n,
                           const ::Ipopt::Number* x,
-                          ::Ipopt::Number obj_value);
+                          ::Ipopt::Number obj_value)
+  {
+    status_ = status;
+  }
 
   const ::Bonmin::TMINLP::BranchingInfo * branchingInfo() const
   {
@@ -163,38 +300,11 @@ public:
     return status_;
   }
 
-  Bool getTimeOut() const
-  {
-    return timeOut_;
-  }
-
-  virtual void setProgressCallback(OptimizationAlgorithmImplementation::ProgressCallback callBack, void * state = nullptr)
-  {
-    progressCallback_ = std::pair<OptimizationAlgorithmImplementation::ProgressCallback, void *>(callBack, state);
-  }
-
-  virtual void setStopCallback(OptimizationAlgorithmImplementation::StopCallback callBack, void * state = nullptr)
-  {
-    stopCallback_ = std::pair<OptimizationAlgorithmImplementation::StopCallback, void *>(callBack, state);
-  }
 
 
 private:
-  // Clip point wrt problem bounds
-  void clip(Point & xPoint) const;
-
-  const OptimizationProblem optimProblem_;
-  const Point startingPoint_;
-  Sample evaluationInputHistory_;
-  Sample evaluationOutputHistory_;
   ::Bonmin::TMINLP::SolverReturn status_;
-  // Callbacks
-  UnsignedInteger maximumCallsNumber_ = 0;
-  Scalar maximumTimeDuration_ = 0.0;
-  Bool timeOut_ = false;
-  std::chrono::steady_clock::time_point t0_;
-  std::pair< OptimizationAlgorithmImplementation::ProgressCallback, void *> progressCallback_;
-  std::pair< OptimizationAlgorithmImplementation::StopCallback, void *> stopCallback_;
+
 };
 
 END_NAMESPACE_OPENTURNS
diff --git a/lib/src/Base/openturns/OTBase.hxx b/lib/src/Base/openturns/OTBase.hxx
index 5fc788d0a..2aef4ce8b 100644
--- a/lib/src/Base/openturns/OTBase.hxx
+++ b/lib/src/Base/openturns/OTBase.hxx
@@ -34,6 +34,6 @@
 #include "openturns/OTStat.hxx"
 #include "openturns/OTType.hxx"
 #include "openturns/OTAlgo.hxx"
-#include "openturns/OTIterativeStat.hxx"
+// #include "openturns/OTIterativeStat.hxx"
 
 #endif /* OPENTURNS_OTBASE_HXX */
diff --git a/lib/src/CMakeLists.txt b/lib/src/CMakeLists.txt
index 2c8b587a5..ae255a4c1 100644
--- a/lib/src/CMakeLists.txt
+++ b/lib/src/CMakeLists.txt
@@ -7,7 +7,7 @@ ot_add_source_file (openturns_library_ok.c)
 
 # Recurse in subdirectories
 add_subdirectory (Base)
-add_subdirectory (Uncertainty)
+# add_subdirectory (Uncertainty)
 
 set_source_files_properties (Base/Func/SpecFunc/Faddeeva.cc PROPERTIES SKIP_UNITY_BUILD_INCLUSION ON)
 
diff --git a/lib/src/openturns/OT.hxx b/lib/src/openturns/OT.hxx
index 42e3942d9..8e9c9693a 100644
--- a/lib/src/openturns/OT.hxx
+++ b/lib/src/openturns/OT.hxx
@@ -49,6 +49,6 @@
  * @todo List the classes belonging to the external API of OpenTURNS
  */
 #include "openturns/OTBase.hxx"
-#include "openturns/OTUncertainty.hxx"
+// #include "openturns/OTUncertainty.hxx"
 
 #endif /* OPENTURNS_OT_HXX */
diff --git a/lib/test/CMakeLists.txt b/lib/test/CMakeLists.txt
index ccf74e675..14449baac 100644
--- a/lib/test/CMakeLists.txt
+++ b/lib/test/CMakeLists.txt
@@ -193,7 +193,10 @@ if (dlib_FOUND)
   ot_check_test (Dlib_global IGNOREOUT)
 endif()
 if (Bonmin_FOUND)
-  ot_check_test (Bonmin_std IGNOREOUT)
+  # ot_check_test (Bonmin_std IGNOREOUT)
+  add_executable(t_Bonmin_std t_Bonmin_std.cxx)
+  target_include_directories(t_Bonmin_std PRIVATE ${COIN_INCLUDE_DIRS} ${IPOPT_INCLUDE_DIRS})
+  target_link_libraries(t_Bonmin_std PRIVATE ${COIN_BONMIN_LIBRARIES})
 endif()
 
 ot_check_test (SQP_std)
diff --git a/lib/test/t_Bonmin_std.cxx b/lib/test/t_Bonmin_std.cxx
index 02fdffeac..9980190dd 100644
--- a/lib/test/t_Bonmin_std.cxx
+++ b/lib/test/t_Bonmin_std.cxx
@@ -1,136 +1,298 @@
-//                                               -*- C++ -*-
-/**
- *  @brief The test file of class Bonmin
- *
- *  Copyright 2005-2024 Airbus-EDF-IMACS-ONERA-Phimeca
- *
- *  This library is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public License
- *  along with this library.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-#include "openturns/OT.hxx"
-#include "openturns/OTtestcode.hxx"
-#include <float.h>
-
-using namespace OT;
-using namespace OT::Test;
-
-void debug(const String & message,
-           const String & where)
-{
-  std::cout << " DEBUG [" << where << "]: " << message << std::endl;
-}
 
+#include <BonBonminSetup.hpp>
+#include <BonCbc.hpp>
+#include <BonminConfig.h>
+#include <BonTMINLP.hpp>
+#include <IpTNLP.hpp>
 
-int main()
+typedef ::Bonmin::TMINLP::VariableType * VariableTypeTable;
+typedef ::Ipopt::TNLP::LinearityType * LinearityTypeTable;
+
+
+class MyTMINLP
+  : public ::Bonmin::TMINLP
 {
-  TESTPREAMBLE;
-  OStream fullprint(std::cout);
+public:
 
-  try
+  /** Constructor with parameters */
+  MyTMINLP() : ::Bonmin::TMINLP() {}
+
+  bool get_nlp_info(int & n,
+                    int & m,
+                    int & nnz_jac_g, // Number of non-zero components in the Jacobian of g
+                    int & nnz_h_lag, // Number of non-zero components in Hessian of Lagrangean
+                    ::Ipopt::TNLP::IndexStyleEnum & index_style)
+  {
+    m = 3;
+    n = 4;
+    
+    // All components of the jacobian and lagrangian's hessian are assumed to be non-zero
+    nnz_jac_g = n * m;
+    nnz_h_lag = n * n;
+
+    // Index style is C-like
+    index_style = ::Ipopt::TNLP::C_STYLE;
+    return true;
+  }
+
+  bool get_variables_types( int n,
+                            VariableTypeTable var_types)
+  {
+    var_types[0] = ::Bonmin::TMINLP::BINARY;
+    var_types[1] = ::Bonmin::TMINLP::CONTINUOUS;
+    var_types[2] = ::Bonmin::TMINLP::CONTINUOUS;
+    var_types[3] = ::Bonmin::TMINLP::INTEGER;
+    return true;
+  }
+
+  bool get_variables_linearity( int n,
+                                LinearityTypeTable var_types)
+  {
+    var_types[0] = ::Ipopt::TNLP::LINEAR;
+    var_types[1] = ::Ipopt::TNLP::NON_LINEAR;
+    var_types[2] = ::Ipopt::TNLP::NON_LINEAR;
+    var_types[3] = ::Ipopt::TNLP::LINEAR;
+    return true;
+  }
+
+  bool get_constraints_linearity( int m, LinearityTypeTable const_types)
   {
-    /* TEST ON SIMPLE FUNCTION */
-
-    // Definition of objective function
-    const Description inputVariables = {"x0", "x1", "x2", "x3"};
-    Description objective(1, "-x0 -x1 -x2");
-    SymbolicFunction objectiveFunction(inputVariables, objective);
-
-    // Definition of bounds
-    Point variablesLowerBounds(4);
-    Point variablesUpperBounds(4);
-    Collection<UnsignedInteger> variablesFiniteLowerBounds(4, 1);
-    Collection<UnsignedInteger> variablesFiniteUpperBounds(4, 1);
-    variablesLowerBounds[0] = 0;
-    variablesUpperBounds[0] = 1;
-
-    variablesLowerBounds[1] = 0;
-    variablesUpperBounds[1] = DBL_MAX;
-    variablesFiniteUpperBounds[1] = 0;
-
-    variablesLowerBounds[2] = 0;
-    variablesUpperBounds[2] = DBL_MAX;
-    variablesFiniteUpperBounds[2] = 0;
-
-    variablesLowerBounds[3] = 0;
-    variablesUpperBounds[3] = 5;
-    Interval variablesBounds(variablesLowerBounds, variablesUpperBounds, variablesFiniteLowerBounds, variablesFiniteUpperBounds) ;
-
-    // Definition of inequality constraints:
-    // Bonmin constraints are defined as g_l <= g(x) <= g_u
-    // OpenTURNS' are defined as g(x) >= 0
-    Description inequalityFormulas(3);
-    inequalityFormulas[0] = "-(x1 - 1/2)^2 - (x2 - 1/2)^2 + 1/4";
-    inequalityFormulas[1] = "-x0 + x1";
-    inequalityFormulas[2] = "-x0 - x2 - x3 + 2";
-    SymbolicFunction inequalityConstraints(inputVariables, inequalityFormulas);
-
-    // Definition of variables types
-    Indices varTypes(4);
-    varTypes[0] = OT::OptimizationProblemImplementation::BINARY;
-    varTypes[1] = OT::OptimizationProblemImplementation::CONTINUOUS;
-    varTypes[2] = OT::OptimizationProblemImplementation::CONTINUOUS;
-    varTypes[3] = OT::OptimizationProblemImplementation::INTEGER;
-
-    // Definition of OptimizationProblem
-    OptimizationProblem problem(objectiveFunction);
-    problem.setBounds(variablesBounds);
-    problem.setVariablesType(varTypes);
-    problem.setInequalityConstraint(inequalityConstraints);
-
-    // Running Bonmin algorithm
-    Bonmin bonminAlgorithm(problem);
-    bonminAlgorithm.setStartingPoint(Point(4, 0));
-    bonminAlgorithm.setMaximumCallsNumber(10000);
-    bonminAlgorithm.setMaximumIterationNumber(1000);
-
-    // Test __repr__ method
-    std::cout << bonminAlgorithm.__repr__() << std::endl;
-
-
-    // Defining reference solution
-    const Point referenceSolution = {1.0, 1.0, 0.5, 0.0};
-
-    // Defining solvers to test
-    const Description solvers(Bonmin::GetAlgorithmNames());
-
-    for (UnsignedInteger i = 0; i < solvers.getSize(); ++i)
+    return true;
+  }
+  bool get_bounds_info( int n,
+                        double* x_l,
+                        double* x_u,
+                        int m,
+                        double* g_l,
+                        double* g_u)
+  {
+    for (int i = 0; i < n; ++i)
+    {
+      x_l[i] = 0.0;
+      x_u[i] = std::numeric_limits<double>::max();
+    }
+    x_u[0] = 1.0;  
+    x_u[3] = 5.0;
+
+    for (int i = 0; i < 3; ++i)
     {
-      // Set solver
-      bonminAlgorithm.setAlgorithmName(solvers[i]);
-      std::cout << " == TEST WITH " << bonminAlgorithm.getAlgorithmName() << " SOLVER:" << std::endl;
-
-      // Run the solver
-      bonminAlgorithm.run();
-
-      // Retrieve solution
-      OptimizationResult result(bonminAlgorithm.getResult());
-      std::cout << " -- Optimal point = " << result.getOptimalPoint() << std::endl;
-      std::cout << " -- Optimal value = " << result.getOptimalValue() << std::endl;
-      std::cout << " -- Evaluation num = " << result.getInputSample().getSize() << std::endl;
-
-      // Check result
-      assert_almost_equal(result.getOptimalPoint(), referenceSolution, 1e-2);
-      std::cout << " => TEST " << bonminAlgorithm.getAlgorithmName() << " PASSED" << std::endl << std::endl;
+      g_l[i] = 0.0;   // OT constraints are expressed as g(x) = 0 and h(x) >= 0
+      g_u[i] = std::numeric_limits<double>::max();
     }
+
+    return true;
+  }
+
+  bool get_starting_point(int n,
+                          bool init_x,
+                          double* x,
+                          bool init_z,
+                          double* z_L,
+                          double* z_U,
+                          int m,
+                          bool init_lambda,
+                          double* lambda)
+  {
+    for (int i=0;i <4; ++i)
+      x[i] = 0.0;
+    return true;
+  }
+  bool eval_f(int n,
+              const double* x,
+              bool new_x,
+              double& obj_value)
+  {
+    obj_value = -x[0] -x[1] -x[2];
+
+    static int ncalls = 0;
+    ++ ncalls;
+    return ncalls <= 10000;
+  }
+  bool eval_grad_f( int n,
+                    const double* x,
+                    bool new_x,
+                    double* grad_f)
+  {
+
+    grad_f[0] = -1.0;
+  grad_f[1] = -1.0;
+  grad_f[2] = -1.0;
+    return true;
   }
+  bool eval_g(int n,
+              const double* x,
+              bool new_x,
+              int m,
+              double* g)
+  {
+    g[0] = -(x[1] - 0.5)*(x[1] - 0.5) - (x[2] - 0.5)*(x[2] - 0.5) + 0.25;
+    g[1] = -x[0] +x[1];
+    g[2] = -x[0] -x[2]-x[3] + 2.0;
+    return true;
+  }
+
+  bool eval_jac_g(int n,
+                  const double* x,
+                  bool new_x,
+                  int m,
+                  int nele_jac,
+                  int* iRow,
+                  int *jCol,
+                  double* values)
+  {
+    /* Switch on first call / later calls */
+    if (values == NULL)
+    {
+      // First call: initialization of iRow/jCol
+      int k = 0;
+      for (int i = 0; i < m; ++i)
+        for (int j = 0; j < n; ++j)
+        {
+          iRow[k] = i;
+          jCol[k] = j;
+          ++k;
+        }
+    }
+    else     // Later calls
+    {
+      for (int i = 0; i < 12; ++i)
+        values[i] = 0.0;
+      values[1] = -2.0*(x[1]-0.5);
+      values[2] = -2.0*(x[2]-0.5);
+      values[4] = -1.0;
+      values[5] = 1.0;
+      values[8] = -1.0;
+      values[10] = -1.0;
+      values[11] = -1.0;
+    }
 
-  catch (TestFailed & ex)
+    return true;
+  }
+  bool eval_h(int n,
+              const double* x,
+              bool new_x,
+              double obj_factor,
+              int m,
+              const double* lambda,
+              bool new_lambda,
+              int nele_hess,
+              int* iRow,
+              int* jCol,
+              double* values)
+  {
+    /* Switch on first call / later calls */
+    if (values == NULL) // First call: initialization of iRow/jCol
+    {
+      int k = 0;
+      for (int i = 0; i < n; ++i)
+        for (int j = 0; j < n; ++j)
+        {
+          iRow[k] = i;
+          jCol[k] = j;
+          ++k;
+        }
+    }
+    else // Later calls
+    {
+      int k = 0;
+      for (int i = 0; i < n; ++i)
+        for (int j = 0; j < n; ++j)
+        {
+          values[k] = 0.0;
+          ++k;
+        }
+      values[5] = -2.0 * lambda[0];
+      values[10] = -2.0 * lambda[0];
+    }
+
+    return true;
+  }
+  bool eval_gi(int n,
+               const double* x,
+               bool new_x,
+               int i,
+               double& gi)
+  {
+    return true;
+  }
+
+  bool eval_grad_gi(int n,
+                    const double* x,
+                    bool new_x,
+                    int i,
+                    int& nele_grad_gi,
+                    int* jCol,
+                    double* values)
+  {
+    return true;
+  }
+
+  void finalize_solution( ::Bonmin::TMINLP::SolverReturn status,
+                          ::Ipopt::Index n,
+                          const ::Ipopt::Number* x,
+                          ::Ipopt::Number obj_value)
+  {
+    status_ = status;
+  }
+
+  const ::Bonmin::TMINLP::BranchingInfo * branchingInfo() const
+  {
+    return NULL;
+  };
+
+  const ::Bonmin::TMINLP::SosInfo * sosConstraints() const
+  {
+    return NULL;
+  };
+
+  ::Bonmin::TMINLP::SolverReturn getStatus() const
+  {
+    return status_;
+  }
+
+
+
+private:
+  ::Bonmin::TMINLP::SolverReturn status_;
+
+};
+
+int main()
+{
+  ::Ipopt::SmartPtr<MyTMINLP> tminlp = new MyTMINLP();
+  ::Bonmin::BonminSetup app;
+  app.initializeOptionsAndJournalist();
+  app.options()->SetStringValue("bonmin.algorithm", "B-BB");
+  app.options()->SetStringValue("honor_original_bounds", "yes"); 
+  app.options()->SetNumericValue("constr_viol_tol", 1e-5);
+  app.options()->SetNumericValue("bound_relax_factor", 0.0);
+
+  // Update setup with MyTMINLP
+  try
+  {
+    app.initialize(GetRawPtr(tminlp));
+
+    // Solve problem
+    ::Bonmin::Bab solver;
+    solver(app);
+  }
+  catch (::Bonmin::TNLPSolver::UnsolvedError *exc)
+  {
+    return 1;
+  }
+  catch(const ::Bonmin::OsiTMINLPInterface::SimpleError & exc)
+  {
+    return 1;
+  }
+  catch(const CoinError & exc)
   {
-    std::cerr << ex << std::endl;
-    return ExitCode::Error;
+    return 1;
   }
 
+  // print used options
+  std::string optionsLog;
+  app.options()->PrintList(optionsLog);
+  std::cout << optionsLog << std::endl;
 
-  return ExitCode::Success;
+  return 0;
 }
