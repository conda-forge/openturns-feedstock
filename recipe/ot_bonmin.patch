diff --git a/lib/test/CMakeLists.txt b/lib/test/CMakeLists.txt
index ccf74e675..14449baac 100644
--- a/lib/test/CMakeLists.txt
+++ b/lib/test/CMakeLists.txt
@@ -193,7 +193,10 @@ if (dlib_FOUND)
   ot_check_test (Dlib_global IGNOREOUT)
 endif()
 if (Bonmin_FOUND)
-  ot_check_test (Bonmin_std IGNOREOUT)
+  # ot_check_test (Bonmin_std IGNOREOUT)
+  add_executable(t_Bonmin_std t_Bonmin_std.cxx)
+  target_include_directories(t_Bonmin_std PRIVATE ${COIN_INCLUDE_DIRS} ${IPOPT_INCLUDE_DIRS})
+  target_link_libraries(t_Bonmin_std PRIVATE ${COIN_BONMIN_LIBRARIES})
 endif()
 
 ot_check_test (SQP_std)
diff --git a/lib/test/t_Bonmin_std.cxx b/lib/test/t_Bonmin_std.cxx
index 02fdffeac..ce15ddc79 100644
--- a/lib/test/t_Bonmin_std.cxx
+++ b/lib/test/t_Bonmin_std.cxx
@@ -1,136 +1,298 @@
-//                                               -*- C++ -*-
-/**
- *  @brief The test file of class Bonmin
- *
- *  Copyright 2005-2024 Airbus-EDF-IMACS-ONERA-Phimeca
- *
- *  This library is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public License
- *  along with this library.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-#include "openturns/OT.hxx"
-#include "openturns/OTtestcode.hxx"
-#include <float.h>
-
-using namespace OT;
-using namespace OT::Test;
-
-void debug(const String & message,
-           const String & where)
-{
-  std::cout << " DEBUG [" << where << "]: " << message << std::endl;
-}
 
+#include <BonBonminSetup.hpp>
+#include <BonCbc.hpp>
+#include <BonminConfig.h>
+#include <BonTMINLP.hpp>
+#include <IpTNLP.hpp>
 
-int main()
+typedef ::Bonmin::TMINLP::VariableType * VariableTypeTable;
+typedef ::Ipopt::TNLP::LinearityType * LinearityTypeTable;
+
+
+class MyTMINLP
+  : public ::Bonmin::TMINLP
 {
-  TESTPREAMBLE;
-  OStream fullprint(std::cout);
+public:
 
-  try
+  /** Constructor with parameters */
+  MyTMINLP() : ::Bonmin::TMINLP() {}
+
+  bool get_nlp_info(int & n,
+                    int & m,
+                    int & nnz_jac_g, // Number of non-zero components in the Jacobian of g
+                    int & nnz_h_lag, // Number of non-zero components in Hessian of Lagrangean
+                    ::Ipopt::TNLP::IndexStyleEnum & index_style)
+  {
+    m = 3;
+    n = 4;
+    
+    // All components of the jacobian and lagrangian's hessian are assumed to be non-zero
+    nnz_jac_g = n * m;
+    nnz_h_lag = n * n;
+
+    // Index style is C-like
+    index_style = ::Ipopt::TNLP::C_STYLE;
+    return true;
+  }
+
+  bool get_variables_types( int n,
+                            VariableTypeTable var_types)
+  {
+    var_types[0] = ::Bonmin::TMINLP::BINARY;
+    var_types[1] = ::Bonmin::TMINLP::CONTINUOUS;
+    var_types[2] = ::Bonmin::TMINLP::CONTINUOUS;
+    var_types[3] = ::Bonmin::TMINLP::INTEGER;
+    return true;
+  }
+
+  bool get_variables_linearity( int n,
+                                LinearityTypeTable var_types)
+  {
+    var_types[0] = ::Ipopt::TNLP::LINEAR;
+    var_types[1] = ::Ipopt::TNLP::NON_LINEAR;
+    var_types[2] = ::Ipopt::TNLP::NON_LINEAR;
+    var_types[3] = ::Ipopt::TNLP::LINEAR;
+    return true;
+  }
+
+  bool get_constraints_linearity( int m, LinearityTypeTable const_types)
   {
-    /* TEST ON SIMPLE FUNCTION */
-
-    // Definition of objective function
-    const Description inputVariables = {"x0", "x1", "x2", "x3"};
-    Description objective(1, "-x0 -x1 -x2");
-    SymbolicFunction objectiveFunction(inputVariables, objective);
-
-    // Definition of bounds
-    Point variablesLowerBounds(4);
-    Point variablesUpperBounds(4);
-    Collection<UnsignedInteger> variablesFiniteLowerBounds(4, 1);
-    Collection<UnsignedInteger> variablesFiniteUpperBounds(4, 1);
-    variablesLowerBounds[0] = 0;
-    variablesUpperBounds[0] = 1;
-
-    variablesLowerBounds[1] = 0;
-    variablesUpperBounds[1] = DBL_MAX;
-    variablesFiniteUpperBounds[1] = 0;
-
-    variablesLowerBounds[2] = 0;
-    variablesUpperBounds[2] = DBL_MAX;
-    variablesFiniteUpperBounds[2] = 0;
-
-    variablesLowerBounds[3] = 0;
-    variablesUpperBounds[3] = 5;
-    Interval variablesBounds(variablesLowerBounds, variablesUpperBounds, variablesFiniteLowerBounds, variablesFiniteUpperBounds) ;
-
-    // Definition of inequality constraints:
-    // Bonmin constraints are defined as g_l <= g(x) <= g_u
-    // OpenTURNS' are defined as g(x) >= 0
-    Description inequalityFormulas(3);
-    inequalityFormulas[0] = "-(x1 - 1/2)^2 - (x2 - 1/2)^2 + 1/4";
-    inequalityFormulas[1] = "-x0 + x1";
-    inequalityFormulas[2] = "-x0 - x2 - x3 + 2";
-    SymbolicFunction inequalityConstraints(inputVariables, inequalityFormulas);
-
-    // Definition of variables types
-    Indices varTypes(4);
-    varTypes[0] = OT::OptimizationProblemImplementation::BINARY;
-    varTypes[1] = OT::OptimizationProblemImplementation::CONTINUOUS;
-    varTypes[2] = OT::OptimizationProblemImplementation::CONTINUOUS;
-    varTypes[3] = OT::OptimizationProblemImplementation::INTEGER;
-
-    // Definition of OptimizationProblem
-    OptimizationProblem problem(objectiveFunction);
-    problem.setBounds(variablesBounds);
-    problem.setVariablesType(varTypes);
-    problem.setInequalityConstraint(inequalityConstraints);
-
-    // Running Bonmin algorithm
-    Bonmin bonminAlgorithm(problem);
-    bonminAlgorithm.setStartingPoint(Point(4, 0));
-    bonminAlgorithm.setMaximumCallsNumber(10000);
-    bonminAlgorithm.setMaximumIterationNumber(1000);
-
-    // Test __repr__ method
-    std::cout << bonminAlgorithm.__repr__() << std::endl;
-
-
-    // Defining reference solution
-    const Point referenceSolution = {1.0, 1.0, 0.5, 0.0};
-
-    // Defining solvers to test
-    const Description solvers(Bonmin::GetAlgorithmNames());
-
-    for (UnsignedInteger i = 0; i < solvers.getSize(); ++i)
+    return true;
+  }
+  bool get_bounds_info( int n,
+                        double* x_l,
+                        double* x_u,
+                        int m,
+                        double* g_l,
+                        double* g_u)
+  {
+    for (int i = 0; i < n; ++i)
+    {
+      x_l[i] = 0.0;
+      x_u[i] = 1e50;
+    }
+    x_u[0] = 1.0;  
+    x_u[3] = 5.0;
+
+    for (int i = 0; i < 3; ++i)
     {
-      // Set solver
-      bonminAlgorithm.setAlgorithmName(solvers[i]);
-      std::cout << " == TEST WITH " << bonminAlgorithm.getAlgorithmName() << " SOLVER:" << std::endl;
-
-      // Run the solver
-      bonminAlgorithm.run();
-
-      // Retrieve solution
-      OptimizationResult result(bonminAlgorithm.getResult());
-      std::cout << " -- Optimal point = " << result.getOptimalPoint() << std::endl;
-      std::cout << " -- Optimal value = " << result.getOptimalValue() << std::endl;
-      std::cout << " -- Evaluation num = " << result.getInputSample().getSize() << std::endl;
-
-      // Check result
-      assert_almost_equal(result.getOptimalPoint(), referenceSolution, 1e-2);
-      std::cout << " => TEST " << bonminAlgorithm.getAlgorithmName() << " PASSED" << std::endl << std::endl;
+      g_l[i] = 0.0;   // OT constraints are expressed as g(x) = 0 and h(x) >= 0
+      g_u[i] = 1e50;
     }
+
+    return true;
+  }
+
+  bool get_starting_point(int n,
+                          bool init_x,
+                          double* x,
+                          bool init_z,
+                          double* z_L,
+                          double* z_U,
+                          int m,
+                          bool init_lambda,
+                          double* lambda)
+  {
+    for (int i=0;i <4; ++i)
+      x[i] = 0.0;
+    return true;
+  }
+  bool eval_f(int n,
+              const double* x,
+              bool new_x,
+              double& obj_value)
+  {
+    obj_value = -x[0] -x[1] -x[2];
+
+    static int ncalls = 0;
+    ++ ncalls;
+    return ncalls <= 10000;
+  }
+  bool eval_grad_f( int n,
+                    const double* x,
+                    bool new_x,
+                    double* grad_f)
+  {
+
+    grad_f[0] = -1.0;
+  grad_f[1] = -1.0;
+  grad_f[2] = -1.0;
+    return true;
   }
+  bool eval_g(int n,
+              const double* x,
+              bool new_x,
+              int m,
+              double* g)
+  {
+    g[0] = -(x[1] - 0.5)*(x[1] - 0.5) - (x[2] - 0.5)*(x[2] - 0.5) + 0.25;
+    g[1] = -x[0] +x[1];
+    g[2] = -x[0] -x[2]-x[3] + 2.0;
+    return true;
+  }
+
+  bool eval_jac_g(int n,
+                  const double* x,
+                  bool new_x,
+                  int m,
+                  int nele_jac,
+                  int* iRow,
+                  int *jCol,
+                  double* values)
+  {
+    /* Switch on first call / later calls */
+    if (values == NULL)
+    {
+      // First call: initialization of iRow/jCol
+      int k = 0;
+      for (int i = 0; i < m; ++i)
+        for (int j = 0; j < n; ++j)
+        {
+          iRow[k] = i;
+          jCol[k] = j;
+          ++k;
+        }
+    }
+    else     // Later calls
+    {
+      for (int i = 0; i < 12; ++i)
+        values[i] = 0.0;
+      values[1] = -2.0*(x[1]-0.5);
+      values[2] = -2.0*(x[2]-0.5);
+      values[4] = -1.0;
+      values[5] = 1.0;
+      values[8] = -1.0;
+      values[10] = -1.0;
+      values[11] = -1.0;
+    }
 
-  catch (TestFailed & ex)
+    return true;
+  }
+  bool eval_h(int n,
+              const double* x,
+              bool new_x,
+              double obj_factor,
+              int m,
+              const double* lambda,
+              bool new_lambda,
+              int nele_hess,
+              int* iRow,
+              int* jCol,
+              double* values)
+  {
+    /* Switch on first call / later calls */
+    if (values == NULL) // First call: initialization of iRow/jCol
+    {
+      int k = 0;
+      for (int i = 0; i < n; ++i)
+        for (int j = 0; j < n; ++j)
+        {
+          iRow[k] = i;
+          jCol[k] = j;
+          ++k;
+        }
+    }
+    else // Later calls
+    {
+      int k = 0;
+      for (int i = 0; i < n; ++i)
+        for (int j = 0; j < n; ++j)
+        {
+          values[k] = 0.0;
+          ++k;
+        }
+      values[5] = -2.0 * lambda[0];
+      values[10] = -2.0 * lambda[0];
+    }
+
+    return true;
+  }
+  bool eval_gi(int n,
+               const double* x,
+               bool new_x,
+               int i,
+               double& gi)
+  {
+    return true;
+  }
+
+  bool eval_grad_gi(int n,
+                    const double* x,
+                    bool new_x,
+                    int i,
+                    int& nele_grad_gi,
+                    int* jCol,
+                    double* values)
+  {
+    return true;
+  }
+
+  void finalize_solution( ::Bonmin::TMINLP::SolverReturn status,
+                          ::Ipopt::Index n,
+                          const ::Ipopt::Number* x,
+                          ::Ipopt::Number obj_value)
+  {
+    status_ = status;
+  }
+
+  const ::Bonmin::TMINLP::BranchingInfo * branchingInfo() const
+  {
+    return NULL;
+  };
+
+  const ::Bonmin::TMINLP::SosInfo * sosConstraints() const
+  {
+    return NULL;
+  };
+
+  ::Bonmin::TMINLP::SolverReturn getStatus() const
+  {
+    return status_;
+  }
+
+
+
+private:
+  ::Bonmin::TMINLP::SolverReturn status_;
+
+};
+
+int main()
+{
+  ::Ipopt::SmartPtr<MyTMINLP> tminlp = new MyTMINLP();
+  ::Bonmin::BonminSetup app;
+  app.initializeOptionsAndJournalist();
+  app.options()->SetStringValue("bonmin.algorithm", "B-BB");
+  // app.options()->SetStringValue("honor_original_bounds", "yes"); 
+  // app.options()->SetNumericValue("constr_viol_tol", 1e-5);
+  app.options()->SetNumericValue("bound_relax_factor", 0.0);
+
+  // Update setup with MyTMINLP
+  try
+  {
+    app.initialize(GetRawPtr(tminlp));
+
+    // Solve problem
+    ::Bonmin::Bab solver;
+    solver(app);
+  }
+  catch (::Bonmin::TNLPSolver::UnsolvedError *exc)
+  {
+    return 1;
+  }
+  catch(const ::Bonmin::OsiTMINLPInterface::SimpleError & exc)
+  {
+    return 1;
+  }
+  catch(const CoinError & exc)
   {
-    std::cerr << ex << std::endl;
-    return ExitCode::Error;
+    return 1;
   }
 
+  // print used options
+  std::string optionsLog;
+  app.options()->PrintList(optionsLog);
+  std::cout << optionsLog << std::endl;
 
-  return ExitCode::Success;
+  return 0;
 }
