diff --git a/CMakeLists.txt b/CMakeLists.txt
index 685223460..6c466e41c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -9,35 +9,35 @@ set (CMAKE_TRY_COMPILE_CONFIGURATION ${CMAKE_BUILD_TYPE})
 
 project (openturns)
 
-option (USE_BISON                    "Looks for Bison if true and then build parser"                         ON)
-option (USE_CUBA                     "Use Cuba library"                                                      ON)
-option (USE_FLEX                     "Looks for Flex if true and then build lexer"                           ON)
-option (USE_TBB                      "Use Intel Threading Building Blocks library for multithreading"        ON)
+option (USE_BISON                    "Looks for Bison if true and then build parser"                         OFF)
+option (USE_CUBA                     "Use Cuba library"                                                      OFF)
+option (USE_FLEX                     "Looks for Flex if true and then build lexer"                           OFF)
+option (USE_TBB                      "Use Intel Threading Building Blocks library for multithreading"        OFF)
 option (USE_HMAT                     "Use HMat library (enforces GPL license)"                               OFF)
-option (USE_MUPARSER                 "Use muParser library"                                                  ON)
+option (USE_MUPARSER                 "Use muParser library"                                                  OFF)
 option (USE_EXPRTK                   "Use ExprTK library"                                                    ON)
-option (USE_LIBXML2                  "Use LibXml2 for XML support"                                           ON)
-option (USE_HDF5                     "Use HDF5 for high volume storage"                                      ON)
-option (USE_BOOST                    "Use Boost for distribution computation"                                ON)
-option (USE_MPFR                     "Use MPFR for real valued special functions computation"                ON)
-option (USE_MPC                      "Use MPC for complex valued special functions computation"              ON)
-option (USE_SPHINX                   "Use sphinx for documentation"                                          ON)
-option (USE_DOXYGEN                  "Use Doxygen for API documentation"                                     ON)
-option (USE_NLOPT                    "Use NLopt for additional optimization algorithms"                      ON)
-option (USE_CERES                    "Use Ceres Solver for additional optimization algorithms"               ON)
-option (USE_CMINPACK                 "Use CMinpack for additional optimization algorithms"                   ON)
-option (USE_DLIB                     "Use dlib for additional optimization algorithms"                       ON)
+option (USE_LIBXML2                  "Use LibXml2 for XML support"                                           OFF)
+option (USE_HDF5                     "Use HDF5 for high volume storage"                                      OFF)
+option (USE_BOOST                    "Use Boost for distribution computation"                                OFF)
+option (USE_MPFR                     "Use MPFR for real valued special functions computation"                OFF)
+option (USE_MPC                      "Use MPC for complex valued special functions computation"              OFF)
+option (USE_SPHINX                   "Use sphinx for documentation"                                          OFF)
+option (USE_DOXYGEN                  "Use Doxygen for API documentation"                                     OFF)
+option (USE_NLOPT                    "Use NLopt for additional optimization algorithms"                      OFF)
+option (USE_CERES                    "Use Ceres Solver for additional optimization algorithms"               OFF)
+option (USE_CMINPACK                 "Use CMinpack for additional optimization algorithms"                   OFF)
+option (USE_DLIB                     "Use dlib for additional optimization algorithms"                       OFF)
 option (USE_IPOPT                    "Use Ipopt for nonlinear optimization"                                  ON)
 option (USE_BONMIN                   "Use Bonmin for MINLP problems"                                         ON)
-option (USE_PAGMO                    "Use Pagmo for multi-objective optimization"                            ON)
-option (USE_SPECTRA                  "Use Spectra for eigenvalues computation"                               ON)
-option (USE_PRIMESIEVE               "Use primesieve for prime numbers generation"                           ON)
-option (USE_OPENMP                   "Use OpenMP to disable threading"                                       ON)
-option (USE_OPENBLAS                 "Use OpenBLAS to disable threading"                                     ON)
-option (USE_CXX17                    "Use C++17 standard"                                                    ON)
-option (USE_NANOFLANN                "Use nanoflann for Nearest Neighbor search"                             ON)
-
-option (BUILD_PYTHON                 "Build the python module for the library"                               ON)
+option (USE_PAGMO                    "Use Pagmo for multi-objective optimization"                            OFF)
+option (USE_SPECTRA                  "Use Spectra for eigenvalues computation"                               OFF)
+option (USE_PRIMESIEVE               "Use primesieve for prime numbers generation"                           OFF)
+option (USE_OPENMP                   "Use OpenMP to disable threading"                                       OFF)
+option (USE_OPENBLAS                 "Use OpenBLAS to disable threading"                                     OFF)
+option (USE_CXX17                    "Use C++17 standard"                                                    OFF)
+option (USE_NANOFLANN                "Use nanoflann for Nearest Neighbor search"                             OFF)
+
+option (BUILD_PYTHON                 "Build the python module for the library"                               OFF)
 option (BUILD_SHARED_LIBS            "Build shared libraries"                                                ON)
 
 # Defines our own module path
diff --git a/lib/include/openturns/OTtestcode.hxx b/lib/include/openturns/OTtestcode.hxx
index 680a86e49..ac795e71e 100644
--- a/lib/include/openturns/OTtestcode.hxx
+++ b/lib/include/openturns/OTtestcode.hxx
@@ -36,7 +36,7 @@
 #include "openturns/PlatformInfo.hxx"
 #include "openturns/SpecFunc.hxx"
 #include "openturns/TBB.hxx"
-#include "openturns/Distribution.hxx"
+// #include "openturns/Distribution.hxx"
 #include "openturns/Mesh.hxx"
 #include "openturns/Field.hxx"
 #include "openturns/ProcessSample.hxx"
@@ -412,38 +412,6 @@ inline void assert_almost_equal(const Tensor & a, const Tensor & b, const Scalar
     assert_almost_equal(a.getSheet(k), b.getSheet(k), rtol, atol, errMsg);
 }
 
-inline void assert_almost_equal(const Distribution &a, const Distribution &b, const Scalar rtol = 1.0e-5, const Scalar atol = 1.0e-8, const String errMsg = "")
-{
-  if (a.getImplementation()->getClassName() != b.getImplementation()->getClassName())
-    throw InvalidArgumentException(HERE) << "A and B must be the same distribution. A is a " << a.getImplementation()->getClassName() << " whereas B is a " << b.getImplementation()->getClassName();
-
-  if (a.getParameterDimension() != b.getParameterDimension())
-    throw InvalidArgumentException(HERE) << "A and B must have the same number of parameters. A has " << a.getParameterDimension() << " parameters whereas B has " << b.getParameterDimension() << " parameters.";
-
-  assert_almost_equal(a.getParameter(), b.getParameter(), rtol, atol, errMsg);
-}
-
-inline void assert_almost_equal(const Mesh & a, const Mesh & b, const Scalar rtol = 1.0e-5, const Scalar atol = 1.0e-8, const String errMsg = "")
-{
-  assert_almost_equal(a.getVertices(), b.getVertices(), rtol, atol, errMsg);
-  if (a.getSimplices() != b.getSimplices())
-    throw InvalidArgumentException(HERE) << "A and B must have the same simplices";
-}
-
-inline void assert_almost_equal(const Field & a, const Field & b, const Scalar rtol = 1.0e-5, const Scalar atol = 1.0e-8, const String errMsg = "")
-{
-  assert_almost_equal(a.getMesh(), b.getMesh(), rtol, atol, errMsg);
-  assert_almost_equal(a.getValues(), b.getValues(), rtol, atol, errMsg);
-}
-
-inline void assert_almost_equal(const ProcessSample & a, const ProcessSample & b, const Scalar rtol = 1.0e-5, const Scalar atol = 1.0e-8, const String errMsg = "")
-{
-  assert_almost_equal(a.getMesh(), b.getMesh(), rtol, atol, errMsg);
-  if (a.getSize() != b.getSize())
-    throw InvalidArgumentException(HERE) << "A and B must have the same size";
-  for (UnsignedInteger j = 0; j < a.getSize(); ++j)
-    assert_almost_equal(a.getField(j).getValues(), b.getField(j).getValues(), rtol, atol, errMsg);
-}
 
 template <typename T>
 void assert_equal(const T & a, const T & b, const String errMsg = "")
diff --git a/lib/src/Base/CMakeLists.txt b/lib/src/Base/CMakeLists.txt
index ea936172e..3d963dbd3 100644
--- a/lib/src/Base/CMakeLists.txt
+++ b/lib/src/Base/CMakeLists.txt
@@ -17,4 +17,4 @@ add_subdirectory (Optim)
 add_subdirectory (Solver)
 add_subdirectory (Stat)
 add_subdirectory (Type)
-add_subdirectory (IterativeStat)
+# add_subdirectory (IterativeStat)
diff --git a/lib/src/Base/Optim/BonminProblem.cxx b/lib/src/Base/Optim/BonminProblem.cxx
index 147ddd9ad..b1c8de708 100644
--- a/lib/src/Base/Optim/BonminProblem.cxx
+++ b/lib/src/Base/Optim/BonminProblem.cxx
@@ -23,9 +23,6 @@
 #include "openturns/BonminProblem.hxx"
 #include "openturns/SpecFunc.hxx"
 
-using namespace Bonmin;
-using namespace Ipopt;
-
 BEGIN_NAMESPACE_OPENTURNS
 
 /** Constructor with parameters */
@@ -34,7 +31,7 @@ BonminProblem::BonminProblem( const OptimizationProblem & optimProblem,
                               const UnsignedInteger maximumCallsNumber,
                               const Scalar maximumTimeDuration,
                               const std::chrono::steady_clock::time_point & t0)
-  : TMINLP()
+  : ::Bonmin::TMINLP()
   , optimProblem_(optimProblem)
   , startingPoint_(startingPoint)
   , evaluationInputHistory_(0, optimProblem.getDimension())
@@ -73,121 +70,45 @@ bool BonminProblem::get_nlp_info(int & n,
                                  Ipopt::TNLP::IndexStyleEnum & index_style)
 {
   // Number of variables
-  n = optimProblem_.getDimension();
-
-  // Number of constraints
-  m = 0;
-  if (optimProblem_.hasEqualityConstraint())
-    m += optimProblem_.getEqualityConstraint().getOutputDimension();
-  if (optimProblem_.hasInequalityConstraint())
-    m += optimProblem_.getInequalityConstraint().getOutputDimension();
-
+  // n = optimProblem_.getDimension();
+  // 
+  // // Number of constraints
+  // m = 0;
+  // if (optimProblem_.hasEqualityConstraint())
+  //   m += optimProblem_.getEqualityConstraint().getOutputDimension();
+  // if (optimProblem_.hasInequalityConstraint())
+  //   m += optimProblem_.getInequalityConstraint().getOutputDimension();
+
+  m = 3;
+  n = 4;
+  
   // All components of the jacobian and lagrangian's hessian are assumed to be non-zero
   nnz_jac_g = n * m;
   nnz_h_lag = n * n;
 
   // Index style is C-like
-  index_style = Ipopt::TNLP::C_STYLE;
+  index_style = ::Ipopt::TNLP::C_STYLE;
 
+  // std::cout << "BonminProblem::get_nlp_info m="<<m<<" n="<<n<<" nnz_jac_g="<<nnz_jac_g<<" nnz_h_lag="<< nnz_h_lag<<std::endl;
   return true;
 }
 
 bool BonminProblem::get_variables_types(int n, VariableTypeTable var_types)
 {
-  // Conversion from OptimizationProblemImplementation::VariableType to TMINLP::VariableType
-  for (int i = 0; i < n; ++i)
-  {
-    switch (optimProblem_.getVariablesType()[i])
-    {
-      case OptimizationProblemImplementation::CONTINUOUS:
-      {
-        var_types[i] = TMINLP::CONTINUOUS;
-        break;
-      }
-      case OptimizationProblemImplementation::INTEGER:
-      {
-        var_types[i] = TMINLP::INTEGER;
-        break;
-      }
-      case OptimizationProblemImplementation::BINARY:
-      {
-        var_types[i] = TMINLP::BINARY;
-        break;
-      }
-    }
-  }
-
+  var_types[0] = ::Bonmin::TMINLP::BINARY;
+  var_types[1] = ::Bonmin::TMINLP::CONTINUOUS;
+  var_types[2] = ::Bonmin::TMINLP::CONTINUOUS;
+  var_types[3] = ::Bonmin::TMINLP::INTEGER;
   return true;
 }
 
-bool BonminProblem::get_variables_linearity( int n,
+bool BonminProblem::get_variables_linearity(int ,
     LinearityTypeTable var_types)
 {
-  Function objective(optimProblem_.getObjective());
-
-  Indices objectiveLinearity(n, Ipopt::TNLP::NON_LINEAR);
-  if (objective.getEvaluation().getImplementation()->isActualImplementation())
-    for (UnsignedInteger i = 0; i < objective.getInputDimension(); ++i)
-      if (objective.isLinearlyDependent(i))
-        objectiveLinearity[i] = Ipopt::TNLP::LINEAR;
-
-  Indices equalityConstraintsLinearity(n, Ipopt::TNLP::LINEAR);
-  if (optimProblem_.hasEqualityConstraint())
-    for (UnsignedInteger i = 0; i < objective.getInputDimension(); ++i)
-      if (!optimProblem_.getEqualityConstraint().isLinearlyDependent(i))
-        equalityConstraintsLinearity[i] = Ipopt::TNLP::NON_LINEAR;
-
-  Indices inequalityConstraintsLinearity(n, Ipopt::TNLP::LINEAR);
-  if (optimProblem_.hasInequalityConstraint())
-    for (UnsignedInteger i = 0; i < objective.getInputDimension(); ++i)
-      if (!optimProblem_.getInequalityConstraint().isLinearlyDependent(i))
-        inequalityConstraintsLinearity[i] = Ipopt::TNLP::NON_LINEAR;
-
-  for (int i = 0; i < n; ++i)
-    if (  objectiveLinearity[i] == Ipopt::TNLP::LINEAR
-          && equalityConstraintsLinearity[i] == Ipopt::TNLP::LINEAR
-          && inequalityConstraintsLinearity[i] == Ipopt::TNLP::LINEAR)
-      var_types[i] = Ipopt::TNLP::LINEAR;
-    else
-      var_types[i] = Ipopt::TNLP::NON_LINEAR;
-
-  return true;
-}
-
-bool BonminProblem::get_constraints_linearity( int /*m*/,
-    LinearityTypeTable const_types)
-{
-  // Retrieving number of constraints
-  const UnsignedInteger nbEqualityConstraints = optimProblem_.getEqualityConstraint().getOutputDimension();
-  const UnsignedInteger nbInequalityConstraints = optimProblem_.getInequalityConstraint().getOutputDimension();
-
-  // Evaluation of constraints linearity to TMINLP::LinearityType
-  UnsignedInteger k = 0;
-
-  // "Linear" functions in Bonmin are of the form f(x) = A*x,
-  // i.e. f is linear and f(0) = 0
-
-  Point zero(optimProblem_.getDimension());
-  for (UnsignedInteger i = 0; i < nbEqualityConstraints; ++i)
-  {
-    if (optimProblem_.getEqualityConstraint().getMarginal(i).isLinear()
-        && (optimProblem_.getEqualityConstraint().getMarginal(i)(zero)[0] == 0))
-      const_types[k] = Ipopt::TNLP::LINEAR;
-    else
-      const_types[k] = Ipopt::TNLP::NON_LINEAR;
-    ++k;
-  }
-
-  for (UnsignedInteger i = 0; i < nbInequalityConstraints; ++i)
-  {
-    if (optimProblem_.getInequalityConstraint().getMarginal(i).isLinear()
-        && (optimProblem_.getInequalityConstraint().getMarginal(i)(zero)[0] == 0))
-      const_types[k] = Ipopt::TNLP::LINEAR;
-    else
-      const_types[k] = Ipopt::TNLP::NON_LINEAR;
-    ++k;
-  }
-
+  var_types[0] = ::Ipopt::TNLP::LINEAR;
+  var_types[1] = ::Ipopt::TNLP::NON_LINEAR;
+  var_types[2] = ::Ipopt::TNLP::NON_LINEAR;
+  var_types[3] = ::Ipopt::TNLP::LINEAR;
   return true;
 }
 
@@ -198,52 +119,20 @@ bool BonminProblem::get_bounds_info( int n,
                                      double* g_l,  // Lower bounds
                                      double* g_u)  // Upper bounds
 {
-  // BOUNDS:
-  // Conversion from OT::Interval to double array
-  if (optimProblem_.hasBounds())
+  for (int i = 0; i < n; ++i)
   {
-    Interval bounds(optimProblem_.getBounds());
-
-    for (int i = 0; i < n; ++i)
-    {
-      if (!bounds.getFiniteLowerBound()[i])
-        x_l[i] = SpecFunc::LowestScalar;
-      else
-        x_l[i] = bounds.getLowerBound()[i];
-
-      if (!bounds.getFiniteUpperBound()[i])
-        x_u[i] =  SpecFunc::MaxScalar;
-      else
-        x_u[i] = bounds.getUpperBound()[i];
-    }
+    x_l[i] = 0.0;
+    x_u[i] = std::numeric_limits<double>::max();
   }
-  else
+  x_u[0] = 1.0;  
+  x_u[3] = 5.0;
+
+  for (UnsignedInteger i = 0; i < 3; ++i)
   {
-    for (int i = 0; i < n; ++i)
-    {
-      x_l[i] = SpecFunc::LowestScalar;
-      x_u[i] =  SpecFunc::MaxScalar;
-    }
+    g_l[i] = 0.0;   // OT constraints are expressed as g(x) = 0 and h(x) >= 0
+    g_u[i] = std::numeric_limits<double>::max();
   }
 
-  // CONSTRAINTS:
-  int k = 0;
-  if (optimProblem_.hasEqualityConstraint())  // Equality constraints
-    for (UnsignedInteger i = 0; i < optimProblem_.getEqualityConstraint().getOutputDimension(); ++i)
-    {
-      g_l[k] = 0.0;   // OT constraints are expressed as g(x) = 0 and h(x) >= 0
-      g_u[k] = 0.0;
-      ++k;
-    }
-
-  if (optimProblem_.hasInequalityConstraint()) // Inequality constraints
-    for (UnsignedInteger i = 0; i < optimProblem_.getInequalityConstraint().getOutputDimension(); ++i)
-    {
-      g_l[k] = 0.0;   // OT constraints are expressed as g(x) = 0 and h(x) >= 0
-      g_u[k] = SpecFunc::MaxScalar;
-      ++k;
-    }
-
   return true;
 }
 
@@ -257,9 +146,8 @@ bool BonminProblem::get_starting_point(int /*n*/,
                                        bool /*init_lambda*/,
                                        double* /*lambda*/)
 {
-  // Conversion starting point from OT::Point to double array
-  std::copy(startingPoint_.begin(), startingPoint_.end(), x);
-
+  for (int i=0;i <4; ++i)
+    x[i] = 0.0;
   return true;
 }
 
@@ -269,135 +157,37 @@ bool BonminProblem::eval_f(int n,
                            bool /*new_x*/,
                            double& obj_value)
 {
-  // Convert x to OT::Point
-  Point xPoint(n);
-  std::copy(x, x + n, xPoint.begin());
-
-  // Computing objective function value
-  Point yPoint;
-  try
-  {
-    yPoint = optimProblem_.getObjective()(xPoint);
-  }
-  catch (const std::exception & exc)
-  {
-    LOGWARN(OSS() << "Bonmin went to an abnormal point x=" << xPoint.__str__() << " msg=" << exc.what());
-    return false;
-  }
-  if (optimProblem_.isMinimization())
-    obj_value = yPoint[0];
-  else
-    obj_value = -yPoint[0];
-
+  obj_value = -x[0] -x[1] -x[2];
   // track input/outputs
-  evaluationInputHistory_.add(xPoint);
-  evaluationOutputHistory_.add(yPoint);
-
-  // enforce time limit even before bonmin.time_limit can be taken into account
-  std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now();
-  const Scalar timeDuration = std::chrono::duration<Scalar>(t1 - t0_).count();
-  if ((maximumTimeDuration_ > 0.0) && (timeDuration > maximumTimeDuration_))
-  {
-    timeOut_ = true;
-    return false;
-  }
-
-  // Check callbacks
-  if (progressCallback_.first)
-  {
-    progressCallback_.first((100.0 * evaluationInputHistory_.getSize()) / maximumCallsNumber_, progressCallback_.second);
-  }
-  if (stopCallback_.first)
-  {
-    Bool stop = stopCallback_.first(stopCallback_.second);
-    if (stop)
-      return false;
-  }
+  evaluationInputHistory_.add(Point({x[0], x[1], x[2], x[3]}));
+  evaluationOutputHistory_.add(Point({obj_value}));
 
   return (evaluationInputHistory_.getSize() <= maximumCallsNumber_);
 }
 
 
-bool BonminProblem::eval_grad_f( int n,
-                                 const double* x,
+bool BonminProblem::eval_grad_f( int /*n*/,
+                                 const double* /*x*/,
                                  bool /*new_x*/,
                                  double* grad_f)
 {
-  // Convert x to OT::Point
-  Point xPoint(n);
-  std::copy(x, x + n, xPoint.begin());
-
-  // Computing objective function gradient
-  Matrix gradOT;
-  try
-  {
-    gradOT = optimProblem_.getObjective().gradient(xPoint);
-  }
-  catch (const std::exception & exc)
-  {
-    LOGWARN(OSS() << "Bonmin went to an abnormal point x=" << xPoint.__str__() << " msg=" << exc.what());
-    return false;
-  }
-
-  // Conversion from OT::Matrix to double array
-  for (int i = 0; i < n; ++i)
-    if (optimProblem_.isMinimization())
-      grad_f[i] = gradOT(i, 0);
-    else
-      grad_f[i] = -gradOT(i, 0);
 
+  grad_f[0] = -1.0;
+grad_f[1] = -1.0;
+grad_f[2] = -1.0;
   return true;
 }
 
-bool BonminProblem::eval_g(int n,
+bool BonminProblem::eval_g(int /*n*/,
                            const double* x,
                            bool /*new_x*/,
                            int /*m*/,
                            double* g)
 {
-  // Convert x to OT::Point
-  Point xPoint(n);
-  std::copy(x, x + n, xPoint.begin());
-
-  // Retrieve number of constraints
-  UnsignedInteger nbEqualityConstraints = 0;
-  UnsignedInteger nbInequalityConstraints = 0;
-  UnsignedInteger k = 0;
-
-  if (optimProblem_.hasEqualityConstraint())
-  {
-    nbEqualityConstraints = optimProblem_.getEqualityConstraint().getOutputDimension();
-    Point equalityConstraint;
-    try
-    {
-      equalityConstraint = (optimProblem_.getEqualityConstraint()(xPoint));
-    }
-    catch (const std::exception & exc)
-    {
-      LOGWARN(OSS() << "Bonmin went to an abnormal point x=" << xPoint.__str__() << " msg=" << exc.what());
-      return false;
-    }
-    std::copy(equalityConstraint.begin(), equalityConstraint.end(), g + k);
-    k += nbEqualityConstraints;
-  }
-
-  if (optimProblem_.hasInequalityConstraint())
-  {
-    nbInequalityConstraints = optimProblem_.getInequalityConstraint().getOutputDimension();
-    Point inequalityConstraint;
-    try
-    {
-      inequalityConstraint = optimProblem_.getInequalityConstraint()(xPoint);
-    }
-    catch (const std::exception & exc)
-    {
-      LOGWARN(OSS() << "Bonmin went to an abnormal point x=" << xPoint.__str__() << " msg=" << exc.what());
-      return false;
-    }
-    std::copy(inequalityConstraint.begin(), inequalityConstraint.end(), g + k);
-    k += nbInequalityConstraints;
-  }
-
+  g[0] = -(x[1] - 0.5)*(x[1] - 0.5) - (x[2] - 0.5)*(x[2] - 0.5) + 0.25;
+     g[1] = -x[0] +x[1];
+    g[2] = -x[0] -x[2]-x[3] + 2.0;
+  
   return true;
 }
 
@@ -431,30 +221,9 @@ bool BonminProblem::eval_jac_g(int n,
 
     // Filling values array
     UnsignedInteger k = 0;
-    UnsignedInteger nbEqualityConstraints = 0;
+    // UnsignedInteger nbEqualityConstraints = 0;
     UnsignedInteger nbInequalityConstraints = 0;
 
-    if (optimProblem_.hasEqualityConstraint())
-    {
-      nbEqualityConstraints = optimProblem_.getEqualityConstraint().getOutputDimension();
-      Matrix equalityConstraintGradient;
-      try
-      {
-        equalityConstraintGradient = optimProblem_.getEqualityConstraint().gradient(xPoint);
-      }
-      catch (const std::exception & exc)
-      {
-        LOGWARN(OSS() << "Bonmin went to an abnormal point x=" << xPoint.__str__() << " msg=" << exc.what());
-        return false;
-      }
-      for (UnsignedInteger i = 0; i < nbEqualityConstraints; ++i)
-        for (int j = 0; j < n; ++j)
-        {
-          values[k] = equalityConstraintGradient(j, i);
-          ++k;
-        }
-    }
-
     if (optimProblem_.hasInequalityConstraint())
     {
       nbInequalityConstraints = optimProblem_.getInequalityConstraint().getOutputDimension();
@@ -494,10 +263,10 @@ bool BonminProblem::eval_h(int n,
                            double* values)
 {
   // Retrieve number of constraints
-  UnsignedInteger nbEqualityConstraints = 0;
+  //UnsignedInteger nbEqualityConstraints = 0;
   UnsignedInteger nbInequalityConstraints = 0;
-  if (optimProblem_.hasEqualityConstraint())
-    nbEqualityConstraints = optimProblem_.getEqualityConstraint().getOutputDimension();
+  // if (optimProblem_.hasEqualityConstraint())
+    // nbEqualityConstraints = optimProblem_.getEqualityConstraint().getOutputDimension();
   if (optimProblem_.hasInequalityConstraint())
     nbInequalityConstraints = optimProblem_.getInequalityConstraint().getOutputDimension();
 
@@ -538,25 +307,6 @@ bool BonminProblem::eval_h(int n,
     int k = 0;
     SymmetricMatrix constraintsHessian(n, 0.0);
 
-    if (optimProblem_.hasEqualityConstraint())
-    {
-      SymmetricTensor equalityConstraintHessian;
-      try
-      {
-        equalityConstraintHessian = optimProblem_.getEqualityConstraint().hessian(xPoint);
-      }
-      catch (const std::exception & exc)
-      {
-        LOGWARN(OSS() << "Bonmin went to an abnormal point x=" << xPoint.__str__() << " msg=" << exc.what());
-        return false;
-      }
-      for (UnsignedInteger i = 0; i < nbEqualityConstraints; ++i)
-      {
-        constraintsHessian = constraintsHessian + lambda[k] * equalityConstraintHessian.getSheet(i);
-        ++k;
-      }
-    }
-
     if (optimProblem_.hasInequalityConstraint())
     {
       SymmetricTensor inequalityConstraintHessian;
@@ -582,42 +332,28 @@ bool BonminProblem::eval_h(int n,
     for (int i = 0; i < n; ++i)
       for (int j = 0; j < n; ++j)
       {
-        values[k] = lagrangianHessian(i, j);
+        values[k] = 0.0;
         ++k;
       }
+    values[5] = -2.0 * lambda[0];
+    values[10] = -2.0 * lambda[0];
   }
 
   return true;
 }
 
-bool BonminProblem::eval_gi(int n,
+bool BonminProblem::eval_gi(int /*n*/,
                             const double* x,
                             bool /*new_x*/,
                             int i,
                             double& gi)
 {
-  // Convert x to OT::Point
-  Point xPoint(n);
-  std::copy(x, x + n, xPoint.begin());
-
-  // Retrieve number of constraints
-  int nbEqualityConstraints = 0;
-  if (optimProblem_.hasEqualityConstraint())
-    nbEqualityConstraints = optimProblem_.getEqualityConstraint().getOutputDimension();
-
-  // Computing constraints values
-  try
-  {
-    if (i < nbEqualityConstraints)
-      gi = optimProblem_.getEqualityConstraint().getMarginal(i)(xPoint)[0];
-    else
-      gi = optimProblem_.getInequalityConstraint().getMarginal(i - nbEqualityConstraints)(xPoint)[0];
-  }
-  catch (const std::exception & exc)
-  {
-    LOGWARN(OSS() << "Bonmin went to an abnormal point x=" << xPoint.__str__() << " msg=" << exc.what());
-    return false;
-  }
+  if (i == 0)
+    gi = -(x[1] - 0.5)*(x[1] - 0.5) - (x[2] - 0.5)*(x[2] - 0.5) + 0.25;
+   if (i == 1)
+     gi = -x[0] +x[1];
+  if (i == 2)
+    gi = -x[0] -x[2]-x[3] + 2.0;
   return true;
 }
 
diff --git a/lib/src/Base/Optim/Pagmo.cxx b/lib/src/Base/Optim/Pagmo.cxx
index 6a9fc2482..8ef033f67 100644
--- a/lib/src/Base/Optim/Pagmo.cxx
+++ b/lib/src/Base/Optim/Pagmo.cxx
@@ -23,7 +23,7 @@
 #include "openturns/SpecFunc.hxx"
 #include "openturns/OTconfig.hxx"
 #include "openturns/DatabaseFunction.hxx"
-#include "openturns/BootstrapExperiment.hxx"
+// #include "openturns/BootstrapExperiment.hxx"
 
 #ifdef OPENTURNS_HAVE_PAGMO
 #include <pagmo/algorithm.hpp>
diff --git a/lib/src/Base/Optim/openturns/BonminProblem.hxx b/lib/src/Base/Optim/openturns/BonminProblem.hxx
index 79af481e0..099de79dd 100644
--- a/lib/src/Base/Optim/openturns/BonminProblem.hxx
+++ b/lib/src/Base/Optim/openturns/BonminProblem.hxx
@@ -72,8 +72,6 @@ public:
   bool get_variables_linearity( int n,
                                 LinearityTypeTable var_types);
 
-  bool get_constraints_linearity( int m,
-                                  LinearityTypeTable const_types);
 
   bool get_bounds_info( int n,
                         double* x_l,  // Lower bounds
diff --git a/lib/src/Base/openturns/OTBase.hxx b/lib/src/Base/openturns/OTBase.hxx
index 5fc788d0a..2aef4ce8b 100644
--- a/lib/src/Base/openturns/OTBase.hxx
+++ b/lib/src/Base/openturns/OTBase.hxx
@@ -34,6 +34,6 @@
 #include "openturns/OTStat.hxx"
 #include "openturns/OTType.hxx"
 #include "openturns/OTAlgo.hxx"
-#include "openturns/OTIterativeStat.hxx"
+// #include "openturns/OTIterativeStat.hxx"
 
 #endif /* OPENTURNS_OTBASE_HXX */
diff --git a/lib/src/CMakeLists.txt b/lib/src/CMakeLists.txt
index 2c8b587a5..ae255a4c1 100644
--- a/lib/src/CMakeLists.txt
+++ b/lib/src/CMakeLists.txt
@@ -7,7 +7,7 @@ ot_add_source_file (openturns_library_ok.c)
 
 # Recurse in subdirectories
 add_subdirectory (Base)
-add_subdirectory (Uncertainty)
+# add_subdirectory (Uncertainty)
 
 set_source_files_properties (Base/Func/SpecFunc/Faddeeva.cc PROPERTIES SKIP_UNITY_BUILD_INCLUSION ON)
 
diff --git a/lib/src/openturns/OT.hxx b/lib/src/openturns/OT.hxx
index 42e3942d9..8e9c9693a 100644
--- a/lib/src/openturns/OT.hxx
+++ b/lib/src/openturns/OT.hxx
@@ -49,6 +49,6 @@
  * @todo List the classes belonging to the external API of OpenTURNS
  */
 #include "openturns/OTBase.hxx"
-#include "openturns/OTUncertainty.hxx"
+// #include "openturns/OTUncertainty.hxx"
 
 #endif /* OPENTURNS_OT_HXX */
diff --git a/lib/test/t_Bonmin_std.cxx b/lib/test/t_Bonmin_std.cxx
index 02fdffeac..874a8512d 100644
--- a/lib/test/t_Bonmin_std.cxx
+++ b/lib/test/t_Bonmin_std.cxx
@@ -102,7 +102,7 @@ int main()
     const Point referenceSolution = {1.0, 1.0, 0.5, 0.0};
 
     // Defining solvers to test
-    const Description solvers(Bonmin::GetAlgorithmNames());
+    const Description solvers = {"B-BB"};
 
     for (UnsignedInteger i = 0; i < solvers.getSize(); ++i)
     {
