diff --git a/CMakeLists.txt b/CMakeLists.txt
index 685223460..6c466e41c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -9,35 +9,35 @@ set (CMAKE_TRY_COMPILE_CONFIGURATION ${CMAKE_BUILD_TYPE})
 
 project (openturns)
 
-option (USE_BISON                    "Looks for Bison if true and then build parser"                         ON)
-option (USE_CUBA                     "Use Cuba library"                                                      ON)
-option (USE_FLEX                     "Looks for Flex if true and then build lexer"                           ON)
-option (USE_TBB                      "Use Intel Threading Building Blocks library for multithreading"        ON)
+option (USE_BISON                    "Looks for Bison if true and then build parser"                         OFF)
+option (USE_CUBA                     "Use Cuba library"                                                      OFF)
+option (USE_FLEX                     "Looks for Flex if true and then build lexer"                           OFF)
+option (USE_TBB                      "Use Intel Threading Building Blocks library for multithreading"        OFF)
 option (USE_HMAT                     "Use HMat library (enforces GPL license)"                               OFF)
-option (USE_MUPARSER                 "Use muParser library"                                                  ON)
+option (USE_MUPARSER                 "Use muParser library"                                                  OFF)
 option (USE_EXPRTK                   "Use ExprTK library"                                                    ON)
-option (USE_LIBXML2                  "Use LibXml2 for XML support"                                           ON)
-option (USE_HDF5                     "Use HDF5 for high volume storage"                                      ON)
-option (USE_BOOST                    "Use Boost for distribution computation"                                ON)
-option (USE_MPFR                     "Use MPFR for real valued special functions computation"                ON)
-option (USE_MPC                      "Use MPC for complex valued special functions computation"              ON)
-option (USE_SPHINX                   "Use sphinx for documentation"                                          ON)
-option (USE_DOXYGEN                  "Use Doxygen for API documentation"                                     ON)
-option (USE_NLOPT                    "Use NLopt for additional optimization algorithms"                      ON)
-option (USE_CERES                    "Use Ceres Solver for additional optimization algorithms"               ON)
-option (USE_CMINPACK                 "Use CMinpack for additional optimization algorithms"                   ON)
-option (USE_DLIB                     "Use dlib for additional optimization algorithms"                       ON)
+option (USE_LIBXML2                  "Use LibXml2 for XML support"                                           OFF)
+option (USE_HDF5                     "Use HDF5 for high volume storage"                                      OFF)
+option (USE_BOOST                    "Use Boost for distribution computation"                                OFF)
+option (USE_MPFR                     "Use MPFR for real valued special functions computation"                OFF)
+option (USE_MPC                      "Use MPC for complex valued special functions computation"              OFF)
+option (USE_SPHINX                   "Use sphinx for documentation"                                          OFF)
+option (USE_DOXYGEN                  "Use Doxygen for API documentation"                                     OFF)
+option (USE_NLOPT                    "Use NLopt for additional optimization algorithms"                      OFF)
+option (USE_CERES                    "Use Ceres Solver for additional optimization algorithms"               OFF)
+option (USE_CMINPACK                 "Use CMinpack for additional optimization algorithms"                   OFF)
+option (USE_DLIB                     "Use dlib for additional optimization algorithms"                       OFF)
 option (USE_IPOPT                    "Use Ipopt for nonlinear optimization"                                  ON)
 option (USE_BONMIN                   "Use Bonmin for MINLP problems"                                         ON)
-option (USE_PAGMO                    "Use Pagmo for multi-objective optimization"                            ON)
-option (USE_SPECTRA                  "Use Spectra for eigenvalues computation"                               ON)
-option (USE_PRIMESIEVE               "Use primesieve for prime numbers generation"                           ON)
-option (USE_OPENMP                   "Use OpenMP to disable threading"                                       ON)
-option (USE_OPENBLAS                 "Use OpenBLAS to disable threading"                                     ON)
-option (USE_CXX17                    "Use C++17 standard"                                                    ON)
-option (USE_NANOFLANN                "Use nanoflann for Nearest Neighbor search"                             ON)
-
-option (BUILD_PYTHON                 "Build the python module for the library"                               ON)
+option (USE_PAGMO                    "Use Pagmo for multi-objective optimization"                            OFF)
+option (USE_SPECTRA                  "Use Spectra for eigenvalues computation"                               OFF)
+option (USE_PRIMESIEVE               "Use primesieve for prime numbers generation"                           OFF)
+option (USE_OPENMP                   "Use OpenMP to disable threading"                                       OFF)
+option (USE_OPENBLAS                 "Use OpenBLAS to disable threading"                                     OFF)
+option (USE_CXX17                    "Use C++17 standard"                                                    OFF)
+option (USE_NANOFLANN                "Use nanoflann for Nearest Neighbor search"                             OFF)
+
+option (BUILD_PYTHON                 "Build the python module for the library"                               OFF)
 option (BUILD_SHARED_LIBS            "Build shared libraries"                                                ON)
 
 # Defines our own module path
diff --git a/lib/include/openturns/OTtestcode.hxx b/lib/include/openturns/OTtestcode.hxx
index 680a86e49..ac795e71e 100644
--- a/lib/include/openturns/OTtestcode.hxx
+++ b/lib/include/openturns/OTtestcode.hxx
@@ -36,7 +36,7 @@
 #include "openturns/PlatformInfo.hxx"
 #include "openturns/SpecFunc.hxx"
 #include "openturns/TBB.hxx"
-#include "openturns/Distribution.hxx"
+// #include "openturns/Distribution.hxx"
 #include "openturns/Mesh.hxx"
 #include "openturns/Field.hxx"
 #include "openturns/ProcessSample.hxx"
@@ -412,38 +412,6 @@ inline void assert_almost_equal(const Tensor & a, const Tensor & b, const Scalar
     assert_almost_equal(a.getSheet(k), b.getSheet(k), rtol, atol, errMsg);
 }
 
-inline void assert_almost_equal(const Distribution &a, const Distribution &b, const Scalar rtol = 1.0e-5, const Scalar atol = 1.0e-8, const String errMsg = "")
-{
-  if (a.getImplementation()->getClassName() != b.getImplementation()->getClassName())
-    throw InvalidArgumentException(HERE) << "A and B must be the same distribution. A is a " << a.getImplementation()->getClassName() << " whereas B is a " << b.getImplementation()->getClassName();
-
-  if (a.getParameterDimension() != b.getParameterDimension())
-    throw InvalidArgumentException(HERE) << "A and B must have the same number of parameters. A has " << a.getParameterDimension() << " parameters whereas B has " << b.getParameterDimension() << " parameters.";
-
-  assert_almost_equal(a.getParameter(), b.getParameter(), rtol, atol, errMsg);
-}
-
-inline void assert_almost_equal(const Mesh & a, const Mesh & b, const Scalar rtol = 1.0e-5, const Scalar atol = 1.0e-8, const String errMsg = "")
-{
-  assert_almost_equal(a.getVertices(), b.getVertices(), rtol, atol, errMsg);
-  if (a.getSimplices() != b.getSimplices())
-    throw InvalidArgumentException(HERE) << "A and B must have the same simplices";
-}
-
-inline void assert_almost_equal(const Field & a, const Field & b, const Scalar rtol = 1.0e-5, const Scalar atol = 1.0e-8, const String errMsg = "")
-{
-  assert_almost_equal(a.getMesh(), b.getMesh(), rtol, atol, errMsg);
-  assert_almost_equal(a.getValues(), b.getValues(), rtol, atol, errMsg);
-}
-
-inline void assert_almost_equal(const ProcessSample & a, const ProcessSample & b, const Scalar rtol = 1.0e-5, const Scalar atol = 1.0e-8, const String errMsg = "")
-{
-  assert_almost_equal(a.getMesh(), b.getMesh(), rtol, atol, errMsg);
-  if (a.getSize() != b.getSize())
-    throw InvalidArgumentException(HERE) << "A and B must have the same size";
-  for (UnsignedInteger j = 0; j < a.getSize(); ++j)
-    assert_almost_equal(a.getField(j).getValues(), b.getField(j).getValues(), rtol, atol, errMsg);
-}
 
 template <typename T>
 void assert_equal(const T & a, const T & b, const String errMsg = "")
diff --git a/lib/src/Base/CMakeLists.txt b/lib/src/Base/CMakeLists.txt
index ea936172e..3d963dbd3 100644
--- a/lib/src/Base/CMakeLists.txt
+++ b/lib/src/Base/CMakeLists.txt
@@ -17,4 +17,4 @@ add_subdirectory (Optim)
 add_subdirectory (Solver)
 add_subdirectory (Stat)
 add_subdirectory (Type)
-add_subdirectory (IterativeStat)
+# add_subdirectory (IterativeStat)
diff --git a/lib/src/Base/Optim/BonminProblem.cxx b/lib/src/Base/Optim/BonminProblem.cxx
index 147ddd9ad..7a77f784c 100644
--- a/lib/src/Base/Optim/BonminProblem.cxx
+++ b/lib/src/Base/Optim/BonminProblem.cxx
@@ -73,18 +73,14 @@ bool BonminProblem::get_nlp_info(int & n,
                                  Ipopt::TNLP::IndexStyleEnum & index_style)
 {
   // Number of variables
-  n = optimProblem_.getDimension();
+  n = 4;
 
   // Number of constraints
-  m = 0;
-  if (optimProblem_.hasEqualityConstraint())
-    m += optimProblem_.getEqualityConstraint().getOutputDimension();
-  if (optimProblem_.hasInequalityConstraint())
-    m += optimProblem_.getInequalityConstraint().getOutputDimension();
+  m = 3;
 
   // All components of the jacobian and lagrangian's hessian are assumed to be non-zero
-  nnz_jac_g = n * m;
-  nnz_h_lag = n * n;
+  nnz_jac_g = 12;
+  nnz_h_lag = 16;
 
   // Index style is C-like
   index_style = Ipopt::TNLP::C_STYLE;
@@ -92,65 +88,22 @@ bool BonminProblem::get_nlp_info(int & n,
   return true;
 }
 
-bool BonminProblem::get_variables_types(int n, VariableTypeTable var_types)
+bool BonminProblem::get_variables_types(int, VariableTypeTable var_types)
 {
-  // Conversion from OptimizationProblemImplementation::VariableType to TMINLP::VariableType
-  for (int i = 0; i < n; ++i)
-  {
-    switch (optimProblem_.getVariablesType()[i])
-    {
-      case OptimizationProblemImplementation::CONTINUOUS:
-      {
-        var_types[i] = TMINLP::CONTINUOUS;
-        break;
-      }
-      case OptimizationProblemImplementation::INTEGER:
-      {
-        var_types[i] = TMINLP::INTEGER;
-        break;
-      }
-      case OptimizationProblemImplementation::BINARY:
-      {
-        var_types[i] = TMINLP::BINARY;
-        break;
-      }
-    }
-  }
-
+  var_types[0] = TMINLP::BINARY;
+  var_types[1] = TMINLP::CONTINUOUS;
+  var_types[2] = TMINLP::CONTINUOUS;
+  var_types[3] = TMINLP::INTEGER;
   return true;
 }
 
 bool BonminProblem::get_variables_linearity( int n,
     LinearityTypeTable var_types)
 {
-  Function objective(optimProblem_.getObjective());
-
-  Indices objectiveLinearity(n, Ipopt::TNLP::NON_LINEAR);
-  if (objective.getEvaluation().getImplementation()->isActualImplementation())
-    for (UnsignedInteger i = 0; i < objective.getInputDimension(); ++i)
-      if (objective.isLinearlyDependent(i))
-        objectiveLinearity[i] = Ipopt::TNLP::LINEAR;
-
-  Indices equalityConstraintsLinearity(n, Ipopt::TNLP::LINEAR);
-  if (optimProblem_.hasEqualityConstraint())
-    for (UnsignedInteger i = 0; i < objective.getInputDimension(); ++i)
-      if (!optimProblem_.getEqualityConstraint().isLinearlyDependent(i))
-        equalityConstraintsLinearity[i] = Ipopt::TNLP::NON_LINEAR;
-
-  Indices inequalityConstraintsLinearity(n, Ipopt::TNLP::LINEAR);
-  if (optimProblem_.hasInequalityConstraint())
-    for (UnsignedInteger i = 0; i < objective.getInputDimension(); ++i)
-      if (!optimProblem_.getInequalityConstraint().isLinearlyDependent(i))
-        inequalityConstraintsLinearity[i] = Ipopt::TNLP::NON_LINEAR;
-
-  for (int i = 0; i < n; ++i)
-    if (  objectiveLinearity[i] == Ipopt::TNLP::LINEAR
-          && equalityConstraintsLinearity[i] == Ipopt::TNLP::LINEAR
-          && inequalityConstraintsLinearity[i] == Ipopt::TNLP::LINEAR)
-      var_types[i] = Ipopt::TNLP::LINEAR;
-    else
-      var_types[i] = Ipopt::TNLP::NON_LINEAR;
-
+  var_types[0] = Ipopt::TNLP::LINEAR;
+  var_types[1] = Ipopt::TNLP::NON_LINEAR;
+  var_types[2] = Ipopt::TNLP::NON_LINEAR;
+  var_types[3] = Ipopt::TNLP::LINEAR;
   return true;
 }
 
@@ -187,6 +140,11 @@ bool BonminProblem::get_constraints_linearity( int /*m*/,
       const_types[k] = Ipopt::TNLP::NON_LINEAR;
     ++k;
   }
+  
+  std::cout <<"cst"<<nbEqualityConstraints+nbInequalityConstraints<<std::endl;
+  
+     // for (int i = 0; i < nbEqualityConstraints+nbInequalityConstraints; ++i)
+  // std::cout << "var_types i="<<i<<" vt="<<const_types[i]<<" LINEAR="<<Ipopt::TNLP::LINEAR<<" NL="<<Ipopt::TNLP::NON_LINEAR<<std::endl;
 
   return true;
 }
@@ -198,50 +156,19 @@ bool BonminProblem::get_bounds_info( int n,
                                      double* g_l,  // Lower bounds
                                      double* g_u)  // Upper bounds
 {
-  // BOUNDS:
-  // Conversion from OT::Interval to double array
-  if (optimProblem_.hasBounds())
-  {
-    Interval bounds(optimProblem_.getBounds());
-
-    for (int i = 0; i < n; ++i)
-    {
-      if (!bounds.getFiniteLowerBound()[i])
-        x_l[i] = SpecFunc::LowestScalar;
-      else
-        x_l[i] = bounds.getLowerBound()[i];
-
-      if (!bounds.getFiniteUpperBound()[i])
-        x_u[i] =  SpecFunc::MaxScalar;
-      else
-        x_u[i] = bounds.getUpperBound()[i];
-    }
-  }
-  else
+  for (int i = 0; i < n; ++i)
   {
-    for (int i = 0; i < n; ++i)
-    {
-      x_l[i] = SpecFunc::LowestScalar;
-      x_u[i] =  SpecFunc::MaxScalar;
-    }
+    x_l[i] = 0.0;
+    x_u[i] = SpecFunc::MaxScalar;
   }
+  x_u[0] = 1.0;
+  x_u[3] = 5.0;
+  
 
-  // CONSTRAINTS:
-  int k = 0;
-  if (optimProblem_.hasEqualityConstraint())  // Equality constraints
-    for (UnsignedInteger i = 0; i < optimProblem_.getEqualityConstraint().getOutputDimension(); ++i)
+    for (UnsignedInteger i = 0; i < 3; ++i)
     {
-      g_l[k] = 0.0;   // OT constraints are expressed as g(x) = 0 and h(x) >= 0
-      g_u[k] = 0.0;
-      ++k;
-    }
-
-  if (optimProblem_.hasInequalityConstraint()) // Inequality constraints
-    for (UnsignedInteger i = 0; i < optimProblem_.getInequalityConstraint().getOutputDimension(); ++i)
-    {
-      g_l[k] = 0.0;   // OT constraints are expressed as g(x) = 0 and h(x) >= 0
-      g_u[k] = SpecFunc::MaxScalar;
-      ++k;
+      g_l[i] = 0.0;
+      g_u[i] = SpecFunc::MaxScalar;
     }
 
   return true;
@@ -257,9 +184,9 @@ bool BonminProblem::get_starting_point(int /*n*/,
                                        bool /*init_lambda*/,
                                        double* /*lambda*/)
 {
-  // Conversion starting point from OT::Point to double array
-  std::copy(startingPoint_.begin(), startingPoint_.end(), x);
-
+  for (int i = 0; i < 4; ++ i)
+    x[i] = 0.0;
+  
   return true;
 }
 
@@ -269,52 +196,13 @@ bool BonminProblem::eval_f(int n,
                            bool /*new_x*/,
                            double& obj_value)
 {
-  // Convert x to OT::Point
-  Point xPoint(n);
-  std::copy(x, x + n, xPoint.begin());
-
-  // Computing objective function value
-  Point yPoint;
-  try
-  {
-    yPoint = optimProblem_.getObjective()(xPoint);
-  }
-  catch (const std::exception & exc)
-  {
-    LOGWARN(OSS() << "Bonmin went to an abnormal point x=" << xPoint.__str__() << " msg=" << exc.what());
-    return false;
-  }
-  if (optimProblem_.isMinimization())
-    obj_value = yPoint[0];
-  else
-    obj_value = -yPoint[0];
+  obj_value = -x[0] -x[1] -x[2];
 
   // track input/outputs
-  evaluationInputHistory_.add(xPoint);
-  evaluationOutputHistory_.add(yPoint);
-
-  // enforce time limit even before bonmin.time_limit can be taken into account
-  std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now();
-  const Scalar timeDuration = std::chrono::duration<Scalar>(t1 - t0_).count();
-  if ((maximumTimeDuration_ > 0.0) && (timeDuration > maximumTimeDuration_))
-  {
-    timeOut_ = true;
-    return false;
-  }
+  evaluationInputHistory_.add(Point({x[0], x[1], x[2], x[3]}));
+  evaluationOutputHistory_.add(Point({obj_value}));
 
-  // Check callbacks
-  if (progressCallback_.first)
-  {
-    progressCallback_.first((100.0 * evaluationInputHistory_.getSize()) / maximumCallsNumber_, progressCallback_.second);
-  }
-  if (stopCallback_.first)
-  {
-    Bool stop = stopCallback_.first(stopCallback_.second);
-    if (stop)
-      return false;
-  }
-
-  return (evaluationInputHistory_.getSize() <= maximumCallsNumber_);
+  return true;
 }
 
 
@@ -323,29 +211,10 @@ bool BonminProblem::eval_grad_f( int n,
                                  bool /*new_x*/,
                                  double* grad_f)
 {
-  // Convert x to OT::Point
-  Point xPoint(n);
-  std::copy(x, x + n, xPoint.begin());
-
-  // Computing objective function gradient
-  Matrix gradOT;
-  try
-  {
-    gradOT = optimProblem_.getObjective().gradient(xPoint);
-  }
-  catch (const std::exception & exc)
-  {
-    LOGWARN(OSS() << "Bonmin went to an abnormal point x=" << xPoint.__str__() << " msg=" << exc.what());
-    return false;
-  }
-
   // Conversion from OT::Matrix to double array
-  for (int i = 0; i < n; ++i)
-    if (optimProblem_.isMinimization())
-      grad_f[i] = gradOT(i, 0);
-    else
-      grad_f[i] = -gradOT(i, 0);
-
+  for (int i = 0; i < 3; ++i)
+      grad_f[i] = -1.0;
+  grad_f[3] = 0.0;
   return true;
 }
 
diff --git a/lib/src/Base/Optim/Pagmo.cxx b/lib/src/Base/Optim/Pagmo.cxx
index 6a9fc2482..8ef033f67 100644
--- a/lib/src/Base/Optim/Pagmo.cxx
+++ b/lib/src/Base/Optim/Pagmo.cxx
@@ -23,7 +23,7 @@
 #include "openturns/SpecFunc.hxx"
 #include "openturns/OTconfig.hxx"
 #include "openturns/DatabaseFunction.hxx"
-#include "openturns/BootstrapExperiment.hxx"
+// #include "openturns/BootstrapExperiment.hxx"
 
 #ifdef OPENTURNS_HAVE_PAGMO
 #include <pagmo/algorithm.hpp>
diff --git a/lib/src/Base/openturns/OTBase.hxx b/lib/src/Base/openturns/OTBase.hxx
index 5fc788d0a..2aef4ce8b 100644
--- a/lib/src/Base/openturns/OTBase.hxx
+++ b/lib/src/Base/openturns/OTBase.hxx
@@ -34,6 +34,6 @@
 #include "openturns/OTStat.hxx"
 #include "openturns/OTType.hxx"
 #include "openturns/OTAlgo.hxx"
-#include "openturns/OTIterativeStat.hxx"
+// #include "openturns/OTIterativeStat.hxx"
 
 #endif /* OPENTURNS_OTBASE_HXX */
diff --git a/lib/src/CMakeLists.txt b/lib/src/CMakeLists.txt
index 2c8b587a5..ae255a4c1 100644
--- a/lib/src/CMakeLists.txt
+++ b/lib/src/CMakeLists.txt
@@ -7,7 +7,7 @@ ot_add_source_file (openturns_library_ok.c)
 
 # Recurse in subdirectories
 add_subdirectory (Base)
-add_subdirectory (Uncertainty)
+# add_subdirectory (Uncertainty)
 
 set_source_files_properties (Base/Func/SpecFunc/Faddeeva.cc PROPERTIES SKIP_UNITY_BUILD_INCLUSION ON)
 
diff --git a/lib/src/openturns/OT.hxx b/lib/src/openturns/OT.hxx
index 42e3942d9..8e9c9693a 100644
--- a/lib/src/openturns/OT.hxx
+++ b/lib/src/openturns/OT.hxx
@@ -49,6 +49,6 @@
  * @todo List the classes belonging to the external API of OpenTURNS
  */
 #include "openturns/OTBase.hxx"
-#include "openturns/OTUncertainty.hxx"
+// #include "openturns/OTUncertainty.hxx"
 
 #endif /* OPENTURNS_OT_HXX */
diff --git a/lib/test/t_Bonmin_std.cxx b/lib/test/t_Bonmin_std.cxx
index 02fdffeac..874a8512d 100644
--- a/lib/test/t_Bonmin_std.cxx
+++ b/lib/test/t_Bonmin_std.cxx
@@ -102,7 +102,7 @@ int main()
     const Point referenceSolution = {1.0, 1.0, 0.5, 0.0};
 
     // Defining solvers to test
-    const Description solvers(Bonmin::GetAlgorithmNames());
+    const Description solvers = {"B-BB"};
 
     for (UnsignedInteger i = 0; i < solvers.getSize(); ++i)
     {
